<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXJ5Q7LKKE"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LXJ5Q7LKKE');
    </script>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../styles.css?v=8e4c2f">
    <link rel="icon" type="image/png" href="../icons/favicon.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy.Top F2P Deck Optimizer</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
    /* Add these new styles after the existing styles */
    .header-container {
        background: linear-gradient(135deg, #333333 0%, #2a2a2a 100%);
        border: 2px solid #555;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .header-title {
        margin: 0 0 15px 0;
        text-align: center;
        color: white;
        font-size: 1.8em;
        font-weight: bold;
    }

    .input-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
    }

    .input-row label {
        color: white;
        font-weight: bold;
        white-space: nowrap;
        min-width: 100px;
    }

    .input-row input {
        flex: 1;
        min-width: 200px;
        max-width: 400px;
        padding: 8px 12px;
        border: 1px solid #555;
        border-radius: 6px;
        background: #444;
        color: white;
        font-size: 0.9em;
    }

    .input-row input::placeholder {
        color: #aaa;
    }

    .input-row button {
        background: #007bff;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        font-weight: bold;
        cursor: pointer;
        white-space: nowrap;
    }

    .input-row button:hover {
        background: #0056b3;
    }

    .status-div {
        color: #ccc;
        font-size: 0.9em;
        text-align: center;
        min-height: 20px;
        margin-top: 5px;
    }

    div.card img.card-image {
        width: 50% !important;
        height: auto !important;
        border-radius: 0 !important;
        display: block !important;
        margin: 0 auto !important;
        object-fit: contain !important;
        max-width: 120px !important;
    }

    .star-section {
        margin: 30px 0;
        padding: 20px;
        border: 2px solid #555;
        border-radius: 12px;
        background: linear-gradient(135deg, #333333 0%, #2a2a2a 100%);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .star-header {
        margin: 0 0 20px 0;
        padding: 10px 15px;
        background: linear-gradient(135deg, #495057 0%, #343a40 100%);
        color: white;
        border-radius: 8px;
        font-size: 1.5em;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        justify-content: flex-start;
    }

    .card {
        border: 1px solid #555;
        padding: 12px;
        width: 180px;
        text-align: center;
        border-radius: 8px;
        background: #333333;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        position: relative; /* Added for positioning the count badge */
    }

    .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    }

    .card-count {
        position: absolute;
        top: -5px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        color: black;
        border: 1px solid black;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 0.65em;
        font-weight: bold;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        z-index: 10;
        white-space: nowrap;
    }

    .card-info {
        margin-top: 8px;
        font-size: 0.9em;
        line-height: 1.4;
        color: white !important;
    }

    .card-info b {
        color: white !important;
    }

    .median-score {
        margin-top: 6px;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 6px;
    }

    .median-label {
        font-size: 0.7em;
        color: #ccc;
        font-weight: bold;
    }

    .median-badge {
        background: #444;
        color: black;
        padding: 3px 8px;
        border-radius: 4px;
        border: 2px solid #333;
        font-size: 0.75em;
        font-weight: bold;
        min-width: 35px;
        text-align: center;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .last-5-days {
        margin-top: 8px;
        font-size: 0.7em;
        color: #ccc;
        font-weight: bold;
    }

    .score-row {
        display: flex;
        justify-content: center;
        gap: 3px;
        margin-top: 4px;
        flex-wrap: wrap;
    }

    .score-badge {
        background: #444;
        color: white;
        padding: 2px 4px;
        border-radius: 8px;
        border: 1px solid #666;
        font-size: 0.8em;
        font-weight: bold;
        min-width: 25px;
        text-align: center;
    }

    /* Update the optimal-deck-section styling to use league colors */
    .optimal-deck-section {
        margin: 20px 0;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    /* Remove the optimal-deck-header styles since we're removing it */

    /* Update generate-btn to be more prominent */
    .generate-btn {
        color: black;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-weight: bold;
        cursor: pointer;
        margin-bottom: 15px;
        font-size: 1.1em;
        width: 100%;
    }

    .generate-btn:hover {
        opacity: 0.9;
    }

    .deck-stats {
        margin: 10px 0;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        font-size: 0.9em;
        color: white;
    }

    .deck-cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        margin-top: 15px;
    }

    .deck-card {
        border: 1px solid #d4a574;
        padding: 8px;
        width: 140px;
        text-align: center;
        border-radius: 8px;
        background: rgba(212, 165, 116, 0.2);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .deck-card img {
        width: 60px !important;
        height: auto !important;
        border-radius: 0 !important;
        display: block !important;
        margin: 0 auto 8px auto !important;
        object-fit: contain !important;
    }

    /* New styles for league sections */
    #optimal-decks {
        display: none;
        margin-top: 0;
    }

    .league-section {
        margin: 20px 0;
        padding: 15px;
        border: 2px solid #777;
        border-radius: 10px;
        background: linear-gradient(135deg, #222 0%, #111 100%);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    }

    .league-header {
        margin: 0 0 15px 0;
        padding: 10px 15px;
        background: linear-gradient(135deg, #777 0%, #555 100%);
        color: white;
        border-radius: 8px;
        font-size: 1.4em;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .league-description {
        font-size: 0.9em;
        color: #ccc;
        margin-bottom: 10px;
        text-align: center;
    }

    .generate-league-btn {
        display: block;
        width: 100%;
        background: #777;
        color: white;
        border: none;
        padding: 10px 0;
        border-radius: 6px;
        font-weight: bold;
        cursor: pointer;
        margin-bottom: 15px;
        font-size: 1em;
        text-align: center;
    }

    .generate-league-btn:hover {
        background: #666;
    }

    /* Replace the optimal-deck-header styles since we're removing it */
    .optimal-deck-header {
        display: none;
    }

    /* Add this CSS after the existing styles */

    .main-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
        margin-top: 20px;
    }

    .content-columns {
        display: flex;
        gap: 20px;
    }

    .left-side {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .right-column {
        flex: 1;
        min-width: 0;
    }

    /* Make the layout responsive for smaller screens */
    @media (max-width: 1200px) {
        .content-columns {
            flex-direction: column;
        }
    }

    /* Add these styles to the existing <style> section */

    .filter-container {
        background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        border: 2px solid #444;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .filter-title {
        color: white;
        font-size: 1.1em;
        font-weight: bold;
        margin: 0 0 10px 0;
    }

    .checkbox-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px; /* Slightly reduced gap */
    }

    .checkbox-label {
        display: flex;
        align-items: center;
        font-size: 11px; /* Reduced from 14px */
        cursor: pointer;
        padding: 5px 8px; /* Slightly smaller padding */
        border-radius: 4px;
        user-select: none;
        color: #fff;
        background: #1a1a1a;
        border: 1px solid #333;
        transition: all 0.2s;
    }

    .checkbox-label:hover {
        background: #3a3a3a;
    }

    .checkbox-label input {
        margin-right: 6px;
        accent-color: transparent;
        transform: scale(0.8); /* Reduce checkbox size by 20% */
    }

    /* Rarity-specific colors for checked state */
    .checkbox-label.legendary input:checked {
        accent-color: #CACBD4;
    }

    .checkbox-label.epic input:checked {
        accent-color: #E890FE;
    }

    .checkbox-label.rare input:checked {
        accent-color: #00FFE2;
    }

    .checkbox-label.common input:checked {
        accent-color: #94FF00;
    }

    /* Rarity-specific colors for label border */
    .checkbox-label.legendary {
        border-left: 3px solid #CACBD4;
    }

    .checkbox-label.epic {
        border-left: 3px solid #E890FE;
    }

    .checkbox-label.rare {
        border-left: 3px solid #00FFE2;
    }

    .checkbox-label.common {
        border-left: 3px solid #94FF00;
    }

    /* Double Range Slider Styles */
    .filter-row {
        display: flex;
        align-items: center;
        gap: 20px;
        flex-wrap: wrap;
    }

    .double_range_slider_box {
        position: relative;
        width: 100%;
        max-width: 300px;
        height: 36px;
        background: rgba(30, 30, 30, 0.6);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border-radius: 6px;
        padding: 0 50px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        margin: 0 40px;
        box-sizing: border-box;
    }

    .range_slider {
        position: relative;
        width: 100%;
        height: 4px;
        background: #444;
        border-radius: 2px;
    }

    .range_slider .track {
        position: absolute;
        height: 4px;
        background: #FACC15;
        border-radius: 2px;
        top: 0;
    }

    .range_slider input[type="range"] {
        position: absolute;
        width: 100%;
        height: 4px;
        top: 0;
        background: transparent;
        pointer-events: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
    }

    .range_slider input[type="range"]::-webkit-slider-thumb {
        pointer-events: all;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #FACC15;
        border: 2px solid #333;
        cursor: pointer;
        -webkit-appearance: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .range_slider input[type="range"]::-moz-range-thumb {
        pointer-events: all;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #FACC15;
        border: 2px solid #333;
        cursor: pointer;
        -moz-appearance: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .range_values {
        position: absolute;
        left: -40px;
        top: 50%;
        transform: translateY(-50%);
        color: #FACC15;
        font-size: 12px;
        font-weight: bold;
    }

    .range_values_right {
        position: absolute;
        right: -40px;
        top: 50%;
        transform: translateY(-50%);
        color: #FACC15;
        font-size: 12px;
        font-weight: bold;
    }

    .star-filter-label {
        color: white;
        font-size: 1.1em;
        font-weight: bold;
        white-space: nowrap;
    }
    </style>
</head>
<body>
    <!-- Replace the header section with this compact container -->
    <div class="header-container">
        <h2 class="header-title">Fantasy.Top F2P Deck Optimizer</h2>
        <div class="input-row">
            <label for="token">Bearer Token:</label>
            <input type="text" id="token" placeholder="Paste your Bearer token here (starts with 'ey')">
            <button id="fetchBtn">Fetch Cards</button>
        </div>
        <div id="status" class="status-div"></div>
    </div>
    
    <!-- Replace the main-content section with this updated structure: -->
    <div class="main-content">
        <div class="content-columns">
            <div class="left-side">
                <div class="filter-container">
                    <div class="filter-title">Filter Cards</div>
                    <div class="filter-row">
                        <div class="checkbox-group">
                            <label class="checkbox-label legendary">
                                <input type="checkbox" id="filterLegendary" checked> Legendary
                            </label>
                            <label class="checkbox-label epic">
                                <input type="checkbox" id="filterEpic" checked> Epic
                            </label>
                            <label class="checkbox-label rare">
                                <input type="checkbox" id="filterRare" checked> Rare
                            </label>
                            <label class="checkbox-label common">
                                <input type="checkbox" id="filterCommon" checked> Common
                            </label>
                        </div>
                        
                        <div class="star-filter-label">Stars:</div>
                        <div class="double_range_slider_box">
                            <div class="range_values" id="minStarValue">1</div>
                            <div class="range_slider">
                                <div class="track" id="starTrack"></div>
                                <input type="range" id="minStarRange" min="1" max="8" value="1" step="1">
                                <input type="range" id="maxStarRange" min="1" max="8" value="8" step="1">
                            </div>
                            <div class="range_values_right" id="maxStarValue">8</div>
                        </div>
                    </div>
                </div>
                
                <div id="result"></div>
            </div>
            
            <div class="right-column">
                <div id="optimal-decks" style="display: none;">
                    <div class="optimal-deck-section" style="border: 2px solid #FE8946; background: linear-gradient(135deg, rgba(254, 137, 70, 0.2) 0%, rgba(212, 115, 42, 0.2) 100%);">
                        <button id="generateBronzeBtn" class="generate-btn" style="background: #FE8946;">Generate Bronze Deck</button>
                        <div id="bronze-deck-result"></div>
                    </div>

                    <div class="optimal-deck-section" style="border: 2px solid #A7B8CF; background: linear-gradient(135deg, rgba(167, 184, 207, 0.2) 0%, rgba(138, 157, 184, 0.2) 100%);">
                        <button id="generateSilverBtn" class="generate-btn" style="background: #A7B8CF;">Generate Silver Deck</button>
                        <div id="silver-deck-result"></div>
                    </div>

                    <div class="optimal-deck-section" style="border: 2px solid #FFCE52; background: linear-gradient(135deg, rgba(255, 206, 82, 0.2) 0%, rgba(230, 184, 74, 0.2) 100%);">
                        <button id="generateGoldBtn" class="generate-btn" style="background: #FFCE52;">Generate Gold Deck</button>
                        <div id="gold-deck-result"></div>
                    </div>

                    <div class="optimal-deck-section" style="border: 2px solid #C78BFF; background: linear-gradient(135deg, rgba(199, 139, 255, 0.2) 0%, rgba(176, 118, 230, 0.2) 100%);">
                        <button id="generateEliteBtn" class="generate-btn" style="background: #C78BFF;">Generate Elite Deck</button>
                        <div id="elite-deck-result"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    const supabaseUrl = 'https://hhcuqhvmzwmehdsaamhn.supabase.co'
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoY3VxaHZtendtZWhkc2FhbWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzIwMTIsImV4cCI6MjA1MDU0ODAxMn0.xJNGoFLnpnmQGLj8RY_4VLmefPmFzuOyiVHLvFtPkkE'
    const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey)

    // Global variable to store the query results
    let f2pScoresData = null;
    let currentCards = null; // Store current cards for deck generation

    // Color cache and helper functions
    const colorCache = new Map();

    function lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    function getColorForRank(value, maxValue = 1000, higherIsBetter = true) {
        const cacheKey = `${value}_${maxValue}_${higherIsBetter}`;
        if (colorCache.has(cacheKey)) {
            return colorCache.get(cacheKey);
        }

        let ratio;
        if (higherIsBetter) {
            ratio = Math.min(value / maxValue, 1);
        } else {
            // For ranks - lower is better
            ratio = 1 - (Math.min(value / maxValue, 1));
        }

        if (ratio < 0.5) {
            // Red to Yellow transition
            const r = Math.round(lerp(215, 254, ratio * 2));
            const g = Math.round(lerp(48, 224, ratio * 2));
            const b = Math.round(lerp(39, 139, ratio * 2));
            const color = `rgb(${r}, ${g}, ${b})`;
            colorCache.set(cacheKey, color);
            return color;
        } else {
            // Yellow to Green transition
            const r = Math.round(lerp(254, 44, (ratio - 0.5) * 2));
            const g = Math.round(lerp(224, 162, (ratio - 0.5) * 2));
            const b = Math.round(lerp(139, 95, (ratio - 0.5) * 2));
            const color = `rgb(${r}, ${g}, ${b})`;
            colorCache.set(cacheKey, color);
            return color;
        }
    }

    // Function to fetch and store the F2P scores data
    async function fetchF2PScores() {
        try {
            console.log('Fetching F2P scores data...');
            const { data, error } = await supabaseClient
                .from('vwf2p_here_24hr_scores')
                .select('hero_id,hero_name, posts_per_day,time_24h_from_now, prior_5_days, prior_5_weeks_dow_hh');

            if (error) {
                console.error('Error fetching F2P scores:', error);
                return null;
            }

            console.log('F2P scores data fetched successfully:', data.length, 'records');
            f2pScoresData = data;
            return data;
        } catch (err) {
            console.error('Exception while fetching F2P scores:', err);
            return null;
        }
    }

    // Function to get F2P score for a specific hero
    function getF2PScore(heroId) {  // Changed from heroHandle to heroId
        if (!f2pScoresData) {
            console.warn('F2P scores data not loaded yet');
            return null;
        }
        
        return f2pScoresData.find(score => score.hero_id === heroId);  // Changed to match by hero_id
    }

    // Function to get all F2P scores (for when you need the full dataset)
    function getAllF2PScores() {
        return f2pScoresData;
    }

    async function fetchAllCards(token) {
        let allCards = [];
        const offset = 0;
        const limit = 500;
        let total = null;

        document.getElementById('status').textContent = `Fetching ${limit} cards at offset ${offset}...`;
        const url = `https://api-v2.fantasy.top/free-to-play/get-player-inventory?limit=${limit}&offset=${offset}&sortBy=expected_score_desc`;
        const resp = await fetch(url, {
            headers: {
                "accept": "application/json, text/plain, */*",
                "authorization": "Bearer " + token
            }
        });
        if (!resp.ok) {
            throw new Error("API error: " + resp.status);
        }
        const json = await resp.json();
        total = json.total;
        allCards = json.data;
        document.getElementById('status').textContent = `Fetched ${allCards.length} of ${total} cards.`;
        return { total, cards: allCards };
    }

    // Helper function to format date for tooltip
    function formatDateForTooltip(dateString) {
        const date = new Date(dateString);
        const options = { 
            weekday: 'short', 
            month: 'short', 
            day: 'numeric' 
        };
        return date.toLocaleDateString('en-US', options);
    }

    // Helper function to calculate median of 4 highest scores
    function calculateMedianScore(scores) {
        if (!scores || scores.length === 0) return null;
        
        // Get all max_score values and sort them descending
        const maxScores = scores.map(s => s.max_score).sort((a, b) => b - a);
        
        // Take the 4 highest scores (or all if less than 4)
        const top4 = maxScores.slice(0, Math.min(4, maxScores.length));
        
        if (top4.length === 0) return null;
        
        // Calculate median
        top4.sort((a, b) => a - b); // Sort ascending for median calculation
        const mid = Math.floor(top4.length / 2);
        
        if (top4.length % 2 === 0) {
            return (top4[mid - 1] + top4[mid]) / 2;
        } else {
            return top4[mid];
        }
    }

    // League configurations with rarity quantity limits (FIXED RARITY NUMBERS)
    const leagueConfigs = {
        bronze: {
            name: "Bronze",
            color: "#FE8946",
            maxStars: 18,
            rarityLimits: {
                4: 5 // max 5 commons (rarity 4)
            },
            description: "5 common cards, max 18 stars"
        },
        silver: {
            name: "Silver", 
            color: "#A7B8CF",
            maxStars: 23,
            rarityLimits: {
                3: 3, // max 3 rares (rarity 3)
                4: 5  // max 5 commons (rarity 4)
            },
            description: "Max 3 rares + commons, max 23 stars"
        },
        gold: {
            name: "Gold",
            color: "#FFCE52", 
            maxStars: 25,
            rarityLimits: {
                2: 2, // max 2 epics (rarity 2)
                3: 4, // max 4 rares (rarity 3)
                4: 5  // max 5 commons (rarity 4)
            },
            description: "Max 2 epics + max 4 rares + commons, max 25 stars"
        },
        elite: {
            name: "Elite",
            color: "#C78BFF",
            maxStars: 50,
            rarityLimits: {
                1: 5, // max 5 legendaries (rarity 1)
                2: 5, // max 5 epics (rarity 2)
                3: 5, // max 5 rares (rarity 3)
                4: 5  // max 5 commons (rarity 4)
            },
            description: "5 cards of any rarity, max 50 stars"
        }
    };

    // Helper function to check if a combination respects rarity limits
    function isValidRarityCombination(cards, config) {
        const rarityCounts = {};
        
        // Count cards by rarity
        cards.forEach(card => {
            rarityCounts[card.rarity] = (rarityCounts[card.rarity] || 0) + 1;
        });
        
        // Check each rarity limit
        for (const [rarity, limit] of Object.entries(config.rarityLimits)) {
            const rarityNum = parseInt(rarity);
            const count = rarityCounts[rarityNum] || 0;
            if (count > limit) {
                return false;
            }
        }
        
        return true;
    }

    // Helper function to check if a combination has unique hero_ids
    function hasUniqueHeroes(cards) {
        const heroIds = new Set();
        for (const card of cards) {
            if (heroIds.has(card.hero_id)) {
                return false; // Duplicate hero_id found
            }
            heroIds.add(card.hero_id);
        }
        return true; // All hero_ids are unique
    }

    // Generic function to generate optimal deck for any league
    function generateOptimalDeck(leagueKey) {
        if (!currentCards) {
            document.getElementById(`${leagueKey}-deck-result`).innerHTML = '<p style="color: #ff6b6b;">No cards loaded. Please fetch cards first.</p>';
            return;
        }

        const config = leagueConfigs[leagueKey];
        if (!config) {
            console.error('Invalid league key:', leagueKey);
            return;
        }

        console.log(`Generating optimal ${config.name} deck...`);

        // Filter for league eligible cards (any rarity that has a limit > 0)
        const allowedRarities = Object.keys(config.rarityLimits).map(r => parseInt(r));
        const eligibleCards = currentCards.filter(card => {
            const hasMedianScore = card.medianScore !== null && card.medianScore !== undefined;
            const isAllowedRarity = allowedRarities.includes(card.rarity);
            return isAllowedRarity && hasMedianScore && card.count > 0;
        });

        console.log(`${config.name} eligible cards found:`, eligibleCards.length);

        if (eligibleCards.length === 0) {
            const rarityNames = allowedRarities.map(r => {
                const rarityMap = { 1: "legendary", 2: "epic", 3: "rare", 4: "common" };
                return rarityMap[r];
            }).join(', ');

            document.getElementById(`${leagueKey}-deck-result`).innerHTML = `
                <p style="color: #ff6b6b;">No eligible cards found for ${config.name} league.</p>
                <p style="color: #ccc; font-size: 0.9em;">Allowed rarities: ${rarityNames}</p>
                <p style="color: #ccc; font-size: 0.9em;">Cards with median scores: ${currentCards.filter(c => c.medianScore !== null).length}</p>
            `;
            return;
        }

        // Strategic card selection based on league requirements
        const topCards = [];
        
        // For each allowed rarity, get the top cards we might need
        allowedRarities.forEach(rarity => {
            const maxNeeded = config.rarityLimits[rarity];
            const cardsOfThisRarity = eligibleCards.filter(card => card.rarity === rarity);
            
            // Sort by median score descending
            cardsOfThisRarity.sort((a, b) => (b.medianScore || 0) - (a.medianScore || 0));
            
            // Calculate how many cards to take for this rarity
            let cardsToTake;
            if (leagueKey === 'bronze') {
                // Bronze: max 5 commons, 8 star levels, so 5 * 8 = 40 cards
                cardsToTake = maxNeeded * 8;
            } else if (leagueKey === 'silver') {
                // Silver: max 3 rares (3 * 8 = 24), max 5 commons (5 * 8 = 40)
                cardsToTake = maxNeeded * 8;
            } else if (leagueKey === 'gold') {
                // Gold: max 2 epics (2 * 8 = 16), max 4 rares (4 * 8 = 32), max 5 commons (5 * 8 = 40)
                cardsToTake = maxNeeded * 8;
            } else if (leagueKey === 'elite') {
                // Elite: 5 of any rarity, so 5 * 8 = 40 for each rarity
                cardsToTake = 40;
            }
            
            // Take the top scoring cards for this rarity
            const selectedCards = cardsOfThisRarity.slice(0, cardsToTake);
            topCards.push(...selectedCards);
            
            console.log(`${config.name} - Rarity ${rarity}: selected ${selectedCards.length} cards (max needed: ${maxNeeded}, target: ${cardsToTake})`);
        });

        console.log(`Total cards for ${config.name} optimization:`, topCards.length);

        // Generate all possible combinations of 5 cards with constraints
        let bestCombination = null;
        let bestScore = 0;
        let validCombinationsFound = 0;
        let totalCombinationsChecked = 0;
        let duplicateHeroRejected = 0;

        const findBestCombination = (cards) => {
            const n = cards.length;
            
            for (let i = 0; i < n - 4; i++) {
                for (let j = i + 1; j < n - 3; j++) {
                    for (let k = j + 1; k < n - 2; k++) {
                        for (let l = k + 1; l < n - 1; l++) {
                            for (let m = l + 1; m < n; m++) {
                                totalCombinationsChecked++;
                                const combination = [cards[i], cards[j], cards[k], cards[l], cards[m]];
                                
                                // Check for unique heroes first (fastest check)
                                if (!hasUniqueHeroes(combination)) {
                                    duplicateHeroRejected++;
                                    continue;
                                }
                                
                                const totalStars = combination.reduce((sum, card) => sum + card.stars, 0);
                                
                                // Check star limit and rarity limits
                                if (totalStars <= config.maxStars && isValidRarityCombination(combination, config)) {
                                    validCombinationsFound++;
                                    const totalScore = combination.reduce((sum, card) => sum + (card.medianScore || 0), 0);
                                    
                                    if (totalScore > bestScore) {
                                        bestScore = totalScore;
                                        bestCombination = combination;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        findBestCombination(topCards);

        console.log(`${config.name} - Total combinations checked:`, totalCombinationsChecked);
        console.log(`${config.name} - Rejected for duplicate heroes:`, duplicateHeroRejected);
        console.log(`${config.name} - Valid combinations found:`, validCombinationsFound);

        if (!bestCombination) {
            // Create rarity limits description
            const rarityMap = { 1: "legendary", 2: "epic", 3: "rare", 4: "common" };
            const limitsDesc = Object.entries(config.rarityLimits)
                .map(([rarity, limit]) => `max ${limit} ${rarityMap[rarity]}`)
                .join(', ');

            document.getElementById(`${leagueKey}-deck-result`).innerHTML = `
                <p style="color: #ff6b6b;">No valid combination found for ${config.name} league.</p>
                <p style="color: #ccc; font-size: 0.9em;">Rarity limits: ${limitsDesc}</p>
                <p style="color: #ccc; font-size: 0.9em;">Max stars: ${config.maxStars}</p>
                <p style="color: #ccc; font-size: 0.9em;">Eligible cards: ${eligibleCards.length}</p>
                <p style="color: #ccc; font-size: 0.9em;">Cards selected for optimization: ${topCards.length}</p>
                <p style="color: #ccc; font-size: 0.9em;">Combinations checked: ${totalCombinationsChecked}</p>
                <p style="color: #ccc; font-size: 0.9em;">Rejected for duplicate heroes: ${duplicateHeroRejected}</p>
                <p style="color: #ccc; font-size: 0.9em;">Valid combinations found: ${validCombinationsFound}</p>
            `;
            return;
        }

        // Render the optimal deck
        renderOptimalDeck(bestCombination, bestScore, leagueKey, config);
    }

    function renderOptimalDeck(cards, totalScore, leagueKey, config) {
        const rarityMap = {
            1: "legendary",
            2: "epic", 
            3: "rare",
            4: "common"
        };

        const totalStars = cards.reduce((sum, card) => sum + card.stars, 0);
        const avgScore = Math.round(totalScore / 5);
        
        // Count cards by rarity for display
        const rarityCounts = {};
        cards.forEach(card => {
            rarityCounts[card.rarity] = (rarityCounts[card.rarity] || 0) + 1;
        });
        
        const rarityBreakdown = Object.entries(rarityCounts)
            .map(([rarity, count]) => `${count} ${rarityMap[rarity]}`)
            .join(', ');

        let html = `
            <div class="deck-stats">
                <strong>Total Combined Score:</strong> ${Math.round(totalScore)} | 
                <strong>Average Score:</strong> ${avgScore} | 
                <strong>Total Stars:</strong> ${totalStars}/${config.maxStars}<br>
                <strong>Composition:</strong> ${rarityBreakdown}
            </div>
            <div class="deck-cards-container">
        `;

        cards.forEach(card => {
            const rarityName = rarityMap[card.rarity] || card.rarity;
            const imgUrl = `https://r2.fantasy.top/v3/${rarityName}/${card.hero_id}_${card.stars}.png`;
            const medianColor = getColorForRank(card.medianScore || 0, 1000, true);

            html += `
                <div class="deck-card">
                    <img src="${imgUrl}" alt="Hero">
                    <div style="color: white; font-size: 0.8em; margin-bottom: 8px;">
                        ${card.hero_name}
                    </div>
                    <div style="display: flex; justify-content: center; align-items: center; gap: 4px;">
                        <span style="font-size: 0.7em; color: #ccc;">Score:</span>
                        <span style="background-color: ${medianColor}; color: black; padding: 2px 6px; border-radius: 4px; font-size: 0.7em; font-weight: bold;">
                            ${Math.round(card.medianScore || 0)}
                        </span>
                    </div>
                </div>
            `;
        });

        html += '</div>';
        document.getElementById(`${leagueKey}-deck-result`).innerHTML = html;
    }

    function renderCardsByStars(cards) {
        // Store cards globally for deck generation
        currentCards = cards;
        
        // Show the optimal deck sections
        document.getElementById('optimal-decks').style.display = 'block';

        const rarityMap = {
            1: "legendary",
            2: "epic",
            3: "rare",
            4: "common"
        };

        // Join cards with F2P scores data
        const enrichedCards = cards.map(card => {
            const f2pData = f2pScoresData ? f2pScoresData.find(score => score.hero_id === card.hero_id) : null;
            let medianScore = null;
            
            // Calculate median score
            if (f2pData && f2pData.prior_5_days) {
                try {
                    let scores;
                    if (Array.isArray(f2pData.prior_5_days)) {
                        scores = f2pData.prior_5_days;
                    } else if (typeof f2pData.prior_5_days === 'string') {
                        scores = JSON.parse(f2pData.prior_5_days);
                    }
                    
                    if (Array.isArray(scores) && scores.length > 0) {
                        medianScore = calculateMedianScore(scores);
                    }
                } catch (e) {
                    console.error('Error parsing prior_5_days for hero:', card.hero_id);
                }
            }
            
            return {
                ...card,
                hero_name: f2pData ? f2pData.hero_name : 'Unknown Hero',
                f2p_scores: f2pData || null,
                medianScore: medianScore
            };
        });

        // Store original enriched cards
        originalCards = enrichedCards;
        currentCards = enrichedCards;
        
        // Set up filter event listeners
        setupFilterListeners();
        
        // Apply initial filter (all rarities selected by default)
        applyFilters();
    }

    // Function to set up filter event listeners
    function setupFilterListeners() {
        const filterIds = ['filterLegendary', 'filterEpic', 'filterRare', 'filterCommon'];
        
        filterIds.forEach(id => {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.removeEventListener('change', applyFilters);
                checkbox.addEventListener('change', applyFilters);
            }
        });

        // Set up star range slider listeners
        const minStarRange = document.getElementById('minStarRange');
        const maxStarRange = document.getElementById('maxStarRange');
        
        if (minStarRange && maxStarRange) {
            minStarRange.removeEventListener('input', updateStarRange);
            maxStarRange.removeEventListener('input', updateStarRange);
            minStarRange.addEventListener('input', updateStarRange);
            maxStarRange.addEventListener('input', updateStarRange);
            
            // Initialize the track
            updateStarTrack();
        }
    }

    // Function to update star range slider
    function updateStarRange() {
        const minStarRange = document.getElementById('minStarRange');
        const maxStarRange = document.getElementById('maxStarRange');
        const minStarValue = document.getElementById('minStarValue');
        const maxStarValue = document.getElementById('maxStarValue');
        
        let minVal = parseInt(minStarRange.value);
        let maxVal = parseInt(maxStarRange.value);
        
        // Ensure min doesn't exceed max
        if (minVal > maxVal) {
            minVal = maxVal;
            minStarRange.value = minVal;
        }
        
        // Ensure max doesn't go below min
        if (maxVal < minVal) {
            maxVal = minVal;
            maxStarRange.value = maxVal;
        }
        
        // Update display values
        minStarValue.textContent = minVal;
        maxStarValue.textContent = maxVal;
        
        // Update track visual
        updateStarTrack();
        
        // Apply filters
        applyFilters();
    }

    // Function to update the visual track
    function updateStarTrack() {
        const minStarRange = document.getElementById('minStarRange');
        const maxStarRange = document.getElementById('maxStarRange');
        const track = document.getElementById('starTrack');
        
        const minVal = parseInt(minStarRange.value);
        const maxVal = parseInt(maxStarRange.value);
        const min = 1;
        const max = 8;
        
        const leftPercent = ((minVal - min) / (max - min)) * 100;
        const rightPercent = ((maxVal - min) / (max - min)) * 100;
        
        track.style.left = leftPercent + '%';
        track.style.width = (rightPercent - leftPercent) + '%';
    }

    // Function to get selected star range
    function getSelectedStarRange() {
        const minStarRange = document.getElementById('minStarRange');
        const maxStarRange = document.getElementById('maxStarRange');
        
        return {
            min: parseInt(minStarRange.value),
            max: parseInt(maxStarRange.value)
        };
    }

    // Function to apply filters and re-render
    function applyFilters() {
        if (!originalCards) return;
        
        const selectedRarities = getSelectedRarities();
        const starRange = getSelectedStarRange();
        
        // Filter cards by selected rarities and star range
        const filteredCards = originalCards.filter(card => {
            const rarityMatch = selectedRarities.includes(card.rarity);
            const starMatch = card.stars >= starRange.min && card.stars <= starRange.max;
            return rarityMatch && starMatch;
        });
        
        console.log(`Filtered ${originalCards.length} cards down to ${filteredCards.length} cards (rarities: ${selectedRarities}, stars: ${starRange.min}-${starRange.max})`);
        
        // Re-render with filtered cards
        renderFilteredCards(filteredCards);
        
        // Update currentCards for deck generation
        currentCards = filteredCards;
    }

    // New function to render filtered cards (same as renderCardsByStars but without enrichment)
    function renderFilteredCards(cards) {
        const rarityMap = {
            1: "legendary",
            2: "epic",
            3: "rare",
            4: "common"
        };

        // Group cards by stars
        const groups = {};
        cards.forEach(card => {
            const stars = card.stars;
            if (!groups[stars]) groups[stars] = [];
            groups[stars].push(card);
        });

        // Sort stars descending
        const sortedStars = Object.keys(groups).map(Number).sort((a, b) => b - a);

        let html = '';
        sortedStars.forEach(star => {
            html += `
                <div class="star-section">
                    <h3 class="star-header">${star} Star${star > 1 ? 's' : ''}</h3>
                    <div class="cards-container">`;
                
            // Sort cards in this group by expected_score descending
            groups[star].sort((a, b) => b.expected_score - a.expected_score).forEach(card => {
                const rarityName = rarityMap[card.rarity] || card.rarity;
                const imgUrl = `https://r2.fantasy.top/v3/${rarityName}/${card.hero_id}_${card.stars}.png`;
                
                // Calculate median score and format daily scores
                let medianHtml = '';
                let scoresHtml = '';
                
                if (card.f2p_scores && card.f2p_scores.prior_5_days) {
                    try {
                        let scores;
                        
                        // Check if prior_5_days is already an array (parsed) or a string (needs parsing)
                        if (Array.isArray(card.f2p_scores.prior_5_days)) {
                            scores = card.f2p_scores.prior_5_days;
                        } else if (typeof card.f2p_scores.prior_5_days === 'string') {
                            scores = JSON.parse(card.f2p_scores.prior_5_days);
                        } else {
                            scores = [];
                        }
                        
                        if (Array.isArray(scores) && scores.length > 0) {
                            // Calculate median score
                            const medianScore = calculateMedianScore(scores);
                            if (medianScore !== null) {
                                const roundedMedian = Math.round(medianScore);
                                const medianColor = getColorForRank(roundedMedian, 1000, true);
                                medianHtml = `
                                    <div class="median-score">
                                        <span class="median-label">Median:</span>
                                        <span class="median-badge" style="background-color: ${medianColor};">${roundedMedian}</span>
                                    </div>
                                `;
                            }
                            
                            // Sort by date ascending for daily scores
                            scores.sort((a, b) => new Date(a.date) - new Date(b.date));
                            
                            scoresHtml = `
                                <div class="last-5-days">Last 5 Days</div>
                                <div class="score-row">
                                    ${scores.map(score => {
                                        const roundedScore = Math.round(score.max_score);
                                        const backgroundColor = getColorForRank(roundedScore, 1000, true);
                                        const formattedDate = formatDateForTooltip(score.date);
                                        return `<span class="score-badge" style="background-color: ${backgroundColor}; color: black; border-color: #333;" title="${formattedDate}">${roundedScore}</span>`;
                                    }).join('')}
                                </div>
                            `;
                        }
                    } catch (e) {
                        console.error('Error parsing prior_5_days for hero:', card.hero_name);
                        console.error('Raw prior_5_days value:', card.f2p_scores.prior_5_days);
                        console.error('Error details:', e);
                    }
                }

                html += `
                    <div class="card">
                        <div class="card-count">x${card.count}</div>
                        <img src="${imgUrl}" alt="Hero" class="card-image">
                        <div class="card-info">
                            ${card.hero_name}
                        </div>
                        ${medianHtml}
                        ${scoresHtml}
                    </div>
                `;
            });
            html += '</div></div>';
        });
        document.getElementById('result').innerHTML = html;
    }

    async function handleToken(token) {
        if (!token.startsWith('ey')) {
            alert("Please enter a valid Bearer token (starts with 'ey').");
            return;
        }
        localStorage.setItem('privy:id_token', token); // Save to localStorage
        document.getElementById('result').textContent = "";
        document.getElementById('status').textContent = "Starting fetch...";
        try {
            const result = await fetchAllCards(token);
            if (!result.cards || result.cards.length === 0) {
                document.getElementById('status').textContent = "Token expired or no cards found.";
                localStorage.removeItem('privy:id_token');
                return;
            }
            document.getElementById('status').textContent = `Total cards: ${result.total}`;
            renderCardsByStars(result.cards);
        } catch (e) {
            document.getElementById('status').textContent = "Token expired or invalid.";
            document.getElementById('result').textContent = "";
            localStorage.removeItem('privy:id_token');
        }
    }

    document.getElementById('fetchBtn').onclick = async function() {
        const token = document.getElementById('token').value.trim();
        await handleToken(token);
    };

    // Update the event listeners for all league buttons
    document.getElementById('generateBronzeBtn').onclick = function() {
        generateOptimalDeck('bronze');
    };

    document.getElementById('generateSilverBtn').onclick = function() {
        generateOptimalDeck('silver');
    };

    document.getElementById('generateGoldBtn').onclick = function() {
        generateOptimalDeck('gold');
    };

    document.getElementById('generateEliteBtn').onclick = function() {
        generateOptimalDeck('elite');
    };

    // Try to auto-populate the token field from localStorage
    window.addEventListener('DOMContentLoaded', async () => {
        console.log("DOMContentLoaded event fired");
        
        // Fetch F2P scores data immediately when page loads
        await fetchF2PScores();
        
        try {
            const privyToken = localStorage.getItem('privy:id_token');
            console.log("privy:id_token from localStorage:", privyToken);
            if (privyToken && privyToken.startsWith('ey')) {
                document.getElementById('token').value = privyToken;
                document.getElementById('result').textContent = "";
                document.getElementById('status').textContent = "Starting fetch...";
                try {
                    console.log("Calling fetchAllCards...");
                    const result = await fetchAllCards(privyToken);
                    document.getElementById('status').textContent = `Total cards: ${result.total}`;
                    renderCardsByStars(result.cards);
                } catch (e) {
                    console.error("Error in fetchAllCards:", e);
                    document.getElementById('status').textContent = "";
                    document.getElementById('result').textContent = "Error: " + e.message;
                }
            }
        } catch (e) {
            console.error("Error in DOMContentLoaded handler:", e);
        }
    });
    </script>
</body>
</html>