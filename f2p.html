<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXJ5Q7LKKE"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LXJ5Q7LKKE');
    </script>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../styles.css?v=8e4c2f">
    <link rel="icon" type="image/png" href="../icons/favicon.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy.Top F2P Deck Optimizer</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
    div.card img.card-image {
        width: 50% !important;
        height: auto !important;
        border-radius: 0 !important;
        display: block !important;
        margin: 0 auto !important;
        object-fit: contain !important;
        max-width: 120px !important;
    }

    .star-section {
        margin: 30px 0;
        padding: 20px;
        border: 2px solid #555;
        border-radius: 12px;
        background: linear-gradient(135deg, #333333 0%, #2a2a2a 100%);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .star-header {
        margin: 0 0 20px 0;
        padding: 10px 15px;
        background: linear-gradient(135deg, #495057 0%, #343a40 100%);
        color: white;
        border-radius: 8px;
        font-size: 1.5em;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        justify-content: flex-start;
    }

    .card {
        border: 1px solid #555;
        padding: 12px;
        width: 180px;
        text-align: center;
        border-radius: 8px;
        background: #333333;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        position: relative; /* Added for positioning the count badge */
    }

    .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    }

    .card-count {
        position: absolute;
        top: -5px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        color: black;
        border: 1px solid black;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 0.65em;
        font-weight: bold;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        z-index: 10;
        white-space: nowrap;
    }

    .card-info {
        margin-top: 8px;
        font-size: 0.9em;
        line-height: 1.4;
        color: white !important;
    }

    .card-info b {
        color: white !important;
    }

    .median-score {
        margin-top: 6px;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 6px;
    }

    .median-label {
        font-size: 0.7em;
        color: #ccc;
        font-weight: bold;
    }

    .median-badge {
        background: #444;
        color: black;
        padding: 3px 8px;
        border-radius: 4px;
        border: 2px solid #333;
        font-size: 0.75em;
        font-weight: bold;
        min-width: 35px;
        text-align: center;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .last-5-days {
        margin-top: 8px;
        font-size: 0.7em;
        color: #ccc;
        font-weight: bold;
    }

    .score-row {
        display: flex;
        justify-content: center;
        gap: 3px;
        margin-top: 4px;
        flex-wrap: wrap;
    }

    .score-badge {
        background: #444;
        color: white;
        padding: 2px 4px;
        border-radius: 8px;
        border: 1px solid #666;
        font-size: 0.8em;
        font-weight: bold;
        min-width: 25px;
        text-align: center;
    }

    .optimal-deck-section {
        margin: 20px 0;
        padding: 20px;
        border: 2px solid #d4a574;
        border-radius: 12px;
        background: linear-gradient(135deg, #4a3728 0%, #3d2e20 100%);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .optimal-deck-header {
        margin: 0 0 15px 0;
        padding: 10px 15px;
        background: linear-gradient(135deg, #d4a574 0%, #b8956a 100%);
        color: black;
        border-radius: 8px;
        font-size: 1.3em;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .generate-btn {
        background: #d4a574;
        color: black;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        font-weight: bold;
        cursor: pointer;
        margin-bottom: 15px;
        font-size: 1em;
    }

    .generate-btn:hover {
        background: #c19660;
    }

    .deck-stats {
        margin: 10px 0;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        font-size: 0.9em;
        color: white;
    }

    .deck-cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        margin-top: 15px;
    }

    .deck-card {
        border: 1px solid #d4a574;
        padding: 8px;
        width: 140px;
        text-align: center;
        border-radius: 8px;
        background: rgba(212, 165, 116, 0.2);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .deck-card img {
        width: 60px !important;
        height: auto !important;
        border-radius: 0 !important;
        display: block !important;
        margin: 0 auto 8px auto !important;
        object-fit: contain !important;
    }
    </style>
</head>
<body>
    <h2>Fantasy.Top F2P Deck Optimizer</h2>
    <label for="token">Bearer Token:</label>
    <input type="text" id="token" style="width:60%;" placeholder="Paste your Bearer token here (starts with 'ey')">
    <br><br>
    <button id="fetchBtn">Fetch Cards</button>
    <div id="status"></div>
    
    <div id="optimal-deck" class="optimal-deck-section" style="display: none;">
        <!-- Bronze League -->
        <div style="margin-bottom: 30px;">
            <div class="optimal-deck-header" style="background: linear-gradient(135deg, #FE8946 0%, #d4734a 100%);">
                Optimal Bronze Deck
            </div>
            <button onclick="generateOptimalDeck('bronze')" class="generate-btn" style="background: #FE8946;">
                Generate Bronze Deck
            </button>
            <div id="bronze-deck-result"></div>
        </div>

        <!-- Silver League -->
        <div style="margin-bottom: 30px;">
            <div class="optimal-deck-header" style="background: linear-gradient(135deg, #A7B8CF 0%, #8ba3ba 100%);">
                Optimal Silver Deck
            </div>
            <button onclick="generateOptimalDeck('silver')" class="generate-btn" style="background: #A7B8CF;">
                Generate Silver Deck
            </button>
            <div id="silver-deck-result"></div>
        </div>

        <!-- Gold League -->
        <div style="margin-bottom: 30px;">
            <div class="optimal-deck-header" style="background: linear-gradient(135deg, #FFCE52 0%, #e6b84a 100%);">
                Optimal Gold Deck
            </div>
            <button onclick="generateOptimalDeck('gold')" class="generate-btn" style="background: #FFCE52;">
                Generate Gold Deck
            </button>
            <div id="gold-deck-result"></div>
        </div>

        <!-- Elite League -->
        <div style="margin-bottom: 30px;">
            <div class="optimal-deck-header" style="background: linear-gradient(135deg, #C78BFF 0%, #b078e6 100%);">
                Optimal Elite Deck
            </div>
            <button onclick="generateOptimalDeck('elite')" class="generate-btn" style="background: #C78BFF;">
                Generate Elite Deck
            </button>
            <div id="elite-deck-result"></div>
        </div>
    </div>
    
    <div id="result"></div>

    <script>
    const supabaseUrl = 'https://hhcuqhvmzwmehdsaamhn.supabase.co'
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoY3VxaHZtendtZWhkc2FhbWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzIwMTIsImV4cCI6MjA1MDU0ODAxMn0.xJNGoFLnpnmQGLj8RY_4VLmefPmFzuOyiVHLvFtPkkE'
    const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey)

    // Global variable to store the query results
    let f2pScoresData = null;
    let currentCards = null; // Store current cards for deck generation

    // Color cache and helper functions
    const colorCache = new Map();

    function lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    function getColorForRank(value, maxValue = 1000, higherIsBetter = true) {
        const cacheKey = `${value}_${maxValue}_${higherIsBetter}`;
        if (colorCache.has(cacheKey)) {
            return colorCache.get(cacheKey);
        }

        let ratio;
        if (higherIsBetter) {
            ratio = Math.min(value / maxValue, 1);
        } else {
            // For ranks - lower is better
            ratio = 1 - (Math.min(value / maxValue, 1));
        }

        if (ratio < 0.5) {
            // Red to Yellow transition
            const r = Math.round(lerp(215, 254, ratio * 2));
            const g = Math.round(lerp(48, 224, ratio * 2));
            const b = Math.round(lerp(39, 139, ratio * 2));
            const color = `rgb(${r}, ${g}, ${b})`;
            colorCache.set(cacheKey, color);
            return color;
        } else {
            // Yellow to Green transition
            const r = Math.round(lerp(254, 44, (ratio - 0.5) * 2));
            const g = Math.round(lerp(224, 162, (ratio - 0.5) * 2));
            const b = Math.round(lerp(139, 95, (ratio - 0.5) * 2));
            const color = `rgb(${r}, ${g}, ${b})`;
            colorCache.set(cacheKey, color);
            return color;
        }
    }

    // Function to fetch and store the F2P scores data
    async function fetchF2PScores() {
        try {
            console.log('Fetching F2P scores data...');
            const { data, error } = await supabaseClient
                .from('vwf2p_here_24hr_scores')
                .select('hero_id,hero_name, posts_per_day,time_24h_from_now, prior_5_days, prior_5_weeks_dow_hh');

            if (error) {
                console.error('Error fetching F2P scores:', error);
                return null;
            }

            console.log('F2P scores data fetched successfully:', data.length, 'records');
            f2pScoresData = data;
            return data;
        } catch (err) {
            console.error('Exception while fetching F2P scores:', err);
            return null;
        }
    }

    // Function to get F2P score for a specific hero
    function getF2PScore(heroHandle) {
        if (!f2pScoresData) {
            console.warn('F2P scores data not loaded yet');
            return null;
        }
        
        return f2pScoresData.find(score => score.hero_handle === heroHandle);
    }

    // Function to get all F2P scores (for when you need the full dataset)
    function getAllF2PScores() {
        return f2pScoresData;
    }

    async function fetchAllCards(token) {
        let allCards = [];
        const offset = 0;
        const limit = 500;
        let total = null;

        document.getElementById('status').textContent = `Fetching ${limit} cards at offset ${offset}...`;
        const url = `https://api-v2.fantasy.top/free-to-play/get-player-inventory?limit=${limit}&offset=${offset}&sortBy=expected_score_desc`;
        const resp = await fetch(url, {
            headers: {
                "accept": "application/json, text/plain, */*",
                "authorization": "Bearer " + token
            }
        });
        if (!resp.ok) {
            throw new Error("API error: " + resp.status);
        }
        const json = await resp.json();
        total = json.total;
        allCards = json.data;
        document.getElementById('status').textContent = `Fetched ${allCards.length} of ${total} cards.`;
        return { total, cards: allCards };
    }

    // Helper function to format date for tooltip
    function formatDateForTooltip(dateString) {
        const date = new Date(dateString);
        const options = { 
            weekday: 'short', 
            month: 'short', 
            day: 'numeric' 
        };
        return date.toLocaleDateString('en-US', options);
    }

    // Helper function to calculate median of 4 highest scores
    function calculateMedianScore(scores) {
        if (!scores || scores.length === 0) return null;
        
        // Get all max_score values and sort them descending
        const maxScores = scores.map(s => s.max_score).sort((a, b) => b - a);
        
        // Take the 4 highest scores (or all if less than 4)
        const top4 = maxScores.slice(0, Math.min(4, maxScores.length));
        
        if (top4.length === 0) return null;
        
        // Calculate median
        top4.sort((a, b) => a - b); // Sort ascending for median calculation
        const mid = Math.floor(top4.length / 2);
        
        if (top4.length % 2 === 0) {
            return (top4[mid - 1] + top4[mid]) / 2;
        } else {
            return top4[mid];
        }
    }

    // League configurations based on config.json
    const leagueConfigs = {
        bronze: {
            name: "Bronze",
            color: "#FE8946",
            maxStars: 18,
            allowedRarities: [4], // common only
            description: "5 common cards, max 18 stars"
        },
        silver: {
            name: "Silver", 
            color: "#A7B8CF",
            maxStars: 23,
            allowedRarities: [3, 4], // rare and common
            description: "5 rare/common cards, max 25 stars"
        },
        gold: {
            name: "Gold",
            color: "#FFCE52", 
            maxStars: 25,
            allowedRarities: [2, 3, 4], // epic, rare, and common
            description: "5 epic/rare/common cards, max 35 stars"
        },
        elite: {
            name: "Elite",
            color: "#C78BFF",
            maxStars: 50,
            allowedRarities: [1, 2, 3, 4], // all rarities
            description: "5 cards of any rarity, max 50 stars"
        }
    };

    // Generic function to generate optimal deck for any league
    function generateOptimalDeck(leagueKey) {
        if (!currentCards) {
            document.getElementById(`${leagueKey}-deck-result`).innerHTML = '<p style="color: #ff6b6b;">No cards loaded. Please fetch cards first.</p>';
            return;
        }

        const config = leagueConfigs[leagueKey];
        if (!config) {
            console.error('Invalid league key:', leagueKey);
            return;
        }

        console.log(`Generating optimal ${config.name} deck...`);

        // Filter for league eligible cards
        const eligibleCards = currentCards.filter(card => {
            const hasMedianScore = card.medianScore !== null && card.medianScore !== undefined;
            const isAllowedRarity = config.allowedRarities.includes(card.rarity);
            return isAllowedRarity && hasMedianScore && card.count > 0;
        });

        console.log(`${config.name} eligible cards found:`, eligibleCards.length);

        if (eligibleCards.length === 0) {
            const rarityNames = config.allowedRarities.map(r => {
                const rarityMap = { 1: "legendary", 2: "epic", 3: "rare", 4: "common" };
                return rarityMap[r];
            }).join(', ');

            document.getElementById(`${leagueKey}-deck-result`).innerHTML = `
                <p style="color: #ff6b6b;">No eligible cards found for ${config.name} league.</p>
                <p style="color: #ccc; font-size: 0.9em;">Required rarities: ${rarityNames}</p>
                <p style="color: #ccc; font-size: 0.9em;">Cards with median scores: ${currentCards.filter(c => c.medianScore !== null).length}</p>
            `;
            return;
        }

        // Group cards by star level and get top 5 for each
        const cardsByStars = {};
        eligibleCards.forEach(card => {
            if (!cardsByStars[card.stars]) {
                cardsByStars[card.stars] = [];
            }
            cardsByStars[card.stars].push(card);
        });

        // Get top 5 cards for each star level
        const topCards = [];
        Object.keys(cardsByStars).forEach(stars => {
            const sortedCards = cardsByStars[stars].sort((a, b) => (b.medianScore || 0) - (a.medianScore || 0));
            const topStarCards = sortedCards.slice(0, 5);
            topCards.push(...topStarCards);
            console.log(`${stars} stars: ${cardsByStars[stars].length} cards, taking top ${topStarCards.length}`);
        });

        console.log(`Total cards for ${config.name} optimization:`, topCards.length);

        // Generate all possible combinations of 5 cards with total stars <= maxStars
        let bestCombination = null;
        let bestScore = 0;
        let validCombinationsFound = 0;

        const findBestCombination = (cards) => {
            const n = cards.length;
            
            for (let i = 0; i < n - 4; i++) {
                for (let j = i + 1; j < n - 3; j++) {
                    for (let k = j + 1; k < n - 2; k++) {
                        for (let l = k + 1; l < n - 1; l++) {
                            for (let m = l + 1; m < n; m++) {
                                const combination = [cards[i], cards[j], cards[k], cards[l], cards[m]];
                                const totalStars = combination.reduce((sum, card) => sum + card.stars, 0);
                                
                                if (totalStars <= config.maxStars) {
                                    validCombinationsFound++;
                                    const totalScore = combination.reduce((sum, card) => sum + (card.medianScore || 0), 0);
                                    
                                    if (totalScore > bestScore) {
                                        bestScore = totalScore;
                                        bestCombination = combination;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };

        findBestCombination(topCards);

        console.log(`${config.name} - Valid combinations found:`, validCombinationsFound);

        if (!bestCombination) {
            document.getElementById(`${leagueKey}-deck-result`).innerHTML = `
                <p style="color: #ff6b6b;">No valid combination found for ${config.name} league.</p>
                <p style="color: #ccc; font-size: 0.9em;">${config.description}</p>
                <p style="color: #ccc; font-size: 0.9em;">Eligible cards: ${eligibleCards.length}</p>
                <p style="color: #ccc; font-size: 0.9em;">Valid combinations found: ${validCombinationsFound}</p>
            `;
            return;
        }

        // Render the optimal deck
        renderOptimalDeck(bestCombination, bestScore, leagueKey, config);
    }

    function renderOptimalDeck(cards, totalScore, leagueKey, config) {
        const rarityMap = {
            1: "legendary",
            2: "epic", 
            3: "rare",
            4: "common"
        };

        const totalStars = cards.reduce((sum, card) => sum + card.stars, 0);
        const avgScore = Math.round(totalScore / 5);

        let html = `
            <div class="deck-stats">
                <strong>Total Combined Score:</strong> ${Math.round(totalScore)} | 
                <strong>Average Score:</strong> ${avgScore} | 
                <strong>Total Stars:</strong> ${totalStars}/${config.maxStars}
            </div>
            <div class="deck-cards-container">
        `;

        cards.forEach(card => {
            const rarityName = rarityMap[card.rarity] || card.rarity;
            const imgUrl = `https://r2.fantasy.top/v3/${rarityName}/${card.hero_id}_${card.stars}.png`;
            const medianColor = getColorForRank(card.medianScore || 0, 1000, true);

            html += `
                <div class="deck-card">
                    <img src="${imgUrl}" alt="Hero">
                    <div style="color: white; font-size: 0.8em; margin-bottom: 4px;">
                        ${card.hero_name}
                    </div>
                    <div style="color: white; font-size: 0.7em; margin-bottom: 4px;">
                        ${card.stars} Star${card.stars > 1 ? 's' : ''} â€¢ ${rarityName}
                    </div>
                    <div style="display: flex; justify-content: center; align-items: center; gap: 4px;">
                        <span style="font-size: 0.7em; color: #ccc;">Score:</span>
                        <span style="background-color: ${medianColor}; color: black; padding: 2px 6px; border-radius: 4px; font-size: 0.7em; font-weight: bold;">
                            ${Math.round(card.medianScore || 0)}
                        </span>
                    </div>
                </div>
            `;
        });

        html += '</div>';
        document.getElementById(`${leagueKey}-deck-result`).innerHTML = html;
    }

    // Remove the old generateOptimalBronzeDeck function and replace with this
    function generateOptimalBronzeDeck() {
        generateOptimalDeck('bronze');
    }

    // Function to generate optimal Silver deck
    function generateOptimalSilverDeck() {
        generateOptimalDeck('silver');
    }

    // Function to generate optimal Gold deck
    function generateOptimalGoldDeck() {
        generateOptimalDeck('gold');
    }

    // Function to generate optimal Elite deck
    function generateOptimalEliteDeck() {
        generateOptimalDeck('elite');
    }

    function renderCardsByStars(cards) {
        // Store cards globally for deck generation
        currentCards = cards;
        
        // Show the optimal deck section
        document.getElementById('optimal-deck').style.display = 'block';

        const rarityMap = {
            1: "legendary",
            2: "epic",
            3: "rare",
            4: "common"
        };

        // Join cards with F2P scores data
        const enrichedCards = cards.map(card => {
            const f2pData = f2pScoresData ? f2pScoresData.find(score => score.hero_id === card.hero_id) : null;
            let medianScore = null;
            
            // Calculate median score
            if (f2pData && f2pData.prior_5_days) {
                try {
                    let scores;
                    if (Array.isArray(f2pData.prior_5_days)) {
                        scores = f2pData.prior_5_days;
                    } else if (typeof f2pData.prior_5_days === 'string') {
                        scores = JSON.parse(f2pData.prior_5_days);
                    }
                    
                    if (Array.isArray(scores) && scores.length > 0) {
                        medianScore = calculateMedianScore(scores);
                    }
                } catch (e) {
                    console.error('Error parsing prior_5_days for hero:', card.hero_id);
                }
            }
            
            return {
                ...card,
                hero_name: f2pData ? f2pData.hero_name : 'Unknown Hero',
                f2p_scores: f2pData || null,
                medianScore: medianScore
            };
        });

        // Update global cards reference
        currentCards = enrichedCards;

        // Group enriched cards by stars
        const groups = {};
        enrichedCards.forEach(card => {
            const stars = card.stars;
            if (!groups[stars]) groups[stars] = [];
            groups[stars].push(card);
        });

        // Sort stars descending
        const sortedStars = Object.keys(groups).map(Number).sort((a, b) => b - a);

        let html = '';
        sortedStars.forEach(star => {
            html += `
                <div class="star-section">
                    <h3 class="star-header">${star} Star${star > 1 ? 's' : ''}</h3>
                    <div class="cards-container">`;
                
            // Sort cards in this group by expected_score descending
            groups[star].sort((a, b) => b.expected_score - a.expected_score).forEach(card => {
                const rarityName = rarityMap[card.rarity] || card.rarity;
                const imgUrl = `https://r2.fantasy.top/v3/${rarityName}/${card.hero_id}_${card.stars}.png`;
                
                // Calculate median score and format daily scores
                let medianHtml = '';
                let scoresHtml = '';
                
                if (card.f2p_scores && card.f2p_scores.prior_5_days) {
                    try {
                        let scores;
                        
                        // Check if prior_5_days is already an array (parsed) or a string (needs parsing)
                        if (Array.isArray(card.f2p_scores.prior_5_days)) {
                            scores = card.f2p_scores.prior_5_days;
                        } else if (typeof card.f2p_scores.prior_5_days === 'string') {
                            scores = JSON.parse(card.f2p_scores.prior_5_days);
                        } else {
                            console.log('Unexpected prior_5_days type:', typeof card.f2p_scores.prior_5_days, card.f2p_scores.prior_5_days);
                            scores = [];
                        }
                        
                        if (Array.isArray(scores) && scores.length > 0) {
                            // Calculate median score
                            const medianScore = calculateMedianScore(scores);
                            if (medianScore !== null) {
                                const roundedMedian = Math.round(medianScore);
                                const medianColor = getColorForRank(roundedMedian, 1000, true);
                                medianHtml = `
                                    <div class="median-score">
                                        <span class="median-label">Median:</span>
                                        <span class="median-badge" style="background-color: ${medianColor};">${roundedMedian}</span>
                                    </div>
                                `;
                            }
                            
                            // Sort by date ascending for daily scores
                            scores.sort((a, b) => new Date(a.date) - new Date(b.date));
                            
                            scoresHtml = `
                                <div class="last-5-days">Last 5 Days</div>
                                <div class="score-row">
                                    ${scores.map(score => {
                                        const roundedScore = Math.round(score.max_score);
                                        const backgroundColor = getColorForRank(roundedScore, 1000, true);
                                        const formattedDate = formatDateForTooltip(score.date);
                                        return `<span class="score-badge" style="background-color: ${backgroundColor}; color: black; border-color: #333;" title="${formattedDate}">${roundedScore}</span>`;
                                    }).join('')}
                                </div>
                            `;
                        }
                    } catch (e) {
                        console.error('Error parsing prior_5_days for hero:', card.hero_name);
                        console.error('Raw prior_5_days value:', card.f2p_scores.prior_5_days);
                        console.error('Error details:', e);
                    }
                }

                html += `
                    <div class="card">
                        <div class="card-count">x${card.count}</div>
                        <img src="${imgUrl}" alt="Hero" class="card-image">
                        <div class="card-info">
                            ${card.hero_name}
                        </div>
                        ${medianHtml}
                        ${scoresHtml}
                    </div>
                `;
            });
            html += '</div></div>';
        });
        document.getElementById('result').innerHTML = html;
    }

    async function handleToken(token) {
        if (!token.startsWith('ey')) {
            alert("Please enter a valid Bearer token (starts with 'ey').");
            return;
        }
        localStorage.setItem('privy:id_token', token); // Save to localStorage
        document.getElementById('result').textContent = "";
        document.getElementById('status').textContent = "Starting fetch...";
        try {
            const result = await fetchAllCards(token);
            if (!result.cards || result.cards.length === 0) {
                document.getElementById('status').textContent = "Token expired or no cards found.";
                localStorage.removeItem('privy:id_token');
                return;
            }
            document.getElementById('status').textContent = `Total cards: ${result.total}`;
            renderCardsByStars(result.cards);
        } catch (e) {
            document.getElementById('status').textContent = "Token expired or invalid.";
            document.getElementById('result').textContent = "";
            localStorage.removeItem('privy:id_token');
        }
    }

    document.getElementById('fetchBtn').onclick = async function() {
        const token = document.getElementById('token').value.trim();
        await handleToken(token);
    };

    // Add event listener for deck generation
    document.getElementById('generateBtn').onclick = function() {
        generateOptimalBronzeDeck();
    };

    // Try to auto-populate the token field from localStorage
    window.addEventListener('DOMContentLoaded', async () => {
        console.log("DOMContentLoaded event fired");
        
        // Fetch F2P scores data immediately when page loads
        await fetchF2PScores();
        
        try {
            const privyToken = localStorage.getItem('privy:id_token');
            console.log("privy:id_token from localStorage:", privyToken);
            if (privyToken && privyToken.startsWith('ey')) {
                document.getElementById('token').value = privyToken;
                document.getElementById('result').textContent = "";
                document.getElementById('status').textContent = "Starting fetch...";
                try {
                    console.log("Calling fetchAllCards...");
                    const result = await fetchAllCards(privyToken);
                    document.getElementById('status').textContent = `Total cards: ${result.total}`;
                    renderCardsByStars(result.cards);
                } catch (e) {
                    console.error("Error in fetchAllCards:", e);
                    document.getElementById('status').textContent = "";
                    document.getElementById('result').textContent = "Error: " + e.message;
                }
            }
        } catch (e) {
            console.error("Error in DOMContentLoaded handler:", e);
        }
    });
    </script>
</body>
</html>