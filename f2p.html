<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXJ5Q7LKKE"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LXJ5Q7LKKE');
    </script>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../styles.css?v=8e4c2f">
    <link rel="icon" type="image/png" href="../icons/favicon.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy.Top F2P Deck Optimizer</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
    /* Add these new styles after the existing styles */
    .header-container {
        background: linear-gradient(135deg, #333333 0%, #2a2a2a 100%);
        border: 2px solid #555;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .header-title {
        margin: 0 0 15px 0;
        text-align: center;
        color: white;
        font-size: 1.8em;
        font-weight: bold;
    }

    .input-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
    }

    .input-row label {
        color: white;
        font-weight: bold;
        white-space: nowrap;
        min-width: 100px;
    }

    .input-row input {
        flex: 1;
        min-width: 200px;
        max-width: 400px;
        padding: 8px 12px;
        border: 1px solid #555;
        border-radius: 6px;
        background: #444;
        color: white;
        font-size: 0.9em;
    }

    .input-row input::placeholder {
        color: #aaa;
    }

    .input-row button {
        background: #007bff;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        font-weight: bold;
        cursor: pointer;
        white-space: nowrap;
    }

    .input-row button:hover {
        background: #0056b3;
    }

    .status-div {
        color: #ccc;
        font-size: 0.9em;
        text-align: center;
        min-height: 20px;
        margin-top: 5px;
    }

    div.card img.card-image {
        width: 42.5% !important; /* Reduced from 50% by 15% */
        height: auto !important;
        border-radius: 0 !important;
        display: block !important;
        margin: 0 auto !important;
        object-fit: contain !important;
        max-width: 102px !important; /* Reduced from 120px by 15% */
    }

    .star-section {
        margin: 30px 0;
        padding: 20px;
        border: 2px solid #555;
        border-radius: 12px;
        background: linear-gradient(135deg, #333333 0%, #2a2a2a 100%);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .star-header {
        margin: 0 0 20px 0;
        padding: 10px 15px;
        background: linear-gradient(135deg, #495057 0%, #343a40 100%);
        color: white;
        border-radius: 8px;
        font-size: 1.5em;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        justify-content: flex-start;
    }

    .card {
        border: 1px solid #555;
        padding: 12px;
        width: 180px;
        text-align: center;
        border-radius: 8px;
        background: #333333;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        position: relative; /* Added for positioning the count badge */
    }

    .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    }

    .card-count {
        position: absolute;
        top: -5px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        color: black;
        border: 1px solid black;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 0.65em;
        font-weight: bold;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        z-index: 10;
        white-space: nowrap;
    }

    .card-info {
        margin-top: 8px;
        font-size: 0.9em;
        line-height: 1.4;
        color: white !important;
    }

    .card-info b {
        color: white !important;
    }

    .median-score {
        margin-top: 6px;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 6px;
    }

    .median-label {
        font-size: 0.7em;
        color: #ccc;
        font-weight: bold;
    }

    .median-badge {
        background: #444;
        color: black;
        padding: 3px 8px;
        border-radius: 4px;
        border: 2px solid #333;
        font-size: 0.75em;
        font-weight: bold;
        min-width: 35px;
        text-align: center;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        cursor: help; /* Add help cursor for tooltip */
        position: relative;
    }

    .last-5-days {
        margin-top: 8px;
        font-size: 0.7em;
        color: #ccc;
        font-weight: bold;
    }

    .score-row {
        display: flex;
        justify-content: center;
        gap: 2px; /* Reduced from 3px */
        margin-top: 4px;
        flex-wrap: nowrap; /* Prevent wrapping */
    }

    .score-badge {
        background: #444;
        color: white;
        padding: 2px 3px; /* Reduced padding from 2px 4px */
        border-radius: 6px; /* Reduced from 8px */
        border: 1px solid #666;
        font-size: 0.75em; /* Reduced from 0.8em */
        font-weight: bold;
        min-width: 22px; /* Reduced from 25px */
        text-align: center;
        cursor: default; /* Change from pointer to default */
    }

    /* Update the optimal-deck-section styling to use league colors */
    .optimal-deck-section {
        margin: 20px 0;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    /* Remove the optimal-deck-header styles since we're removing it */

    /* Update generate-btn to be more prominent */
    .generate-btn {
        color: black;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-weight: bold;
        cursor: pointer;
        margin-bottom: 15px;
        font-size: 1.1em;
        width: 100%;
    }

    .generate-btn:hover {
        opacity: 0.9;
    }

    .deck-stats {
        margin: 10px 0;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        font-size: 0.9em;
        color: white;
    }

    .deck-cards-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        margin-top: 15px;
    }

    .deck-card {
        border: 1px solid #d4a574;
        padding: 8px;
        width: 140px;
        text-align: center;
        border-radius: 8px;
        background: rgba(212, 165, 116, 0.2);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .deck-card img {
        width: 60px !important;
        height: auto !important;
        border-radius: 0 !important;
        display: block !important;
        margin: 0 auto 8px auto !important;
        object-fit: contain !important;
    }

    /* New styles for league sections */
    #optimal-decks {
        display: none;
        margin-top: 0;
    }

    .league-section {
        margin: 20px 0;
        padding: 15px;
        border: 2px solid #777;
        border-radius: 10px;
        background: linear-gradient(135deg, #222 0%, #111 100%);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    }

    .league-header {
        margin: 0 0 15px 0;
        padding: 10px 15px;
        background: linear-gradient(135deg, #777 0%, #555 100%);
        color: white;
        border-radius: 8px;
        font-size: 1.4em;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .league-description {
        font-size: 0.9em;
        color: #ccc;
        margin-bottom: 10px;
        text-align: center;
    }

    .generate-league-btn {
        display: block;
        width: 100%;
        background: #777;
        color: white;
        border: none;
        padding: 10px 0;
        border-radius: 6px;
        font-weight: bold;
        cursor: pointer;
        margin-bottom: 15px;
        font-size: 1em;
        text-align: center;
    }

    .generate-league-btn:hover {
        background: #666;
    }

    /* Replace the optimal-deck-header styles since we're removing it */
    .optimal-deck-header {
        display: none;
    }

    /* Add this CSS after the existing styles */

    .main-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
        margin-top: 20px;
    }

    .content-columns {
        display: flex;
        gap: 20px;
    }

    .left-side {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .right-column {
        flex: 1;
        min-width: 0;
    }

    /* Make the layout responsive for smaller screens */
    @media (max-width: 1200px) {
        .content-columns {
            flex-direction: column;
        }
    }

    /* Add these styles to the existing <style> section */

    .filter-container {
        background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        border: 2px solid #444;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .filter-title {
        color: white;
        font-size: 1.1em;
        font-weight: bold;
        margin: 0 0 10px 0;
    }

    .checkbox-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px; /* Slightly reduced gap */
    }

    .checkbox-label {
        display: flex;
        align-items: center;
        font-size: 11px; /* Reduced from 14px */
        cursor: pointer;
        padding: 5px 8px; /* Slightly smaller padding */
        border-radius: 4px;
        user-select: none;
        color: #fff;
        background: #1a1a1a;
        border: 1px solid #333;
        transition: all 0.2s;
    }

    .checkbox-label:hover {
        background: #3a3a3a;
    }

    .checkbox-label input {
        margin-right: 6px;
        accent-color: transparent;
        transform: scale(0.8); /* Reduce checkbox size by 20% */
    }

    /* Rarity-specific colors for checked state */
    .checkbox-label.legendary input:checked {
        accent-color: #CACBD4;
    }

    .checkbox-label.epic input:checked {
        accent-color: #E890FE;
    }

    .checkbox-label.rare input:checked {
        accent-color: #00FFE2;
    }

    .checkbox-label.common input:checked {
        accent-color: #94FF00;
    }

    /* Rarity-specific colors for label border */
    .checkbox-label.legendary {
        border-left: 3px solid #CACBD4;
    }

    .checkbox-label.epic {
        border-left: 3px solid #E890FE;
    }

    .checkbox-label.rare {
        border-left: 3px solid #00FFE2;
    }

    .checkbox-label.common {
        border-left: 3px solid #94FF00;
    }

    .star-slider-container {
        display: flex;
        align-items: center;
        position: relative;
        min-width: 320px;
        height: 40px;
        justify-content: space-between;
    }

    .star-label-group {
        display: flex;
        align-items: center;
        gap: 4px;
        position: relative;
        z-index: 4;
    }

    .star-label-group.left {
        margin-right: 8px;
    }

    .star-label-group.right {
        margin-left: 8px;
    }

    .gold-star {
        color: #FACC15;
        font-size: 1em;
        margin-bottom: 2px;
    }

    .star-label {
        font-weight: bold;
        color: #FACC15;
        font-size: 1em;
        min-width: 24px;
        text-align: center;
        position: relative;
    }

    .star-slider-track {
        position: absolute;
        left: 60px;
        right: 60px;
        top: 50%;
        transform: translateY(-50%);
        height: 8px;
        background: #FACC15;
        border-radius: 4px;
        z-index: 1;
        width: auto;
    }

    .star-slider-container input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        position: absolute;
        left: 60px;
        width: calc(100% - 120px);
        height: 40px;
        background: transparent;
        top: 0;
        margin: 0;
        pointer-events: auto;
    }

    #minStarSlider {
        z-index: 2;
    }
    #maxStarSlider {
        z-index: 3;
    }

    .star-slider-container input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #FACC15;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        margin-top: -5px;
        border: none;
    }

    .star-slider-container input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #FACC15;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        border: none;
    }

    .star-slider-container input[type="range"]:focus {
        outline: none;
    }

    .star-slider-container input[type="range"]::-webkit-slider-runnable-track {
        height: 8px;
        background: transparent;
    }

    .star-slider-container input[type="range"]::-ms-fill-lower,
    .star-slider-container input[type="range"]::-ms-fill-upper {
        background: transparent;
    }
    </style>
</head>
<body>
    <!-- Replace the header section with this compact container -->
    <div class="header-container">
        <h2 class="header-title">Fantasy.Top F2P Deck Optimizer</h2>
        <div class="input-row">
            <label for="token">Bearer Token:</label>
            <input type="text" id="token" placeholder="Paste your Bearer token here (starts with 'ey')">
            <button id="fetchBtn">Fetch Cards</button>
        </div>
        <div id="status" class="status-div"></div>
    </div>
    
    <!-- Replace the main-content section with this updated structure: -->
    <div class="main-content">
        <div class="content-columns">
            <div class="left-side">
                <div class="filter-container">
                    <div class="filter-title">Filter Cards</div>
                    <div style="display: flex; align-items: center; gap: 18px;">
                        <div class="checkbox-group">
                            <label class="checkbox-label legendary">
                                <input type="checkbox" id="filterLegendary" checked> Legendary
                            </label>
                            <label class="checkbox-label epic">
                                <input type="checkbox" id="filterEpic" checked> Epic
                            </label>
                            <label class="checkbox-label rare">
                                <input type="checkbox" id="filterRare" checked> Rare
                            </label>
                            <label class="checkbox-label common">
                                <input type="checkbox" id="filterCommon" checked> Common
                            </label>
                        </div>
                        <!-- Double range slider for stars -->
                        <div class="star-slider-container">
                            <div class="star-label-group left">
                                <span id="minStarLabel" class="star-label">1</span>
                                <i class="fa-solid fa-star gold-star"></i>
                            </div>
                            <div class="star-slider-track"></div>
                            <input type="range" id="minStarSlider" min="1" max="8" value="1" step="1">
                            <input type="range" id="maxStarSlider" min="1" max="8" value="8" step="1">
                            <div class="star-label-group right">
                                <span id="maxStarLabel" class="star-label">8</span>
                                <i class="fa-solid fa-star gold-star"></i>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="result"></div>
            </div>
            
            <div class="right-column">
                <div id="optimal-decks" style="display: none;">
                    <div class="optimal-deck-section" style="border: 2px solid #FE8946; background: linear-gradient(135deg, rgba(254, 137, 70, 0.2) 0%, rgba(212, 115, 42, 0.2) 100%);">
                        <button id="generateBronzeBtn" class="generate-btn" style="background: #FE8946;">Generate Bronze Deck</button>
                        <div id="bronze-deck-result"></div>
                    </div>

                    <div class="optimal-deck-section" style="border: 2px solid #A7B8CF; background: linear-gradient(135deg, rgba(167, 184, 207, 0.2) 0%, rgba(138, 157, 184, 0.2) 100%);">
                        <button id="generateSilverBtn" class="generate-btn" style="background: #A7B8CF;">Generate Silver Deck</button>
                        <div id="silver-deck-result"></div>
                    </div>

                    <div class="optimal-deck-section" style="border: 2px solid #FFCE52; background: linear-gradient(135deg, rgba(255, 206, 82, 0.2) 0%, rgba(230, 184, 74, 0.2) 100%);">
                        <button id="generateGoldBtn" class="generate-btn" style="background: #FFCE52;">Generate Gold Deck</button>
                        <div id="gold-deck-result"></div>
                    </div>

                    <div class="optimal-deck-section" style="border: 2px solid #C78BFF; background: linear-gradient(135deg, rgba(199, 139, 255, 0.2) 0%, rgba(176, 118, 230, 0.2) 100%);">
                        <button id="generateEliteBtn" class="generate-btn" style="background: #C78BFF;">Generate Elite Deck</button>
                        <div id="elite-deck-result"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    const supabaseUrl = 'https://hhcuqhvmzwmehdsaamhn.supabase.co'
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoY3VxaHZtendtZWhkc2FhbWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzIwMTIsImV4cCI6MjA1MDU0ODAxMn0.xJNGoFLnpnmQGLj8RY_4VLmefPmFzuOyiVHLvFtPkkE'
    const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey)

    // Global variable to store the query results
    let f2pScoresData = null;
    let currentCards = null; // Store current cards for deck generation
    let originalCards = null; // This was missing!

    // Color cache and helper functions
    const colorCache = new Map();

    function lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    function getColorForRank(value, maxValue = 1000, higherIsBetter = true) {
        const cacheKey = `${value}_${maxValue}_${higherIsBetter}`;
        if (colorCache.has(cacheKey)) {
            return colorCache.get(cacheKey);
        }

        let ratio;
        if (higherIsBetter) {
            ratio = Math.min(value / maxValue, 1);
        } else {
            // For ranks - lower is better
            ratio = 1 - (Math.min(value / maxValue, 1));
        }

        if (ratio < 0.5) {
            // Red to Yellow transition
            const r = Math.round(lerp(215, 254, ratio * 2));
            const g = Math.round(lerp(48, 224, ratio * 2));
            const b = Math.round(lerp(39, 139, ratio * 2));
            const color = `rgb(${r}, ${g}, ${b})`;
            colorCache.set(cacheKey, color);
            return color;
        } else {
            // Yellow to Green transition
            const r = Math.round(lerp(254, 44, (ratio - 0.5) * 2));
            const g = Math.round(lerp(224, 162, (ratio - 0.5) * 2));
            const b = Math.round(lerp(139, 95, (ratio - 0.5) * 2));
            const color = `rgb(${r}, ${g}, ${b})`;
            colorCache.set(cacheKey, color);
            return color;
        }
    }

    // Function to fetch and store the F2P scores data
    async function fetchF2PScores() {
        try {
            console.log('Fetching F2P scores data...');
            const { data, error } = await supabaseClient
                .from('vwf2p_here_24hr_scores')
                .select('hero_id,hero_name, posts_per_day,time_24h_from_now, prior_5_days, prior_5_weeks_dow_hh');

            if (error) {
                console.error('Error fetching F2P scores:', error);
                return null;
            }

            // Preview data for Cirrus
            const cirrus = data.find(row => row.hero_name === 'Cirrus');
            if (cirrus) {
                console.log('Cirrus F2P data:', cirrus);
            } else {
                console.log('No F2P data found for Cirrus');
            }

            console.log('F2P scores data fetched successfully:', data.length, 'records');
            f2pScoresData = data;
            return data;
        } catch (err) {
            console.error('Exception while fetching F2P scores:', err);
            return null;
        }
    }

    // Function to get F2P score for a specific hero
    function getF2PScore(heroId) {  // Changed from heroHandle to heroId
        if (!f2pScoresData) {
            console.warn('F2P scores data not loaded yet');
            return null;
        }
        
        return f2pScoresData.find(score => score.hero_id === heroId);  // Changed to match by hero_id
    }

    // Function to get all F2P scores (for when you need the full dataset)
    function getAllF2PScores() {
        return f2pScoresData;
    }

    async function fetchAllCards(token) {
        let allCards = [];
        const offset = 0;
        const limit = 400;
        let total = null;

        document.getElementById('status').textContent = `Fetching ${limit} cards at offset ${offset}...`;
        const url = `https://api-v2.fantasy.top/free-to-play/get-player-inventory?name=&handle=&limit=${limit}&offset=${offset}&sortBy=score_desc`;

        const resp = await fetch(url, {
            headers: {
                "accept": "application/json, text/plain, */*",
                "accept-language": "en-US,en;q=0.9",
                "authorization": "Bearer " + token,
                // The following headers are important for mimicking a browser request:
                "origin": "https://fantasy.top",
                "referer": "https://fantasy.top/",
                "sec-ch-ua": '"Not;A=Brand";v="99", "Google Chrome";v="139", "Chromium";v="139"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": '"Windows"',
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-site",
                "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36"
                // Do NOT set Cookie or if-none-match headers in browser JS for security reasons
            }
        });
        if (!resp.ok) {
            throw new Error("API error: " + resp.status);
        }
        const json = await resp.json();
        total = json.total;
        allCards = json.data;
        document.getElementById('status').textContent = `Fetched ${allCards.length} of ${total} cards.`;
        return { total, cards: allCards };
    }

    // Fix the formatDateForTooltip function to show correct day of week
    function formatDateForTooltip(dateString) {
        // Expecting dateString in "YYYY-MM-DD"
        if (!dateString) return '';
        const [year, month, day] = dateString.split('-').map(Number);
        // month is 0-based in JS Date
        const date = new Date(year, month - 1, day);
        // Always show as "Aug 12, 2025"
        const options = { month: 'short', day: 'numeric', year: 'numeric' };
        return date.toLocaleDateString('en-US', options);
    }

    // Add this helper function after formatDateForTooltip
    function formatTimeToLocal(timeString) {
        if (!timeString) return 'N/A';
        
        try {
            // Parse the time string and convert to local time
            const date = new Date(timeString);
            
            // Get day of week (short format)
            const dayOptions = { weekday: 'short' };
            const dayName = date.toLocaleDateString('en-US', dayOptions);
            
            // Get time in 12-hour format
            const timeOptions = { 
                hour: 'numeric', 
                hour12: true 
            };
            const timeFormatted = date.toLocaleTimeString('en-US', timeOptions).toLowerCase();
            
            return `${dayName} ${timeFormatted}`;
        } catch (e) {
            console.error('Error formatting time:', timeString, e);
            return 'N/A';
        }
    }

    // Helper function to calculate median of top 7 scores from combined daily and weekly data
    function calculateMedianScore(dailyScores, weeklyScores, heroName = "") {
        const allScores = [];
        
        // Add daily scores
        if (dailyScores && Array.isArray(dailyScores)) {
            dailyScores.forEach(score => {
                if (score && typeof score.max_score === 'number') {
                    allScores.push(score.max_score);
                }
            });
        }
        
        // Add weekly scores
        if (weeklyScores && Array.isArray(weeklyScores)) {
            weeklyScores.forEach(score => {
                if (score && typeof score.max_score === 'number') {
                    allScores.push(score.max_score);
                }
            });
        }
        
        if (allScores.length === 0) return null;

        // Sort all scores descending and take top 7 (drop 3 lowest)
        allScores.sort((a, b) => b - a);
        const top7 = allScores.slice(0, Math.min(7, allScores.length));

        // Debug logging for Hugo Fartingale
        if (heroName === "Hugo Fartingale") {
            console.log(`[Hugo Fartingale] All 10 scores (descending):`, allScores);
            console.log(`[Hugo Fartingale] Top 7 scores used for median:`, top7);
        }

        if (top7.length === 0) return null;
        
        // Calculate median of top 7
        top7.sort((a, b) => a - b); // Sort ascending for median calculation
        const mid = Math.floor(top7.length / 2);
        
        if (top7.length % 2 === 0) {
            return (top7[mid - 1] + top7[mid]) / 2;
        } else {
            return top7[mid];
        }
    }

    // League configurations with rarity quantity limits (FIXED RARITY NUMBERS)
    const leagueConfigs = {
        bronze: {
            name: "Bronze",
            color: "#FE8946",
            maxStars: 18,
            rarityLimits: {
                4: 5 // max 5 commons (rarity 4)
            },
            description: "5 common cards, max 18 stars"
        },
        silver: {
            name: "Silver", 
            color: "#A7B8CF",
            maxStars: 23,
            rarityLimits: {
                3: 3, // max 3 rares (rarity 3)
                4: 5  // max 5 commons (rarity 4)
            },
            description: "Max 3 rares + commons, max 23 stars"
        },
        gold: {
            name: "Gold",
            color: "#FFCE52", 
            maxStars: 25,
            rarityLimits: {
                2: 2, // max 2 epics (rarity 2)
                3: 4, // max 4 rares (rarity 3)
                4: 5  // max 5 commons (rarity 4)
            },
            description: "Max 2 epics + max 4 rares + commons, max 25 stars"
        },
        elite: {
            name: "Elite",
            color: "#C78BFF",
            maxStars: 50,
            rarityLimits: {
                1: 5, // max 5 legendaries (rarity 1)
                2: 5, // max 5 epics (rarity 2)
                3: 5, // max 5 rares (rarity 3)
                4: 5  // max 5 commons (rarity 4)
            },
            description: "5 cards of any rarity, max 50 stars"
        }
    };

    // Helper function to check if a combination respects rarity limits
    function isValidRarityCombination(cards, config) {
        const rarityCounts = {};
        
        // Count cards by rarity
        cards.forEach(card => {
            rarityCounts[card.rarity] = (rarityCounts[card.rarity] || 0) + 1;
        });
        
        // Check each rarity limit
        for (const [rarity, limit] of Object.entries(config.rarityLimits)) {
            const rarityNum = parseInt(rarity);
            const count = rarityCounts[rarityNum] || 0;
            if (count > limit) {
                return false;
            }
        }
        
        return true;
    }

    // Helper function to check if a combination has unique hero_ids
    function hasUniqueHeroes(cards) {
        const heroIds = new Set();
        for (const card of cards) {
            if (heroIds.has(card.hero_id)) {
                return false; // Duplicate hero_id found
            }
            heroIds.add(card.hero_id);
        }
        return true; // All hero_ids are unique
    }

    // Generic function to generate optimal deck for any league
    function generateOptimalDeck(leagueKey) {
        if (!currentCards) {
            document.getElementById(`${leagueKey}-deck-result`).innerHTML = '<p style="color: #ff6b6b;">No cards loaded. Please fetch cards first.</p>';
            return;
        }

        const config = leagueConfigs[leagueKey];
        if (!config) {
            console.error('Invalid league key:', leagueKey);
            return;
        }

        // Show initial status
        document.getElementById(`${leagueKey}-deck-result`).innerHTML = `
            <div style="color: #FACC15; text-align: center; padding: 20px;">
                <i class="fa-solid fa-spinner fa-spin"></i> Analyzing ${config.name} deck combinations...
            </div>
        `;

        // Use setTimeout to allow UI to update before heavy computation
        setTimeout(() => {
            console.log(`Generating optimal ${config.name} deck...`);

            // Filter for league eligible cards
            const allowedRarities = Object.keys(config.rarityLimits).map(r => parseInt(r));
            const eligibleCards = currentCards.filter(card => {
                const hasMedianScore = card.medianScore !== null && card.medianScore !== undefined;
                const isAllowedRarity = allowedRarities.includes(card.rarity);
                const hasAvailable = card.availableCards > 0;
                return isAllowedRarity && hasMedianScore && hasAvailable;
            });

            // Update status with eligible cards count
            document.getElementById(`${leagueKey}-deck-result`).innerHTML = `
                <div style="color: #FACC15; text-align: center; padding: 20px;">
                    <i class="fa-solid fa-spinner fa-spin"></i> Found ${eligibleCards.length} eligible cards<br>
                    <span style="font-size: 0.9em;">Selecting top candidates...</span>
                </div>
            `;

            setTimeout(() => {
                console.log(`${config.name} eligible cards found:`, eligibleCards.length);

                if (eligibleCards.length === 0) {
                    const rarityNames = allowedRarities.map(r => {
                        const rarityMap = { 1: "legendary", 2: "epic", 3: "rare", 4: "common" };
                        return rarityMap[r];
                    }).join(', ');

                    document.getElementById(`${leagueKey}-deck-result`).innerHTML = `
                        <p style="color: #ff6b6b;">No eligible cards found for ${config.name} league.</p>
                        <p style="color: #ccc; font-size: 0.9em;">Allowed rarities: ${rarityNames}</p>
                        <p style="color: #ccc; font-size: 0.9em;">Cards with median scores: ${currentCards.filter(c => c.medianScore !== null).length}</p>
                    `;
                    return;
                }

                // Strategic card selection based on league requirements
                const topCards = [];
                const starRange = [1,2,3,4,5,6,7,8];

                allowedRarities.forEach(rarity => {
                    const maxNeeded = config.rarityLimits[rarity];
                    starRange.forEach(star => {
                        // Find all eligible cards of this rarity and star value
                        const cardsOfThisRarityAndStar = eligibleCards.filter(card => card.rarity === rarity && card.stars === star);
                        // Sort by median score descending
                        cardsOfThisRarityAndStar.sort((a, b) => (b.medianScore || 0) - (a.medianScore || 0));
                        // Take up to maxNeeded best cards for this rarity/star
                        const selectedCards = cardsOfThisRarityAndStar.slice(0, maxNeeded);
                        topCards.push(...selectedCards);
                    });
                });

                // Update status before heavy computation
                const totalCombinations = topCards.length >= 5 ? 
                    (topCards.length * (topCards.length - 1) * (topCards.length - 2) * (topCards.length - 3) * (topCards.length - 4)) / 120 : 0;
                
                document.getElementById(`${leagueKey}-deck-result`).innerHTML = `
                    <div style="color: #FACC15; text-align: center; padding: 20px;">
                        <i class="fa-solid fa-cog fa-spin"></i> Computing optimal combination...<br>
                        <span style="font-size: 0.9em;">Evaluating ${totalCombinations.toLocaleString()} possible decks</span>
                    </div>
                `;

                setTimeout(() => {
                    console.log(`Total cards for ${config.name} optimization:`, topCards.length);

                    // Generate all possible combinations of 5 cards with constraints
                    let bestCombination = null;
                    let bestScore = 0;
                    let validCombinationsFound = 0;
                    let totalCombinationsChecked = 0;
                    let duplicateHeroRejected = 0;

                    const findBestCombination = (cards) => {
                        const n = cards.length;
                        
                        for (let i = 0; i < n - 4; i++) {
                            // Update progress every 1000 iterations
                            if (i % 1000 === 0 && i > 0) {
                                const progress = Math.round((i / (n - 4)) * 100);
                                document.getElementById(`${leagueKey}-deck-result`).innerHTML = `
                                    <div style="color: #FACC15; text-align: center; padding: 20px;">
                                        <i class="fa-solid fa-cog fa-spin"></i> Computing optimal combination...<br>
                                        <span style="font-size: 0.9em;">Progress: ${progress}% (${validCombinationsFound} valid decks found)</span>
                                    </div>
                                `;
                            }
                            
                            for (let j = i + 1; j < n - 3; j++) {
                                for (let k = j + 1; k < n - 2; k++) {
                                    for (let l = k + 1; l < n - 1; l++) {
                                        for (let m = l + 1; m < n; m++) {
                                            totalCombinationsChecked++;
                                            const combination = [cards[i], cards[j], cards[k], cards[l], cards[m]];
                                            
                                            // Check for unique heroes first (fastest check)
                                            if (!hasUniqueHeroes(combination)) {
                                                duplicateHeroRejected++;
                                                continue;
                                            }
                                            
                                            const totalStars = combination.reduce((sum, card) => sum + card.stars, 0);
                                            
                                            // Check star limit and rarity limits
                                            if (totalStars <= config.maxStars && isValidRarityCombination(combination, config)) {
                                                validCombinationsFound++;
                                                const totalScore = combination.reduce((sum, card) => sum + (card.medianScore || 0), 0);
                                                
                                                if (totalScore > bestScore) {
                                                    bestScore = totalScore;
                                                    bestCombination = combination;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };

                    findBestCombination(topCards);

                    console.log(`${config.name} - Total combinations checked:`, totalCombinationsChecked);
                    console.log(`${config.name} - Rejected for duplicate heroes:`, duplicateHeroRejected);
                    console.log(`${config.name} - Valid combinations found:`, validCombinationsFound);

                    if (!bestCombination) {
                        // Create rarity limits description
                        const rarityMap = { 1: "legendary", 2: "epic", 3: "rare", 4: "common" };
                        const limitsDesc = Object.entries(config.rarityLimits)
                            .map(([rarity, limit]) => `max ${limit} ${rarityMap[rarity]}`)
                            .join(', ');

                        document.getElementById(`${leagueKey}-deck-result`).innerHTML = `
                            <p style="color: #ff6b6b;">No valid combination found for ${config.name} league.</p>
                            <p style="color: #ccc; font-size: 0.9em;">Rarity limits: ${limitsDesc}</p>
                            <p style="color: #ccc; font-size: 0.9em;">Max stars: ${config.maxStars}</p>
                            <p style="color: #ccc; font-size: 0.9em;">Eligible cards: ${eligibleCards.length}</p>
                            <p style="color: #ccc; font-size: 0.9em;">Cards selected for optimization: ${topCards.length}</p>
                            <p style="color: #ccc; font-size: 0.9em;">Combinations checked: ${totalCombinationsChecked}</p>
                            <p style="color: #ccc; font-size: 0.9em;">Rejected for duplicate heroes: ${duplicateHeroRejected}</p>
                            <p style="color: #ccc; font-size: 0.9em;">Valid combinations found: ${validCombinationsFound}</p>
                        `;
                        return;
                    }

                    // Render the optimal deck
                    renderOptimalDeck(bestCombination, bestScore, leagueKey, config);
                }, 50); // Small delay before heavy computation
            }, 100); // Small delay after eligibility check
        }, 50); // Small delay to show initial status
    }

    function renderOptimalDeck(cards, totalScore, leagueKey, config) {
        const rarityMap = {
            1: "legendary",
            2: "epic", 
            3: "rare",
            4: "common"
        };

        const totalStars = cards.reduce((sum, card) => sum + card.stars, 0);
        const avgScore = Math.round(totalScore / 5);
        
        // Count cards by rarity for display
        const rarityCounts = {};
        cards.forEach(card => {
            rarityCounts[card.rarity] = (rarityCounts[card.rarity] || 0) + 1;
        });
        
        const rarityBreakdown = Object.entries(rarityCounts)
            .map(([rarity, count]) => `${count} ${rarityMap[rarity]}`)
            .join(', ');

        let html = `
            <div class="deck-stats">
                <strong>Total Combined Score:</strong> ${Math.round(totalScore)} | 
                <strong>Average Score:</strong> ${avgScore} | 
                <strong>Total Stars:</strong> ${totalStars}/${config.maxStars}<br>
                <strong>Composition:</strong> ${rarityBreakdown}
            </div>
            <div class="deck-cards-container">
        `;

        cards.forEach(card => {
            const rarityName = rarityMap[card.rarity] || card.rarity;
            const imgUrl = `https://r2.fantasy.top/v3/${rarityName}/${card.hero_id}_${card.stars}.png`;
            const medianColor = getColorForRank(card.medianScore || 0, 1000, true);

            html += `
                <div class="deck-card">
                    <img src="${imgUrl}" alt="Hero">
                    <div style="color: white; font-size: 0.8em; margin-bottom: 8px;">
                        ${card.hero_name}
                    </div>
                    <div style="display: flex; justify-content: center; align-items: center; gap: 4px;">
                        <span style="font-size: 0.7em; color: #ccc;">Score:</span>
                        <span style="background-color: ${medianColor}; color: black; padding: 2px 6px; border-radius: 4px; font-size: 0.7em; font-weight: bold;">
                            ${Math.round(card.medianScore)}
                        </span>
                    </div>
                </div>
            `;
        });

        html += '</div>';
        document.getElementById(`${leagueKey}-deck-result`).innerHTML = html;
    }

    function renderCardsByStars(cards) {
        // Store cards globally for deck generation
        currentCards = cards;
        
        // Show the optimal deck sections
        document.getElementById('optimal-decks').style.display = 'block';

        const rarityMap = {
            1: "legendary",
            2: "epic",
            3: "rare",
            4: "common"
        };

        // Join cards with F2P scores data
        const enrichedCards = cards.map(card => {
            const f2pData = f2pScoresData ? f2pScoresData.find(score => score.hero_id === card.hero_id) : null;
            let medianScore = null;
            let adjustedMedianScore = null; // <-- Fix: declare outside

            // Calculate median score using both daily and weekly data
            if (f2pData) {
                let dailyScores = null;
                let weeklyScores = null;

                // Parse daily scores
                if (f2pData.prior_5_days) {
                    try {
                        if (Array.isArray(f2pData.prior_5_days)) {
                            dailyScores = f2pData.prior_5_days;
                        } else if (typeof f2pData.prior_5_days === 'string') {
                            dailyScores = JSON.parse(f2pData.prior_5_days);
                        }
                    } catch (e) {
                        console.error('Error parsing prior_5_days for hero:', card.hero_id);
                    }
                }

                // Parse weekly scores
                if (f2pData.prior_5_weeks_dow_hh) {
                    try {
                        if (Array.isArray(f2pData.prior_5_weeks_dow_hh)) {
                            weeklyScores = f2pData.prior_5_weeks_dow_hh;
                        } else if (typeof f2pData.prior_5_weeks_dow_hh === 'string') {
                            weeklyScores = JSON.parse(f2pData.prior_5_weeks_dow_hh);
                        }
                    } catch (e) {
                        console.error('Error parsing prior_5_weeks_dow_hh for hero:', card.hero_id);
                    }
                }

                medianScore = calculateMedianScore(dailyScores, weeklyScores);
                const rarityMultiplier = getRarityMultiplier(card.rarity);
                adjustedMedianScore = medianScore !== null ? medianScore * rarityMultiplier : null;
            }
            
            return {
                ...card,
                hero_name: f2pData ? f2pData.hero_name : 'Unknown Hero',
                f2p_scores: f2pData || null,
                medianScore: adjustedMedianScore,
                availableCards: card.count - (card.isInDeckCount || 0)
            };
        });

        // Store original enriched cards
        originalCards = enrichedCards;
        currentCards = enrichedCards;
        
        // Set up filter event listeners
        setupFilterListeners();
        setupStarSliderListeners();
        // Apply initial filter (all rarities selected by default)
        applyFilters();
    }

    // Function to set up filter event listeners
    function setupFilterListeners() {
        const filterIds = ['filterLegendary', 'filterEpic', 'filterRare', 'filterCommon'];
        
        filterIds.forEach(id => {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.removeEventListener('change', applyFilters); // Remove existing listener
                checkbox.addEventListener('change', applyFilters);
            }
        });
    }

    // Add after setupFilterListeners()
    function setupStarSliderListeners() {
        const minSlider = document.getElementById('minStarSlider');
        const maxSlider = document.getElementById('maxStarSlider');
        const minLabel = document.getElementById('minStarLabel');
        const maxLabel = document.getElementById('maxStarLabel');

        function updateLabelsAndFilter(event) {
            let minVal = parseInt(minSlider.value);
            let maxVal = parseInt(maxSlider.value);

            // Don't allow values to cross over - prevent invalid movements
            if (event && event.target === minSlider) {
                // If min slider tries to go above max, stop it at max
                if (minVal > maxVal) {
                    minVal = maxVal;
                    minSlider.value = minVal;
                }
            } else if (event && event.target === maxSlider) {
                // If max slider tries to go below min, stop it at min
                if (maxVal < minVal) {
                    maxVal = minVal;
                    maxSlider.value = maxVal;
                }
            }

            minLabel.textContent = minVal;
            maxLabel.textContent = maxVal;
            applyFilters();
        }

        minSlider.addEventListener('input', updateLabelsAndFilter);
        maxSlider.addEventListener('input', updateLabelsAndFilter);
        updateLabelsAndFilter();
    }

    // Function to get currently selected rarities
    function getSelectedRarities() {
        const selectedRarities = [];
        const rarityMap = { 1: "legendary", 2: "epic", 3: "rare", 4: "common" };
        
        Object.entries(rarityMap).forEach(([rarityNum, rarityName]) => {
            const checkbox = document.getElementById(`filter${rarityName.charAt(0).toUpperCase() + rarityName.slice(1)}`);
            if (checkbox && checkbox.checked) {
                selectedRarities.push(parseInt(rarityNum));
            }
        });
        
        return selectedRarities;
    }

    // Update applyFilters to use star slider values
    function applyFilters() {
        if (!originalCards) return;
        const selectedRarities = getSelectedRarities();
        const minStar = parseInt(document.getElementById('minStarSlider').value);
        const maxStar = parseInt(document.getElementById('maxStarSlider').value);

        // Filter cards by selected rarities and star range
        const filteredCards = originalCards.filter(card => {
            return selectedRarities.includes(card.rarity) &&
                card.stars >= minStar && card.stars <= maxStar;
        });

        console.log(`Filtered ${originalCards.length} cards down to ${filteredCards.length} cards`);
        renderFilteredCards(filteredCards);
        currentCards = filteredCards;
    }

    // Fix the renderFilteredCards function - it was incomplete
    function renderFilteredCards(cards) {
        const rarityMap = {
            1: "legendary",
            2: "epic",
            3: "rare",
            4: "common"
        };

        // Group cards by stars
        const groups = {};
        cards.forEach(card => {
            const stars = card.stars;
            if (!groups[stars]) groups[stars] = [];
            groups[stars].push(card);
        });

        // Sort stars descending
        const sortedStars = Object.keys(groups).map(Number).sort((a, b) => b - a);

        let html = '';
        sortedStars.forEach(star => {
            html += `
                <div class="star-section">
                    <h3 class="star-header">${star} Star${star > 1 ? 's' : ''}</h3>
                    <div class="cards-container">`;
                
            // Sort cards in this group by expected_score descending
            groups[star].sort((a, b) => (b.medianScore || 0) - (a.medianScore || 0)).forEach(card => {
                const rarityName = rarityMap[card.rarity] || card.rarity;
                const imgUrl = `https://r2.fantasy.top/v3/${rarityName}/${card.hero_id}_${card.stars}.png`;
                
                // Calculate median score and format daily scores
                let medianHtml = '';
                let dailyScoresHtml = '';
                let weeklyScoresHtml = '';
                let postsHtml = '';
                
                if (card.f2p_scores) {
                    // Handle daily scores
                    if (card.f2p_scores.prior_5_days) {
                        try {
                            let dailyScores;
                            
                            if (Array.isArray(card.f2p_scores.prior_5_days)) {
                                dailyScores = card.f2p_scores.prior_5_days;
                            } else if (typeof card.f2p_scores.prior_5_days === 'string') {
                                dailyScores = JSON.parse(card.f2p_scores.prior_5_days);
                            }
                            
                            if (Array.isArray(dailyScores) && dailyScores.length > 0) {
                                // Sort by date ascending for daily scores
                                dailyScores.sort((a, b) => new Date(a.date) - new Date(b.date));
                                
                                // Update the score badge generation to use correct tooltip dates
                                dailyScoresHtml = `
                                    <div class="last-5-days">Last 5 Days</div>
                                    <div class="score-row">
                                        ${dailyScores.map(score => {
                                            const roundedScore = Math.round(score.max_score);
                                            const backgroundColor = getColorForRank(roundedScore, 1000, true);
                                            const formattedDate = formatDateForTooltip(score.date);
                                            return `<span class="score-badge" style="background-color: ${backgroundColor}; color: black; border-color: #333;" title="${formattedDate}">${roundedScore}</span>`;
                                        }).join('')}
                                    </div>
                                `;
                            }
                        } catch (e) {
                            console.error('Error parsing prior_5_days for hero:', card.hero_name);
                        }
                    }

                    // Handle weekly scores
                    if (card.f2p_scores.prior_5_weeks_dow_hh) {
                        try {
                            let weeklyScores;
                            
                            if (Array.isArray(card.f2p_scores.prior_5_weeks_dow_hh)) {
                                weeklyScores = card.f2p_scores.prior_5_weeks_dow_hh;
                            } else if (typeof card.f2p_scores.prior_5_weeks_dow_hh === 'string') {
                                weeklyScores = JSON.parse(card.f2p_scores.prior_5_weeks_dow_hh);
                            }
                            
                            if (Array.isArray(weeklyScores) && weeklyScores.length > 0) {
                                // Sort by date ascending for weekly scores
                                weeklyScores.sort((a, b) => new Date(a.date) - new Date(b.date));
                                
                                const timeDisplay = formatTimeToLocal(card.f2p_scores.time_24h_from_now);
                                
                                // Update the median HTML in renderFilteredCards to include tooltip
                                weeklyScoresHtml = `
                                    <div class="last-5-days" style="margin-top: 12px;">Last 5 Weeks ${timeDisplay}</div>
                                    <div class="score-row">
                                        ${weeklyScores.map(score => {
                                            const roundedScore = Math.round(score.max_score);
                                            const backgroundColor = getColorForRank(roundedScore, 1000, true);
                                            const formattedDate = formatDateForTooltip(score.date);
                                            return `<span class="score-badge" style="background-color: ${backgroundColor}; color: black; border-color: #333;" title="${formattedDate}">${roundedScore}</span>`;
                                        }).join('')}
                                    </div>
                                `;
                            }
                        } catch (e) {
                            console.error('Error parsing prior_5_weeks_dow_hh for hero:', card.hero_name);
                        }
                    }

                    // Calculate median from combined scores (already done in enrichment)
                    if (card.medianScore !== null) {
                        const roundedMedian = Math.round(card.medianScore);
                        const medianColor = getColorForRank(roundedMedian, 1000, true);
                        medianHtml = `
                            <div class="median-score">
                                <span class="median-label">Median:</span>
                                <span class="median-badge" style="background-color: ${medianColor};" title="Lowest 3 of 10 Scores Excluded">${roundedMedian}</span>
                            </div>
                        `;
                    }

                    // Handle posts per day
                    if (typeof card.f2p_scores.posts_per_day !== "undefined") {
                        const postsPerDay = Number(card.f2p_scores.posts_per_day);
                        postsHtml = `
                            <div style="font-size:0.85em;color:#FACC15;font-weight:bold;margin-bottom:2px;">
                                Posts: ${postsPerDay.toFixed(1)}/day
                            </div>
                        `;
                    }
                }

                // New card rendering logic with in-use count
                const showInUse = card.isInDeckCount && card.isInDeckCount > 0;
                const cardCountText = showInUse
                    ? `x${card.count} (${card.isInDeckCount} in use)`
                    : `x${card.count}`;

                html += `
                    <div class="card">
                        <div class="card-count">${cardCountText}</div>
                        <img src="${imgUrl}" alt="Hero" class="card-image">
                        <div class="card-info">
                            ${card.hero_name}
                        </div>
                        ${postsHtml}
                        ${medianHtml}
                        ${dailyScoresHtml}
                        ${weeklyScoresHtml}
                    </div>
                `;
            });
            html += '</div></div>';
        });
        document.getElementById('result').innerHTML = html;
    }

    // Add the missing event listener for the fetch button
    document.addEventListener('DOMContentLoaded', async function() {
        // Fetch F2P scores data on page load
        await fetchF2PScores();

        // --- Add this block to auto-calculate and log Hugo's median ---
        if (f2pScoresData) {
            const hugo = f2pScoresData.find(row => row.hero_name === "Hugo Fartingale");
            if (hugo) {
                let dailyScores = Array.isArray(hugo.prior_5_days) ? hugo.prior_5_days : JSON.parse(hugo.prior_5_days);
                let weeklyScores = Array.isArray(hugo.prior_5_weeks_dow_hh) ? hugo.prior_5_weeks_dow_hh : JSON.parse(hugo.prior_5_weeks_dow_hh);
                const median = calculateMedianScore(dailyScores, weeklyScores, "Hugo Fartingale");
                console.log("Hugo Fartingale medianScore:", median);
            } else {
                console.log("No F2P data found for Hugo Fartingale");
            }
        }
        
        // Set up the fetch button event listener
        document.getElementById('fetchBtn').addEventListener('click', async function() {
            const token = document.getElementById('token').value.trim().replace(/^["']|["']$/g, '');
            if (!token) {
                alert('Please enter a bearer token');
                return;
            }

            try {
                document.getElementById('status').textContent = 'Fetching cards...';
                const result = await fetchAllCards(token);
                document.getElementById('status').textContent = `Total cards in inventory: ${result.total}`;
                renderCardsByStars(result.cards);
            } catch (error) {
                console.error('Error fetching cards:', error);
                document.getElementById('status').textContent = `Error: ${error.message}`;
            }
        });
        
        // Set up deck generation buttons
        document.getElementById('generateBronzeBtn').addEventListener('click', () => generateOptimalDeck('bronze'));
        document.getElementById('generateSilverBtn').addEventListener('click', () => generateOptimalDeck('silver'));
        document.getElementById('generateGoldBtn').addEventListener('click', () => generateOptimalDeck('gold'));
        document.getElementById('generateEliteBtn').addEventListener('click', () => generateOptimalDeck('elite'));
    });

    function getRarityMultiplier(rarity) {
        switch (rarity) {
            case 1: return 2.5; // legendary
            case 2: return 2;   // epic
            case 3: return 1.5; // rare
            case 4: return 1;   // common
            default: return 1;
        }
    }
    </script>
</body>
</html>