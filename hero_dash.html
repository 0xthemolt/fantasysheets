<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hero Dashboard</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <h1>Hero Dashboard</h1>
    <div class="view-controls">
        <select id="viewSelector">
            <option value="single">Single Table</option>
            <option value="split">Split by Stars</option>
        </select>
    </div>
    <div id="searchContainer" style="margin: 15px 0;">
        <input type="text" id="heroSearch" placeholder="Search hero handle..." style="
            padding: 8px;
            width: 200px;
            border: 1px solid #ccc;
            border-radius: 4px;
        ">
        <div id="autocompleteResults" style="
            display: none;
            position: absolute;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            width: 200px;
            z-index: 1000;
        "></div>
    </div>
    <div id="tableContainer"></div>

    <script>
        // Add this color mapping function at the top of your script
        function getStarColor(number) {
            const colorMap = {
                1: '#E1D0BC', 2: '#FFFFCC', 3: '#FFFF99',
                4: '#FFFF66', 5: '#FFFF33', 6: '#FFFF00',
                7: '#FFC300', 8: '#ADB7F6'
            };
            return colorMap[number] || 'grey';
        }

        // Add this new color mapping function for the numeric columns
        function getHeatmapColor(value, min, max) {
            if (value === null || value === '' || isNaN(value)) return 'transparent';

            const plasmaColors = [
                '#0d0887', '#46039f', '#7201a8', '#9c179e', '#bd3786', '#d8576b',
                '#ed7953', '#fb9f3a', '#fdca26', '#f0f921'
            ];

            const normalizedValue = (value - min) / (max - min);
            const index = normalizedValue * (plasmaColors.length - 1);
            const lowerIndex = Math.floor(index);
            const upperIndex = Math.ceil(index);

            if (lowerIndex === upperIndex) return plasmaColors[lowerIndex];

            const t = index - lowerIndex;
            return interpolateColor(plasmaColors[lowerIndex], plasmaColors[upperIndex], t);
        }

        function interpolateColor(color1, color2, t) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);
            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);

            const r = Math.round(r1 * (1 - t) + r2 * t);
            const g = Math.round(g1 * (1 - t) + g2 * t);
            const b = Math.round(b1 * (1 - t) + b2 * t);

            return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')}`;
        }

        function sortHeroData(data) {
            return data.sort((a, b) => {
                // Sort by stars descending
                if (b.stars !== a.stars) {
                    return b.stars - a.stars;
                }
                // Then by last 7d score
                return b['last_7d'] - a['last_7d'];
            });
        }

        // Add filter controls above the table
        function createRarityFilter() {
            const filterDiv = document.createElement('div');
            filterDiv.className = 'rarity-filter';
            filterDiv.style.marginBottom = '15px';
            
            const label = document.createElement('label');
            label.textContent = 'Rarity: ';
            label.style.marginRight = '10px';
            
            const select = document.createElement('select');
            select.id = 'rarityFilter';
            select.style.padding = '5px';
            
            const options = [
                { value: 'all', text: 'All' },
                { value: 'common', text: 'Common' },
                { value: 'rare', text: 'Rare' }
            ];
            
            options.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.text;
                select.appendChild(option);
            });
            
            select.addEventListener('change', () => {
                const selectedRarity = select.value;
                filterTableByRarity(selectedRarity);
            });
            
            filterDiv.appendChild(label);
            filterDiv.appendChild(select);
            return filterDiv;
        }
        

        function filterTableByRarity(rarity) {
            const rows = document.querySelectorAll('table tr');
            rows.forEach((row, index) => {
                if (index === 0) return; // Skip header row
                const heroData = row.getAttribute('data-rarity');
                if (rarity === 'all' || heroData === rarity) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        function filterTablesByStars() {
            const selectedButtons = document.querySelectorAll('.star-selector button[data-selected="true"]');
            const selectedStars = Array.from(selectedButtons).map(btn => parseInt(btn.dataset.stars));
            
            const tables = document.querySelectorAll('table');
            tables.forEach(table => {
                const rows = table.querySelectorAll('tr');
                
                rows.forEach((row, index) => {
                    if (index === 0) return; // Skip header row
                    
                    const starCell = row.querySelector('td[data-stars]');
                    if (starCell) {
                        const stars = parseInt(starCell.dataset.stars);
                        const shouldShow = (selectedStars.length === 0 || selectedStars.includes(stars));
                        row.style.display = shouldShow ? '' : 'none';
                    }
                });
            });
        }

        function createPriceRangeSlider(minPrice, maxPrice, bestBid, floorPrice, trend, rarity, fullData) {
            // Calculate min/max floor_or_last_price per rarity
            const rarityPriceRange = fullData.reduce((acc, hero) => {
                if (hero.rarity === rarity && hero.floor_or_last_price != null) {
                    acc.min = Math.min(acc.min, hero.floor_or_last_price);
                    acc.max = Math.max(acc.max, hero.floor_or_last_price);
                }
                return acc;
            }, { min: Infinity, max: -Infinity });

            // Normalize the floor price for color calculation
            const normalizedPrice = (floorPrice - rarityPriceRange.min) / (rarityPriceRange.max - rarityPriceRange.min);
            
            // Generate color from RdYlGn_r colormap (red = expensive, green = cheap)
            const getColor = (value) => {
                const colors = {
                    0: '#1a9850',    // green (cheap)
                    0.25: '#91cf60',
                    0.5: '#ffffbf',
                    0.75: '#fc8d59',
                    1: '#d73027'     // red (expensive)
                };
                
                // Find the two closest color points
                const points = Object.keys(colors).map(Number).sort((a, b) => a - b);
                let lower = points[0];
                let upper = points[points.length - 1];
                
                for (let i = 0; i < points.length - 1; i++) {
                    if (value >= points[i] && value <= points[i + 1]) {
                        lower = points[i];
                        upper = points[i + 1];
                        break;
                    }
                }
                
                // Interpolate between the two colors
                const lowerColor = colors[lower];
                const upperColor = colors[upper];
                const ratio = (value - lower) / (upper - lower);
                
                // Convert hex to RGB and interpolate
                const lowerRGB = hexToRgb(lowerColor);
                const upperRGB = hexToRgb(upperColor);
                const resultRGB = {
                    r: Math.round(lowerRGB.r + (upperRGB.r - lowerRGB.r) * ratio),
                    g: Math.round(lowerRGB.g + (upperRGB.g - lowerRGB.g) * ratio),
                    b: Math.round(lowerRGB.b + (upperRGB.b - lowerRGB.b) * ratio)
                };
                
                return `rgb(${resultRGB.r}, ${resultRGB.g}, ${resultRGB.b})`;
            };

            // Helper function to convert hex to RGB
            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            };

            // Add safety check for null/undefined values
            if (minPrice === null || maxPrice === null || 
                minPrice === undefined || maxPrice === undefined) {
                const container = document.createElement('div');
                container.style.width = '120px';
                container.textContent = 'No price data';
                container.style.fontSize = '10px';
                container.style.color = '#666';
                return container;
            }

            const container = document.createElement('div');
            container.style.width = '150px';  // Increased width by 25%
            container.style.position = 'relative';
            container.style.height = '4px';
            container.style.margin = '4px 0';
            
            // Background track
            const track = document.createElement('div');
            track.style.position = 'absolute';
            track.style.width = '100%';
            track.style.height = '100%';
            track.style.backgroundColor = '#666'; // Fixed neutral color instead of normalized color
            track.style.borderRadius = '2px';
            
            // Best bid dot
            const bidDot = document.createElement('div');
            bidDot.style.position = 'absolute';
            bidDot.style.width = '8px';
            bidDot.style.height = '8px';
            bidDot.style.backgroundColor = '#007bff';
            bidDot.style.borderRadius = '50%';
            bidDot.style.top = '-2px';
            bidDot.style.transform = 'translateX(-50%)';
            
            // Updated trend arrow
            const trendArrow = document.createElement('div');
            trendArrow.style.position = 'absolute';
            trendArrow.style.width = '0';
            trendArrow.style.height = '0';
            trendArrow.style.border = '5px solid transparent'; // Slightly bigger arrow
            trendArrow.style.transform = 'translateX(-50%)';

            if (trend === 'up') {
                trendArrow.style.borderBottom = '8px solid #22c55e'; // Bigger green arrow
                trendArrow.style.top = '-4px'; // Positioned on the line
            } else if (trend === 'down') {
                trendArrow.style.borderTop = '8px solid #ef4444'; // Bigger red arrow
                trendArrow.style.top = '0px'; // Positioned on the line
            }

            // Price labels with only 2 intermediate points
            const priceContainer = document.createElement('div');
            priceContainer.style.display = 'flex';
            priceContainer.style.justifyContent = 'space-between';
            priceContainer.style.fontSize = '10px';
            priceContainer.style.color = '#666';
            priceContainer.style.marginTop = '4px';
            priceContainer.style.position = 'relative';
            
            const formatPrice = (price) => {
                if (price >= 1) {
                    return Number(price).toFixed(1);
                } else {
                    return Number(price).toFixed(3).slice(1);
                }
            };

            // Calculate intermediate points (now only 2)
            const priceRange = maxPrice - minPrice;
            const intermediatePoints = [
                minPrice,
                minPrice + (priceRange * 0.33),  // First third
                minPrice + (priceRange * 0.67),  // Second third
                maxPrice
            ];

            // Create labels for all points
            intermediatePoints.forEach((price, index) => {
                const label = document.createElement('span');
                label.textContent = formatPrice(price);
                label.style.position = 'absolute';
                label.style.left = `${index * 33.3}%`;
                label.style.transform = 'translateX(-50%)';
                priceContainer.appendChild(label);
            });

            // Calculate positions - FIXED VERSION
            const bidPos = ((bestBid - minPrice) / (maxPrice - minPrice)) * 100;
            const floorPos = ((floorPrice - minPrice) / (maxPrice - minPrice)) * 100;
            
            // Clamp the positions between 0 and 100
            const clampedBidPos = Math.max(0, Math.min(100, bidPos));
            const clampedFloorPos = Math.max(0, Math.min(100, floorPos));
            
            // Add some debug logging
            console.log('Price Range:', {
                minPrice,
                maxPrice,
                bestBid,
                floorPrice,
                bidPos: clampedBidPos,
                floorPos: clampedFloorPos
            });
            
            bidDot.style.left = `${clampedBidPos}%`;
            trendArrow.style.left = `${clampedFloorPos}%`;
            
            container.appendChild(track);
            container.appendChild(bidDot);
            container.appendChild(trendArrow);
            container.appendChild(priceContainer);
            
            return container;
        }

        function parseViewCount(viewStr) {
            const multiplier = viewStr.endsWith('M') ? 1000000 : (viewStr.endsWith('K') ? 1000 : 1);
            return parseFloat(viewStr.replace(/[MK]/g, '')) * multiplier;
        }

        function formatViewCount(value) {
            if (value >= 1000000) {
                return (value / 1000000).toFixed(1).replace('.0', '') + 'M';
            }
            if (value >= 1000) {
                return (value / 1000).toFixed(0) + 'K';
            }
            return value.toString();
        }

        function calculateTrend(values) {
            // Use linear regression to determine overall trend
            const n = values.length;
            const x = Array.from({length: n}, (_, i) => i);
            const y = values;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((a, b, i) => a + b * y[i], 0);
            const sumXX = x.reduce((a, b) => a + b * b, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            return slope;
        }

        function createSparkline(viewsData, heroHandle, rarity) {
            const container = document.createElement('div');
            container.style.position = 'relative';
            container.style.width = '150px';
            container.style.height = '40px';
            container.style.padding = '5px';
            
            // Clean the viewsData string by removing leading empty segments
            const cleanedViewsData = viewsData.replace(/^\|+\s*/, '');
            
            // Parse view counts and log any issues
            const views = cleanedViewsData.split('|')
                .map((v, index) => {
                    const trimmed = v.trim();
                    const parsed = parseViewCount(trimmed);
                    if (isNaN(parsed)) {
                        console.error(`Invalid view count found:`, {
                            heroHandle,
                            rarity,
                            rawValue: trimmed,
                            index,
                            fullViewsData: viewsData
                        });
                    }
                    return parsed;
                })
                .filter(v => !isNaN(v)); // Filter out any NaN values

            // Log if we have any NaN values
            if (views.some(isNaN)) {
                console.error('NaN values detected:', {
                    heroHandle,
                    rarity,
                    views,
                    rawData: viewsData
                });
            }

            const maxView = Math.max(...views);
            const minView = Math.min(...views);
            const trend = calculateTrend(views);
            
            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.style.overflow = 'visible';
            
            // Calculate points
            const width = 150;
            const height = 30;
            const points = views.map((view, i) => {
                const x = (i / (views.length - 1)) * width;
                const y = height - ((view - minView) / (maxView - minView)) * height;
                return `${x},${y}`;
            }).join(' ');
            
            // Create polyline
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            line.setAttribute('points', points);
            line.setAttribute('fill', 'none');
            line.setAttribute('stroke', trend > 0 ? '#22c55e' : '#ef4444');
            line.setAttribute('stroke-width', '2');
            
            // Add value labels
            views.forEach((view, i) => {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                const x = (i / (views.length - 1)) * width;
                const y = height - ((view - minView) / (maxView - minView)) * height;
                text.setAttribute('x', x);
                text.setAttribute('y', y - 8);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '8px');
                text.setAttribute('fill', '#666');
                text.textContent = formatViewCount(view);
                svg.appendChild(text);
            });
            
            svg.appendChild(line);
            container.appendChild(svg);
            
            return container;
        }

        function normalizeAndColorPrice(price, minPrice, maxPrice) {
            // RdYlGn_r colormap colors from matplotlib
            const colors = [
                '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf',
                '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850'
            ].reverse();  // Reverse to make red for high values
            
            const normalizedValue = (price - minPrice) / (maxPrice - minPrice);
            const colorIndex = Math.min(Math.floor(normalizedValue * colors.length), colors.length - 1);
            return colors[colorIndex];
        }

        function formatPrice(price) {
            return price ? price.toFixed(3).replace(/^0+/, '') : '-';
        }

        function createPriceCell(price, minPrice, maxPrice) {
            const container = document.createElement('div');
            container.style.padding = '4px 8px';
            container.style.backgroundColor = normalizeAndColorPrice(price, minPrice, maxPrice);
            container.style.color = 'black';
            container.style.fontWeight = 'bold';
            container.style.textShadow = 'none';
            container.style.borderRadius = '4px';
            container.textContent = formatPrice(price);
            return container;
        }

        // Define these functions first
        function getColumnIndex(columnName) {
            const headers = document.querySelector('table thead tr').children;
            for (let i = 0; i < headers.length; i++) {
                if (headers[i].getAttribute('data-sort') === columnName) {
                    return i + 1;
                }
            }
            return -1;
        }

        function sortTable(column, descending) {
            console.log('Sorting column:', column, 'descending:', descending); // Debug log
            
            const tables = document.querySelectorAll('table');
            tables.forEach(table => {
                const tbody = table.querySelector('tbody');
                const rows = Array.from(tbody.querySelectorAll('tr'));
                
                rows.sort((a, b) => {
                    const columnIndex = getColumnIndex(column);
                    console.log('Column index:', columnIndex); // Debug log
                    
                    // Get the cell values
                    const aCell = a.querySelector(`td:nth-child(${columnIndex})`);
                    const bCell = b.querySelector(`td:nth-child(${columnIndex})`);
                    
                    // Extract numeric values (handle K/M formatting if present)
                    let aValue = aCell ? parseFloat(aCell.textContent) : -Infinity;
                    let bValue = bCell ? parseFloat(bCell.textContent) : -Infinity;
                    
                    // Handle NaN values
                    if (isNaN(aValue)) aValue = -Infinity;
                    if (isNaN(bValue)) bValue = -Infinity;
                    
                    return descending ? bValue - aValue : aValue - bValue;
                });
                
                // Clear and re-append sorted rows
                while (tbody.firstChild) {
                    tbody.removeChild(tbody.firstChild);
                }
                rows.forEach(row => tbody.appendChild(row));
            });
        }

        function addSortListeners() {
            const headers = document.querySelectorAll('th[data-sort]');
            headers.forEach(header => {
                header.addEventListener('click', function() {
                    const column = this.getAttribute('data-sort');
                    
                    // Find current sort direction
                    const currentArrow = this.querySelector('.sort-arrow.active');
                    const isDescending = currentArrow && currentArrow.classList.contains('down');
                    
                    // Reset all arrows in all headers
                    document.querySelectorAll('.sort-arrow').forEach(arrow => {
                        arrow.classList.remove('active');
                    });
                    
                    // Toggle between ascending and descending
                    const newArrow = this.querySelector(isDescending ? '.sort-arrow.up' : '.sort-arrow.down');
                    if (newArrow) {
                        newArrow.classList.add('active');
                    }
                    
                    // Sort the table
                    sortTable(column, !isDescending);
                });
            });
        }

        // Then your existing createTable function
        function createTable(data, headers) {
            // Sort data initially by last_7d
            data = data.sort((a, b) => b['last_7d'] - a['last_7d']);
            
            const table = document.createElement('table');
            
            // Filter out the columns we want to skip
            const columnsToSkip = [
                 'min_price', 'max_price',
                'floor_or_last_price',
                'is_floor_above_max_trade',
                'trend', 
                'rare_floor_as_common',
                // Add the quantity columns to skip
                'avail_card_qty', 'card_qty', 'own_card', 'deck_qty', 'com_qty'
            ];
    
            // Create header row
            const headerRow = document.createElement('tr');
            headers.forEach(header => {
                if (!columnsToSkip.includes(header) && 
                    header !== 'rarity' && 
                    header !== 'hero_pfp_image_url') {
                    const th = document.createElement('th');

                    const headerMap = {
                        'floor_price': 'floor',
                        'l3_avg_price': 'avg_l3',
                        'best_bid': 'bid',
                        'min_price': 'min',
                        'max_price': 'max',
                        'floor_or_last_price': 'floor',
                        'is_floor_above_max_trade': 'floor > max',
                        'trend': 'trend',
                        'last_7d': '7d',
                        'last_30d': '30d',
                        'ceiling': 'CEIL',
                        'main_26': 'MT26',
                        'main_25': 'MT25',
                        'main_24': 'MT24',
                        'main_23': 'MT23',
                        'main_22': 'MT22',
                        'hero_handle': 'hero',
                        'post_counts': 'posts',
                        'views': 'views',
                        'stars': 'â­', 
                    };
                                
                    // Add data-sort attribute and arrows for sortable columns
                    const sortableColumns = ['last_7d', 'last_30d', 'main_26', 'main_25', 
                                           'main_24', 'main_23', 'main_22', 'ceiling'];
                    
                    if (sortableColumns.includes(header)) {
                        th.setAttribute('data-sort', header);
                        
                        // Create container for header text and arrows
                        const headerContent = document.createElement('div');
                        headerContent.style.display = 'flex';
                        headerContent.style.alignItems = 'center';
                        headerContent.style.gap = '4px';
                        
                        // Add header text - Use the headerMap here
                        const headerText = document.createElement('span');
                        headerText.textContent = headerMap[header] || header;
                        headerContent.appendChild(headerText);
                        
                        // Add sort arrows container
                        const arrowsDiv = document.createElement('div');
                        arrowsDiv.className = 'sort-arrows';
                        
                        // Add up arrow
                        const upArrow = document.createElement('span');
                        upArrow.className = 'sort-arrow up';
                        arrowsDiv.appendChild(upArrow);
                        
                        // Add down arrow
                        const downArrow = document.createElement('span');
                        downArrow.className = 'sort-arrow down';
                        // Set default sort on last_7d
                        if (header === 'last_7d') {
                            downArrow.classList.add('active');
                        }
                        arrowsDiv.appendChild(downArrow);
                        
                        headerContent.appendChild(arrowsDiv);
                        th.appendChild(headerContent);
                    } else {
                        // For non-sortable columns, also use the headerMap
                        th.textContent = headerMap[header] || header;
                    }
                    
                    headerRow.appendChild(th);
                }
            });
            table.appendChild(headerRow);
            
            // Create data rows
            data.forEach(hero => {
                const row = document.createElement('tr');
                row.setAttribute('data-rarity', hero.rarity);
                
                headers.forEach(header => {
                    if (!columnsToSkip.includes(header) && 
                        header !== 'rarity' && 
                        header !== 'hero_pfp_image_url') {
                        const td = document.createElement('td');
                        
                        if (header === 'floor_price' || header === 'l3_avg_price' || header === 'best_bid') {
                            // Get min/max prices for the hero's rarity
                            const rarityPrices = data
                                .filter(h => h.rarity === hero.rarity)
                                .map(h => h[header])
                                .filter(p => p !== null && p !== undefined && !isNaN(p));
                            
                            const minPrice = Math.min(...rarityPrices);
                            const maxPrice = Math.max(...rarityPrices);
                            
                            // Create colored price cell
                            const priceCell = createPriceCell(hero[header], minPrice, maxPrice);
                            td.appendChild(priceCell);
                        } else if (header === 'hero_handle') {
                            // Create a container div for all elements
                            const containerDiv = document.createElement('div');
                            containerDiv.style.display = 'flex';
                            containerDiv.style.flexDirection = 'column';
                            containerDiv.style.gap = '4px';
                            containerDiv.style.alignItems = 'center'; // Center everything

                            // Create the hero handle container
                            const heroInfoDiv = document.createElement('div');
                            heroInfoDiv.style.display = 'flex';
                            heroInfoDiv.style.alignItems = 'center';
                            heroInfoDiv.style.justifyContent = 'center'; // Center horizontally
                            heroInfoDiv.style.gap = '10px';
                            heroInfoDiv.style.width = '100%'; // Ensure full width

                            // Create and style the image
                            const img = document.createElement('img');
                            img.src = hero.hero_pfp_image_url;
                            img.style.width = '24px';
                            img.style.height = '24px';
                            img.style.borderRadius = '50%';
                            img.style.objectFit = 'cover';

                            // Create link for hero handle
                            const link = document.createElement('a');
                            link.href = `https://x.com/${hero[header]}`;
                            link.target = '_blank';
                            link.style.textDecoration = 'none';
                            link.style.cursor = 'pointer';
                            link.style.color = hero.rarity === 'common' ? '#4AF54E' : '#02E5E8';
                            link.style.fontWeight = 'bold';
                            link.textContent = hero[header];

                            // Update the createPriceRangeSlider call to include floor price and trend
                            const slider = createPriceRangeSlider(
                                hero.min_price, 
                                hero.max_price, 
                                hero.best_bid,
                                hero.floor_or_last_price,
                                hero.trend,
                                hero.rarity,
                                data
                            );

                            // Combine all elements
                            heroInfoDiv.appendChild(img);
                            heroInfoDiv.appendChild(link);
                            containerDiv.appendChild(heroInfoDiv);
                            containerDiv.appendChild(slider);
                            td.appendChild(containerDiv);
                        } else if (header === 'stars') {
                            td.setAttribute('data-stars', hero[header]);
                            td.innerHTML = `
                                <div style="
                                    display: inline-block;
                                    width: 24px;
                                    height: 24px;
                                    line-height: 24px;
                                    border-radius: 50%;
                                    background-color: ${getStarColor(hero[header])};
                                    color: black;
                                    text-align: center;
                                    font-weight: bold;
                                    margin-right: 5px;">
                                    ${hero[header]}
                                </div>`;
                        } else if (header.includes('main_') || header.includes('last_7d') || 
                                 header.includes('last_30d') || header === 'ceiling') {
                            const value = parseFloat(hero[header]);
                            // Get min/max for this column
                            const values = data.map(h => parseFloat(h[header])).filter(v => !isNaN(v));
                            const min = Math.min(...values);
                            const max = Math.max(...values);
                            
                            td.textContent = value ? Math.round(value) : '';
                            td.style.backgroundColor = getHeatmapColor(value, min, max);
                            td.style.color = 'black';  // Change to black text
                            td.style.textAlign = 'center';  // Center align numbers
                            td.style.fontWeight = '500';  // Slightly bold for better readability
                        } else if (header === 'post_counts') {
                            // Create a container for both visualizations
                            const visualContainer = document.createElement('div');
                            visualContainer.style.display = 'flex';
                            visualContainer.style.gap = '10px';
                            visualContainer.style.alignItems = 'center';
                            
                            // Add mini bar chart
                            visualContainer.appendChild(createMiniBarChart(hero[header]));
                            
                            // Add circle visualization
                            visualContainer.appendChild(createCircleVisualization(hero[header]));
                            
                            td.appendChild(visualContainer);
                        } else if (header === 'views') {
                            const sparkline = createSparkline(
                                hero[header],
                                hero.hero_handle,  // Add these parameters
                                hero.rarity
                            );
                            td.appendChild(sparkline);
                        } else {
                            td.textContent = hero[header] || '';
                        }
                        row.appendChild(td);
                    }
                });
                table.appendChild(row);
            });
            
            addSortListeners();
            
            // Trigger initial sort on last_7d
            const last7dHeader = table.querySelector('th[data-sort="last_7d"]');
            if (last7dHeader) {
                const downArrow = last7dHeader.querySelector('.sort-arrow.down');
                if (downArrow) {
                    downArrow.classList.add('active');
                }
            }
            
            return table;
        }

        function createMiniBarChart(postCounts) {
            // Split the post counts and convert to numbers
            const counts = postCounts.split('|').map(n => parseInt(n.trim()));
            const maxCount = Math.max(...counts);
            
            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.alignItems = 'flex-end';
            container.style.gap = '2px';
            container.style.height = '30px';
            container.style.padding = '2px';
            
            counts.forEach(count => {
                const bar = document.createElement('div');
                const height = (count / maxCount) * 100;
                bar.style.width = '4px';
                bar.style.height = `${height}%`;
                bar.style.backgroundColor = '#4a5568';
                bar.style.borderRadius = '1px';
                container.appendChild(bar);
            });
            
            return container;
        }

        function createCircleVisualization(postCounts) {
            const counts = postCounts.split('|').map(n => parseInt(n.trim()));
            const maxCount = Math.max(...counts);
            
            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.gap = '7.5px';  // Reduced from 10px (25% reduction)
            container.style.alignItems = 'center';
            container.style.justifyContent = 'center';
            
            counts.forEach(count => {
                const circleContainer = document.createElement('div');
                circleContainer.style.position = 'relative';
                circleContainer.style.width = '30px';  // Reduced from 40px
                circleContainer.style.height = '30px';  // Reduced from 40px
                circleContainer.style.display = 'flex';
                circleContainer.style.alignItems = 'center';
                circleContainer.style.justifyContent = 'center';
                
                const circle = document.createElement('div');
                circle.style.position = 'absolute';
                circle.style.borderRadius = '50%';
                circle.style.backgroundColor = 'rgba(99, 102, 241, 0.4)';
                
                // Size based on count relative to max (min 15px, max 30px)
                const size = Math.max(15, Math.min(30, 15 + (count / maxCount * 15))); // Adjusted ranges
                circle.style.width = `${size}px`;
                circle.style.height = `${size}px`;
                
                const label = document.createElement('span');
                label.textContent = count;
                label.style.color = 'white';
                label.style.fontSize = '9px';  // Reduced from 12px
                label.style.fontWeight = 'bold';
                label.style.textShadow = '1px 1px 1px rgba(0,0,0,0.5)';
                label.style.zIndex = '1';
                
                circleContainer.appendChild(circle);
                circleContainer.appendChild(label);
                container.appendChild(circleContainer);
            });
            
            return container;
        }

        function displaySplitTables(data, headers) {
            const container = document.getElementById('tableContainer');
            container.innerHTML = '';
            
            // Group heroes by star count
            const groupedHeroes = {};
            data.forEach(hero => {
                if (!groupedHeroes[hero.stars]) {
                    groupedHeroes[hero.stars] = [];
                }
                groupedHeroes[hero.stars].push(hero);
            });
            
            // Create a table for each star level
            Object.keys(groupedHeroes)
                .sort((a, b) => b - a)
                .forEach(starLevel => {
                    const section = document.createElement('div');
                    section.className = 'star-section';
                    
                    const heading = document.createElement('h2');
                    heading.style.textAlign = 'left';  // Left align the heading
                    heading.innerHTML = `<span style="
                        display: inline-block;
                        width: 32px;
                        height: 32px;
                        line-height: 32px;
                        border-radius: 50%;
                        background-color: ${getStarColor(parseInt(starLevel))};
                        color: black;
                        text-align: center;
                        font-weight: bold;
                        margin-right: 10px;">
                        ${starLevel}
                    </span> Star Heroes`;
                    section.appendChild(heading);
                    
                    const tableData = sortHeroData(groupedHeroes[starLevel]);
                    section.appendChild(createTable(tableData, headers));
                    container.appendChild(section);
                });
            
            // Add the sort event listeners after table creation
            addSortListeners();
        }

        function createStarFilter() {
            const filterDiv = document.createElement('div');
            filterDiv.className = 'star-selector';
            filterDiv.style.marginBottom = '15px';
            filterDiv.style.display = 'flex';
            filterDiv.style.gap = '8px';
            
            const label = document.createElement('label');
            label.textContent = 'Stars: ';
            label.style.marginRight = '10px';
            
            filterDiv.appendChild(label);
            
            // Add "All" button first
            const allButton = document.createElement('button');
            allButton.textContent = 'All';
            allButton.style.backgroundColor = '#ffffff';
            allButton.style.border = '2px solid #ccc';
            allButton.style.borderRadius = '15px'; // More rounded for the All button
            allButton.style.padding = '0 10px';    // Wider padding for text
            allButton.style.cursor = 'pointer';
            allButton.style.height = '30px';
            
            allButton.addEventListener('click', () => {
                // Reset all star buttons
                filterDiv.querySelectorAll('button[data-stars]').forEach(btn => {
                    btn.dataset.selected = 'false';
                    btn.style.border = 'none';
                });
                filterTablesByStars();
            });
            
            filterDiv.appendChild(allButton);
            
            // Create buttons for stars 1-8
            for (let i = 1; i <= 8; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.dataset.stars = i;
                button.style.backgroundColor = getStarColor(i);
                button.style.border = 'none';
                button.style.borderRadius = '50%';
                button.style.width = '30px';
                button.style.height = '30px';
                button.style.cursor = 'pointer';
                button.dataset.selected = 'false';
                
                button.addEventListener('click', () => {
                    button.dataset.selected = button.dataset.selected === 'true' ? 'false' : 'true';
                    // Toggle white border
                    button.style.border = button.dataset.selected === 'true' ? '2px solid white' : 'none';
                    filterTablesByStars();
                });
                
                filterDiv.appendChild(button);
            }
            
            return filterDiv;
        }

        // Add these new functions after your existing functions but before loadHeroData()

        function createSearchBox(data) {
            const searchInput = document.getElementById('heroSearch');
            const autocompleteResults = document.getElementById('autocompleteResults');
            let currentFocus = -1;

            // Create a Set of unique hero handles for faster lookup
            const heroHandles = new Set(data.map(hero => hero.hero_handle));

            searchInput.addEventListener('input', function(e) {
                // Trim the search text and update the input value
                const searchText = this.value.trim();
                this.value = searchText; // This will automatically remove spaces
                
                // Rest of the function remains the same
                autocompleteResults.innerHTML = '';
                
                if (!searchText) {
                    autocompleteResults.style.display = 'none';
                    filterTablesByHeroHandle('');
                    return;
                }

                // Find matching hero handles
                const matches = Array.from(heroHandles)
                    .filter(handle => handle.toLowerCase().includes(searchText))
                    .slice(0, 10); // Limit to 10 results

                if (matches.length > 0) {
                    autocompleteResults.style.display = 'block';
                    matches.forEach((handle, index) => {
                        const div = document.createElement('div');
                        div.textContent = handle;
                        div.style.padding = '8px';
                        div.style.cursor = 'pointer';
                        div.style.borderBottom = '1px solid #333';

                        // Highlight matching text
                        const regex = new RegExp(searchText, 'gi');
                        div.innerHTML = handle.replace(regex, match => `<strong style="color: #4AF54E">${match}</strong>`);

                        div.addEventListener('mouseover', function() {
                            this.style.backgroundColor = '#333';
                        });

                        div.addEventListener('mouseout', function() {
                            this.style.backgroundColor = '';
                        });

                        div.addEventListener('click', function() {
                            searchInput.value = handle;
                            autocompleteResults.style.display = 'none';
                            filterTablesByHeroHandle(handle);
                        });

                        autocompleteResults.appendChild(div);
                    });
                } else {
                    autocompleteResults.style.display = 'none';
                }

                filterTablesByHeroHandle(searchText);
            });

            // Handle keyboard navigation
            searchInput.addEventListener('keydown', function(e) {
                const items = autocompleteResults.getElementsByTagName('div');
                
                if (e.key === 'ArrowDown') {
                    currentFocus++;
                    addActive(items);
                    e.preventDefault();
                } else if (e.key === 'ArrowUp') {
                    currentFocus--;
                    addActive(items);
                    e.preventDefault();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (currentFocus > -1 && items[currentFocus]) {
                        items[currentFocus].click();
                    }
                }
            });

            // Close autocomplete when clicking outside
            document.addEventListener('click', function(e) {
                if (!searchInput.contains(e.target) && !autocompleteResults.contains(e.target)) {
                    autocompleteResults.style.display = 'none';
                }
            });

            function addActive(items) {
                if (!items) return;

                removeActive(items);
                if (currentFocus >= items.length) currentFocus = 0;
                if (currentFocus < 0) currentFocus = items.length - 1;

                items[currentFocus].style.backgroundColor = '#333';
            }

            function removeActive(items) {
                Array.from(items).forEach(item => {
                    item.style.backgroundColor = '';
                });
            }
        }

        function filterTablesByHeroHandle(searchText) {
            const tables = document.querySelectorAll('table');
            const searchLower = searchText.trim().toLowerCase();

            tables.forEach(table => {
                const rows = table.querySelectorAll('tr');
                
                rows.forEach((row, index) => {
                    if (index === 0) return; // Skip header row
                    
                    const heroCell = row.querySelector('td a'); // Find the hero handle link
                    if (heroCell) {
                        const heroHandle = heroCell.textContent.toLowerCase();
                        const shouldShow = searchText === '' || heroHandle.includes(searchLower);
                        row.style.display = shouldShow ? '' : 'none';
                    }
                });
            });
        }

        // Modify your loadHeroData function to initialize the search box
        async function loadHeroData() {
            try {
                const response = await fetch('hero_dash.json');
                const data = await response.json();
                const headers = Object.keys(data[0]);
                const sortedData = sortHeroData(data);

                // Initialize search box with the data
                createSearchBox(data);

                const viewSelector = document.getElementById('viewSelector');
                const container = document.getElementById('tableContainer');
                
                function updateView() {
                    container.innerHTML = '';
                    // Add both filters
                    const filtersDiv = document.createElement('div');
                    filtersDiv.style.display = 'flex';
                    filtersDiv.style.gap = '20px';
                    filtersDiv.style.marginBottom = '20px';
                    
                    filtersDiv.appendChild(createRarityFilter());
                    filtersDiv.appendChild(createStarFilter());
                    container.appendChild(filtersDiv);
                    
                    if (viewSelector.value === 'single') {
                        container.appendChild(createTable(sortedData, headers));
                    } else {
                        displaySplitTables(data, headers);
                    }
                }

                viewSelector.addEventListener('change', updateView);
                updateView();
                
            } catch (error) {
                console.error('Error loading hero data:', error);
                document.getElementById('tableContainer').innerHTML = 'Error loading data';
            }
        }

        // Load data when page loads
        window.onload = loadHeroData;

    </script>
</body>
</html>