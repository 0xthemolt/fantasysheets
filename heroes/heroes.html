<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXJ5Q7LKKE"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        let supabaseClient;
        let currentSort = {
            column: 'rank',
            direction: 'asc'
        };

        window.onload = async function() {
            // Initialize Supabase
            const supabaseUrl = 'https://hhcuqhvmzwmehdsaamhn.supabase.co';
            const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoY3VxaHZtendtZWhkc2FhbWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzIwMTIsImV4cCI6MjA1MDU0ODAxMn0.xJNGoFLnpnmQGLj8RY_4VLmefPmFzuOyiVHLvFtPkkE';
            supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);

            // Load hero data after Supabase is initialized
            await loadHeroData();
            initializeSparklineHovers();
        };

        // Google Analytics code
        window.dataLayer = window.dataLayer || [];
        function gtag(){{dataLayer.push(arguments);}}
        gtag('js', new Date());
        gtag('config', 'G-LXJ5Q7LKKE');

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
        }

        function generateDummySparkline(values, color = '#6B4E8B') {
            // If values is an array of objects, extract and sort by timestamp first
            if (values.length > 0 && typeof values[0] === 'object') {
                values = values
                    .sort((a, b) => new Date(a.created_at_utc) - new Date(b.created_at_utc))
                    .map(v => v.inflation_degree || v.followers || v.fantasy_score || 0); // Add inflation_degree and fallback to 0
            }

            // Ensure we have numeric values to plot
            if (!values.length || values.every(v => v === 0)) {
                values = [0, 0]; // Default flat line if no valid data
            }

            // Add debug logging
            console.log('Sparkline values:', values);

            // Calculate the range and adjust scaling for small variations
            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            const range = maxValue - minValue;
            
            // Ensure we always have a non-zero range
            const effectiveRange = range || 1;
            
            const points = values.map((value, index) => {
                const x = 5 + (index / (values.length - 1)) * 50;
                const y = 19 - ((value - minValue) / effectiveRange * 14);
                return { x, y, value };
            });

            const pointsString = points.map(p => `${p.x},${p.y}`).join(' ');

            return `
                <div class="sparkline-container">
                    <div class="sparkline-tooltip"></div>
                    <svg width="60" height="24">
                        <polyline 
                            points="${pointsString}"
                            style="stroke: ${color}; stroke-width: 1.5; fill: none;"
                        />
                        ${points.map((p, i) => `
                            <circle 
                                cx="${p.x}" 
                                cy="${p.y}" 
                                r="3" 
                                fill="${color}" 
                                style="opacity: 0"
                                data-value="${p.value}"
                                data-index="${i}"
                            />
                        `).join('')}
                    </svg>
                </div>
            `;
        }

        // Add these new formatting functions
        function formatScore(score) {
            return Math.round(score).toLocaleString();
        }

        function formatFollowers(followers) {
            if (followers >= 100000) {
                return `${(followers / 1000).toFixed(1)}k`;
            } else if (followers >= 1000) {
                return `${(followers / 1000).toFixed(1)}k`;
            }
            return followers.toLocaleString();
        }

        function parseRawValue(value) {
            if (typeof value === 'string') {
                if (value.endsWith('k')) {
                    return parseFloat(value.replace('k', '')) * 1000;
                }
                // Remove commas and convert to number
                return parseFloat(value.replace(/,/g, ''));
            }
            return value;
        }

        // Add function to fetch and display data
        async function loadHeroData() {
            const { data, error } = await supabaseClient
                .from('hero_stat_history')
                .select(`
                    hero_id,
                    hero_handle,
                    hero_name,
                    hero_pfp_url,
                    rank,
                    score_7d,
                    score_24h,
                    stars,
                    followers,
                    inflation_degree,
                    glide_24h_json,
                    glide_7d_json,
                    stars_inflation_follow_json,
                    db_updated
                `)
                .order('rank', { ascending: true });

            if (error) {
                console.error('Error fetching data:', error);
                return;
            }

            renderHeroTable(data);
            
            // Add click handlers for sortable columns
            document.querySelectorAll('th[data-sort]').forEach(th => {
                th.addEventListener('click', () => {
                    const column = th.dataset.sort;
                    
                    // Reset all other arrows
                    document.querySelectorAll('.sort-arrow').forEach(arrow => {
                        arrow.className = 'sort-arrow';
                    });
                    
                    // Update sort direction
                    if (currentSort.column === column) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.column = column;
                        currentSort.direction = 'desc';
                    }
                    
                    // Update arrow for current column
                    const arrow = th.querySelector('.sort-arrow');
                    arrow.className = `sort-arrow active ${currentSort.direction === 'asc' ? 'up' : 'down'}`;
                    
                    // Resort and render
                    renderHeroTable(data);
                });
            });
        }

        // Add this new function to handle table rendering
        function renderHeroTable(data) {
            // Sort the data
            const sortedData = [...data].sort((a, b) => {
                let compareA = a[currentSort.column];
                let compareB = b[currentSort.column];
                
                // Special handling for followers
                if (currentSort.column === 'followers') {
                    compareA = a.followers || 0;
                    compareB = b.followers || 0;
                }
                
                if (compareA === compareB) return 0;
                const comparison = compareA < compareB ? -1 : 1;
                return currentSort.direction === 'asc' ? comparison : -comparison;
            });

            // Your existing rendering code, moved to a separate function
            const tbody = document.querySelector('tbody');
            tbody.innerHTML = sortedData.map(hero => {
                // Modified JSON parsing function
                const safeJsonParse = (jsonString, defaultValue = []) => {
                    try {
                        // Handle case where data might already be an array
                        if (Array.isArray(jsonString)) {
                            return jsonString;
                        }
                        // Handle case where data is a string
                        if (typeof jsonString === 'string') {
                            return JSON.parse(jsonString);
                        }
                        return defaultValue;
                    } catch (e) {
                        console.warn('JSON parse error:', e);
                        console.warn('Raw data:', jsonString);
                        return defaultValue;
                    }
                };

                const glide24h = safeJsonParse(hero.glide_24h_json);
                const glide7d = safeJsonParse(hero.glide_7d_json);
                const starsFollow = safeJsonParse(hero.stars_inflation_follow_json);
                
                // Extract specific fields from starsFollow data
                const followersData = starsFollow.map(entry => ({
                    created_at_utc: entry.created_at_utc,
                    followers: entry.followers
                }));

                const starsData = starsFollow.map(entry => ({
                    created_at_utc: entry.created_at_utc,
                    stars: entry.stars
                }));

                const inflationData = starsFollow.map(entry => ({
                    created_at_utc: entry.created_at_utc,
                    inflation_degree: entry.inflation_degree
                }));

                // Debug logging
                console.log('Hero:', hero.hero_handle);
                console.log('Raw glide24h_json:', hero.followersData);
                console.log('Parsed glide24h:', followersData);
                console.log('Type of glide24h_json:', typeof hero.followersData);
                
                return `
                    <tr>
                        <td>${hero.rank || ''}</td>
                        <td>
                            <div class="hero-cell">
                                ${hero.hero_pfp_url ? `<img src="${hero.hero_pfp_url}" alt="${hero.hero_handle}" class="hero-pfp">` : ''}
                                <span data-hero-name="${hero.hero_name || ''}">${hero.hero_handle}</span>
                            </div>
                        </td>
                        <td>${formatScore(hero.stars || 0)}</td>
                        <td>${formatScore(hero.score_7d || 0)}${generateDummySparkline(glide7d)}</td>
                        <td>${formatScore(hero.score_24h || 0)}${generateDummySparkline(glide24h)}</td>
                        <td>${formatFollowers(hero.followers || 0)}${generateDummySparkline(followersData)}</td>
                        <td>${formatScore(hero.inflation_degree || 0)}${generateDummySparkline(inflationData)}</td>
                    </tr>
                `;
            }).join('');
        }

        function initializeSparklineHovers() {
            document.body.addEventListener('mouseover', function(e) {
                const circle = e.target.closest('circle');
                if (circle) {
                    // Make the hovered circle visible
                    circle.style.opacity = "1";
                    
                    const tooltip = circle.closest('.sparkline-container').querySelector('.sparkline-tooltip');
                    const value = parseFloat(circle.dataset.value);
                    tooltip.innerHTML = `Value: <span class="score-value">${formatScore(value)}</span>`;
                    
                    const containerRect = circle.closest('.sparkline-container').getBoundingClientRect();
                    const circleRect = circle.getBoundingClientRect();
                    
                    const tooltipX = circleRect.left - containerRect.left + (circleRect.width / 2);
                    const tooltipY = -10;
                    
                    tooltip.style.left = `${tooltipX}px`;
                    tooltip.style.top = `${tooltipY}px`;
                    tooltip.style.opacity = '1';
                }
            });

            document.body.addEventListener('mouseout', function(e) {
                const circle = e.target.closest('circle');
                if (circle) {
                    // Hide the circle again
                    circle.style.opacity = "0";
                    const tooltip = circle.closest('.sparkline-container').querySelector('.sparkline-tooltip');
                    tooltip.style.opacity = '0';
                }
            });
        }
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Hero League Winners</title>
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"></noscript>
    <link rel="stylesheet" href="../styles.css">
    <link rel="icon" type="image/png" href="../icons/favicon.webp">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>
<style>
        .sparkline-container {
            position: relative;
        }

        .sparkline-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 9px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
            z-index: 1000;
            transform: translate(-50%, -100%);
            top: -8px;
            text-align: left;
        }

        .sparkline-tooltip .score-value {
            font-size: 11px;
            font-weight: bold;
        }
        
        .table-container {
                margin: 0;
                width: 100%;
                padding: 0 10px;
            }
        .hero-pfp {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
        }

        .sort-arrow {
                display: none; /* Hide by default */
                width: 0;
                height: 0;
                margin: 2px auto;
            }

            .sort-arrow.active.up {
                    display: block; /* Show only when active */
                    border-left: 5px solid transparent;
                    border-right: 5px solid transparent;
                    border-bottom: 5px solid #4CAF50; /* Green */
            }

            .sort-arrow.active.down {
                    display: block; /* Show only when active */
                    border-left: 5px solid transparent;
                    border-right: 5px solid transparent;
                    border-top: 5px solid #F44336; /* Red */
            }
</style>
<body>
    <table>
        <thead>
            <tr>
                <th data-sort="rank">
                    <div class="metric-header">
                        Rank
                        <div class="sort-arrow"></div>
                    </div>
                </th>
                <th data-sort="hero">
                    <div class="metric-header">
                        Hero
                        <div class="sort-arrow"></div>
                    </div>
                </th>
                <th data-sort="stars">
                    <div class="metric-header">
                        <span class="metric-type">
                            <i class="fas fa-star"></i> Stars
                        </span>
                        <div class="sort-arrow"></div>
                    </div>
                </th>
                <th data-sort="score_7d">
                    <div class="metric-header">
                        <span class="metric-type">
                            <i class="fas fa-chart-line"></i> 7d Score
                        </span>
                        <div class="sort-arrow"></div>
                    </div>
                </th>
                <th data-sort="score_24h">
                    <div class="metric-header">
                        <span class="metric-type">
                            <i class="fas fa-clock"></i> 24hr Score
                        </span>
                        <div class="sort-arrow"></div>
                    </div>
                </th>
                <th data-sort="followers">
                    <div class="metric-header">
                        <span class="metric-type">
                            <i class="fas fa-users"></i> Followers
                        </span>
                        <div class="sort-arrow"></div>
                    </div>
                </th>
                <th data-sort="inflation_degree">
                    <div class="metric-header">
                        <span class="metric-type">
                            <i class="fas fa-chart-line"></i> Inflation
                        </span>
                        <div class="sort-arrow"></div>
                    </div>
                </th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
</body>