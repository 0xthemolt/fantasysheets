<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXJ5Q7LKKE"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LXJ5Q7LKKE');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player Bids</title>
    <link rel="stylesheet" href="../styles.css?v=8e4c2f">
    <link rel="icon" type="image/png" href="../icons/favicon.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Add this line to include Supabase -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
        #results-container {
            padding: 1rem;
        }

        @media (min-width: 992px) {
            #results-container {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        /* Add this new class for the low floor cards section */
        .low-floor-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            padding: 1rem;
            margin-top: 2rem;
        }

        @media (min-width: 992px) {
            .low-floor-container {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .hero-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 250px;
            margin: 0 auto;
        }

        .hero-card h3 {
            color: white;
            font-size: .9rem;
            margin-bottom: 4px;
            margin-top: 8px;
        }

        .hero-card .hero-image {
          width: 80px; /* Reduce from larger size */
        }

        .hero-card .hero-name {
          font-size: 8px; /* Smaller font */
        }

        .hero-info {
            color: #666;
            margin: 0.25rem 0;
        }

        .hero-price {
            font-weight: bold;
            color: #2c5282;
            margin-top: 0.5rem;
        }



        .price-col {
            text-align: right;
        }

        .themolt-bid {
            background-color: #e6f7ff;
        }        .card-image {
            width: 20%;
            height: auto;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
        }

        .player-bid {
            color: #4ADE80 !important;
            font-weight: bold;
        }

        .hero-handle {
            color: #777;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        
        .hero-handle:hover {
            color: #1DA1F2;
            text-decoration: underline;
        }
        /* Add to your <style> section */

.control-container {
    background-color: #333;
    padding: 12px 16px;
    margin-bottom: 16px;
    border-radius: 8px;
    display: flex;
    justify-content: flex-end;
    gap: 16px; /* Add this line to create spacing */
}

.sort-options {
    display: flex;
    align-items: center;
    gap: 8px;
}

.sort-options label {
    color: #fff;
    font-weight: 500;
}

.sort-options select {
    background-color: #444;
    color: #fff;
    border: 1px solid #555;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
}

.sort-options select:focus {
    outline: none;
    border-color: #00AAFF;
}

.hero-card.player-winning {
    border: 2px solid #4ADE80;
}

.hero-card.player-not-winning {
    border: 2px solid #FF8C00;
}

.refresh-btn {
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    width: 38px;
    height: 38px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s;
}

.refresh-btn:hover {
    background-color: #2980b9;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.refresh-btn.spinning i {
    animation: spin 1s linear infinite;
}

.hero-card.player-winning-with-gap {
    border: 2px solid #FF69B4 !important; /* Same pink color as price gap */
}

.page-container {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.low-floor-section {
    width: 100%;
    margin-top: 2rem;
}

.low-floor-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
    padding: 1rem;
}

@media (min-width: 992px) {
    .low-floor-container {
        grid-template-columns: repeat(4, 1fr);
    }
}

        /* Update the main-container class to match low-floor-container */
        .main-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            padding: 1rem;
        }

        @media (min-width: 992px) {
            .main-container {
                grid-template-columns: repeat(4, 1fr);
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="control-container">
            <div class="sort-options">
                <label for="sort-select">Sort By:</label>
                <select id="sort-select" onchange="sortCards(this.value)">
                    <option value="not-winning" selected>Not Winning</option>
                    <option value="winning">Winning</option>
                </select>
            </div>
            <button id="refresh-button" class="refresh-btn" title="Refresh player data">
                <i class="fas fa-sync-alt"></i>
            </button>
        </div>
    </header>

    <main>
        <div id="results-container"></div>
        <div id="loading-indicator" style="display: none;">Loading...</div>
        <div id="error-message" style="display: none;"></div>
    </main>

    <script>
    // 1. Constants and Configuration
    const supabaseUrl = 'https://hhcuqhvmzwmehdsaamhn.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoY3VxaHZtendtZWhkc2FhbWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzIwMTIsImV4cCI6MjA1MDU0ODAxMn0.xJNGoFLnpnmQGLj8RY_4VLmefPmFzuOyiVHLvFtPkkE';
    const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);
    const PLAYER_ADDRESS = '0x162F95a9364c891028d255467F616902A479681a';
    
    const KNOWN_BOTS = [
        { handle: 'NoahCohen697864', address: '0x6CBAC11436149e49CE0fFF01c087946032aB0AFC' },
        { handle: 'visavi_eth', address: '0x71355856191061B1723F24DFc1007dAC29F3aCa5' },
        { handle: 'Chiro458', address: '0x307E0aBe028ca468bF97126610e0Ad7C2b2C12Fb' },
        { handle: 'Bartomiej1805', address: '0xeb77499E304792ad15a9C2501E5F9dfdFE6eBa45' },
        { handle: 'nghia19993', address: '0x0bE267CDe2E2E892346363A6e6E27b189f5B17B0' },
        { handle: '_0xE83C0E', address: '0xE8381dB94c161154e2d7FdFF9e8502403565FC0E' },
        { handle: 'Saxeus03', address: '0xa881e9042d377f217D806F90B80aF6b02A6eB92E' },
        { handle: 'xsaint237656', address: '0x311166e0F6745ED6EBa3B76756C518F0ece2B988' },
        { handle: 'moneyfest_2020', address: '0xefbA9AB00b5cC953BeC5Ce1e87F6FfA9b8aACA46' },
        { handle: 'PuperSuper228', address: '0x165E60D31dAc6E711C6e8935dc5c7B1C01fDE8D4' },
        { handle: 'Veslav27323979', address: '0x4A9FfBD7274a1E1cBEBA2192d3Cd53c1a3bca2fF' },
        { handle: 'schettaroX', address: '0xC4a94A00fb486cB131009E7BDBB1772dAc860560' },
    ];
    
    // 2. Data Storage
    let bidData = [];
    
    // 3. API Functions
    async function fetchOrderbook(heroId, rarity) {
        const response = await fetch(`https://api-v2.fantasy.top/marketplace/bid-orders?heroId=${heroId}&rarity=${rarity}&includeOrderbook=true&includePersonalBids=true&includeHighestFiveBids=true`, {
            headers: {
                'accept': 'application/json',
                'x-api-key': 'cbc57228-5495-47b0-ae2f-b43ba6d5a9b6'
            }
        });
        return await response.json();
    }
    
    async function fetchBidBotData() {
        try {
            const { data, error } = await supabaseClient
                .from('vwbid_bot')
                .select(`
                    hero_id, rarity_id, floor_price, bid_price, last_sale,
                    max_price_eth, price_increment_eth, max_card_own_qty,
                    enabled, updated_datetime, updated_by, hero_rarity_id
                `);
            
            if (error) {
                console.error('Error fetching bid bot data:', error);
                return null;
            }
            return data;
        } catch (error) {
            console.error('Error connecting to Supabase:', error);
            return null;
        }
    }
    
    async function fetchBids() {
        try {
            const response = await fetch(`https://api-v2.fantasy.top/player/bids/${PLAYER_ADDRESS}`, {
                headers: {
                    'accept': 'application/json',
                    'x-api-key': 'cbc57228-5495-47b0-ae2f-b43ba6d5a9b6'
                }
            });
            const data = await response.json();
            console.log('Sample item rarity:', data[0]?.rarity);
            console.log('Sample item hero_id:', data[0]?.hero_id);
            console.log('Sample item stars:', data[0]?.hero?.stars);
            
            // Fetch bid bot data
            const bidBotData = await fetchBidBotData();
            
            // Create bid bot lookup map using hero_rarity_id
            const bidBotMap = new Map();
            if (bidBotData) {
                bidBotData.forEach(bot => {
                    bidBotMap.set(bot.hero_rarity_id, bot);
                });
            }
            
            // Deduplicate bids based on hero_id and rarity
            const uniqueHeroes = Array.from(new Map(
                data.map(item => [
                    `${item.hero_id}-${item.rarity}`,
                    item
                ])
            ).values());
            
            // Process each unique hero and fetch orderbook
            const processedData = {
                bids: await Promise.all(uniqueHeroes.map(async item => {
                    const orderbook = await fetchOrderbook(item.hero_id, item.rarity);
                    
                    // Create the key for joining with bid bot data
                    const heroRarityKey = `${item.hero_id}_${item.rarity}`;
                    const bidBotInfo = bidBotMap.get(heroRarityKey);
                    
                    return {
                        bidder_handle: item.bidder_handle,
                        bidder_address: item.trader,
                        price: item.price,
                        expiration_time: item.expiration_time,
                        hero_id: item.hero_id,
                        rarity: item.rarity,
                        stars: item.hero.stars,
                        name: item.hero.name,
                        handle: item.hero.handle,
                        floorPrice: item.floorPrice,
                        orderbook: orderbook,
                        // Add bid bot data
                        bidBot: bidBotInfo || null
                    };
                }))
            };
            
            // 4. Data Processing
            bidData = processedData.bids.map(item => {
                const topFiveBids = item.orderbook.highest_five_bids || [];
                
                // Determine if player is winning this card
                const playerIsWinning = topFiveBids.length > 0 && 
                                       topFiveBids[0].trader && 
                                       topFiveBids[0].trader.toLowerCase() === PLAYER_ADDRESS.toLowerCase();
                
                // Check for price gap below player's winning bid
                const hasGapBelowWinningBid = playerIsWinning && topFiveBids.length > 1 && 
                                             ((topFiveBids[0].price - topFiveBids[1].price) / topFiveBids[0].price) * 100 > 6;
                
                // Set card class based on winning status and gap
                const cardClass = playerIsWinning 
                    ? (hasGapBelowWinningBid ? 'hero-card player-winning-with-gap' : 'hero-card player-winning')
                    : 'hero-card player-not-winning';
                
                // Get bid bot info
                const bidBotInfo = item.bidBot;
                const bidCeiling = bidBotInfo && bidBotInfo.max_price_eth && bidBotInfo.max_price_eth > 0 
                    ? bidBotInfo.max_price_eth.toFixed(5) 
                    : 'N/A';
                const botEnabled = bidBotInfo ? bidBotInfo.enabled : false;
                const botIconColor = botEnabled ? '#4ADE80' : '#888';
                
                // Create bid rows with price gap highlighting
                let bidRows = '';
                
                for (let i = 0; i < topFiveBids.length; i++) {
                    const bid = topFiveBids[i];
                    const prevBid = i > 0 ? topFiveBids[i-1] : null;
                    
                    // Calculate price gap percentage if not the first bid
                    let priceGapClass = '';
                    let priceDiff = 0;

                    if (prevBid) {
                        priceDiff = ((prevBid.price - bid.price) / prevBid.price) * 100;
                        // Only highlight if this is the gap below a player's winning bid
                        const prevBidIsPlayer = prevBid.trader && prevBid.trader.toLowerCase() === PLAYER_ADDRESS.toLowerCase();
                        const isFirstBid = i === 1; // Second row (index 1) would be the gap below first bid
                        
                        if (priceDiff > 6 && prevBidIsPlayer && isFirstBid) {
                            priceGapClass = 'price-gap';
                        }
                    }
                    
                    const isPlayerBid = bid.trader && bid.trader.toLowerCase() === PLAYER_ADDRESS.toLowerCase();
                    
                    // Check if any higher bids are from other players
                    let otherPlayerHasHigherBid = false;
                    for (let j = 0; j < i; j++) {
                        if (topFiveBids[j].trader && 
                            topFiveBids[j].trader.toLowerCase() !== PLAYER_ADDRESS.toLowerCase()) {
                            otherPlayerHasHigherBid = true;
                            break;
                        }
                    }
                    
                    let cellStyle = '';
                    if (isPlayerBid) {
                        if (otherPlayerHasHigherBid) {
                            cellStyle = 'style="color: #FF8C00 !important;"'; // Orange if other player has higher bid
                        } else {
                            cellStyle = 'style="color: #4ADE80 !important;"'; // Green if all higher bids are player's
                        }
                    }
                    
                    const expiration = formatTimeUntilExpiration(bid.expiration_time);
                    const gapStyle = priceGapClass ? 'style="border-top: 2px solid #FF69B4 !important;"' : '';
                    
                    bidRows += `
                    <tr class="${priceGapClass}">
                        <td ${cellStyle} ${gapStyle}>
                            ${bid.bidder_handle || 'Anonymous'}
                            ${isBot(bid.trader) 
                                ? '<i class="fas fa-robot" style="margin-left: 4px; color: #4DC2FC;" title="Known bot"></i>' 
                                : ''}
                        </td>
                        <td ${cellStyle} class="price-col" ${gapStyle}>${formatPrice(bid.price)}</td>
                        <td ${gapStyle} style="color: ${expiration.color} !important;">${expiration.text}</td>
                    </tr>
                    `;
                }

                return {
                    ...item,
                    cardClass,
                    bidRows,
                    bidCeiling,
                    botIconColor
                };
            });
            
            // 5. Render
            renderBids();
            sortCards('not-winning');
        } catch (error) {
            console.error('Error fetching bids:', error);
            document.getElementById('error-message').innerText = 'Error fetching bids. Please try again later.';
            document.getElementById('error-message').style.display = 'block';
        } finally {
            document.getElementById('loading-indicator').style.display = 'none';
        }
    }
    
    function renderBids() {
        const container = document.getElementById('results-container');
        
        // Separate cards based on floorPrice
        const mainCards = bidData.filter(item => parseFloat(item.floorPrice) >= 0.009);
        const lowFloorCards = bidData.filter(item => parseFloat(item.floorPrice) < 0.009);
        
        // Function to generate card HTML
        const generateCardHTML = (item) => `
            <div class="${item.cardClass}">
                <img 
                    class="card-image" 
                    src="https://r2.fantasy.top/v2/${getRarityName(item.rarity)}/${item.hero_id}_${item.stars}.png" 
                    alt="Hero Card"
                    onerror="this.src='../icons/ft_logo.webp'"
                >
                <h3>${item.name}</h3>
                <a href="https://x.com/${item.handle}/" class="hero-handle" target="_blank">@${item.handle}</a>
                <p style="color: #888; font-size: 0.8rem; margin: 4px 0;">Floor: ${item.floorPrice}</p>
                <p style="color: #888; font-size: 0.8rem; margin: 4px 0;">
                    Bid Ceiling: ${item.bidCeiling}
                    <i class="fas fa-robot" style="margin-left: 4px; color: ${item.botIconColor};" title="Bot ${item.bidBot && item.bidBot.enabled ? 'enabled' : 'disabled'}"></i>
                </p>
                
                <table class="bids-table">
                    <thead>
                        <tr>
                            <th>Bidder</th>
                            <th>Price</th>
                            <th>Expires In</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${item.bidRows}
                    </tbody>
                </table>
            </div>
        `;

        // Generate HTML for both sections
        const mainGrid = mainCards.map(item => generateCardHTML(item)).join('');
        const lowFloorGrid = lowFloorCards.map(item => generateCardHTML(item)).join('');

        // Create the combined HTML with a wrapper container
        const combinedHTML = `
            <div class="page-container">
                <div class="main-container">${mainGrid}</div>
                ${lowFloorCards.length > 0 ? `
                    <div class="low-floor-section">
                        <h2 style="color: #888; text-align: center; margin-bottom: 1rem; margin-top: 2rem;">Low Floor Price Cards (&lt; 0.009)</h2>
                        <div class="low-floor-container">${lowFloorGrid}</div>
                    </div>
                ` : ''}
            </div>
        `;

        container.innerHTML = combinedHTML;
    }
    
    function sortCards(sortBy) {
        if (!bidData || bidData.length === 0) {
            console.log('No bid data to sort');
            return;
        }
        
        if (sortBy === 'winning') {
            // Keep original winning sort logic
            bidData.sort((a, b) => {
                const aIsWinning = a.cardClass.includes('player-winning');
                const bIsWinning = b.cardClass.includes('player-winning');
                
                if (aIsWinning && !bIsWinning) return -1;
                if (!aIsWinning && bIsWinning) return 1;
                return 0;
            });
        } else {
            // Enhanced not-winning sort logic
            bidData.sort((a, b) => {
                const getTopTwoBids = (item) => {
                    const orderbook = item.orderbook?.highest_five_bids || [];
                    return orderbook.length >= 2 ? [orderbook[0], orderbook[1]] : [orderbook[0]];
                };

                const calculatePriceGap = (topBids) => {
                    if (topBids.length < 2) return 0;
                    return ((topBids[0].price - topBids[1].price) / topBids[0].price) * 100;
                };

                const isPlayerWinning = (topBid) => {
                    return topBid && topBid.trader && 
                           topBid.trader.toLowerCase() === PLAYER_ADDRESS.toLowerCase();
                };

                const aTopBids = getTopTwoBids(a);
                const bTopBids = getTopTwoBids(b);
                const aIsWinning = aTopBids.length > 0 && isPlayerWinning(aTopBids[0]);
                const bIsWinning = bTopBids.length > 0 && isPlayerWinning(bTopBids[0]);
                const aGap = aIsWinning ? calculatePriceGap(aTopBids) : 0;
                const bGap = bIsWinning ? calculatePriceGap(bTopBids) : 0;
                
                // Consider a gap > 6% as "too much"
                const TOO_MUCH_GAP = 4;
                const aIsTooMuch = aGap > TOO_MUCH_GAP;
                const bIsTooMuch = bGap > TOO_MUCH_GAP;

                // First priority: Not winning or winning with too much gap
                if ((!aIsWinning || aIsTooMuch) && (bIsWinning && !bIsTooMuch)) return -1;
                if ((aIsWinning && !aIsTooMuch) && (!bIsWinning || bIsTooMuch)) return 1;

                // Second priority: Sort by floor price for cards that need attention
                if (!aIsWinning || aIsTooMuch || !bIsWinning || bIsTooMuch) {
                    return (b.floorPrice || 0) - (a.floorPrice || 0);
                }

                return 0;
            });
        }
        
        renderBids();
    }
    
    document.getElementById('refresh-button').addEventListener('click', () => {
        document.getElementById('loading-indicator').style.display = 'block';
        document.getElementById('error-message').style.display = 'none';
        fetchBids();
    });
    
    function formatTimeUntilExpiration(expirationTime) {
        // Convert Unix timestamp (seconds) to JavaScript Date (milliseconds)
        const expirationDate = new Date(parseInt(expirationTime) * 1000);
        const now = new Date();
        const diffMs = expirationDate - now;
        const diffHours = diffMs / (1000 * 60 * 60);
        const diffDays = diffHours / 24;

        if (diffMs <= 0) return { text: 'Expired', color: '#ff4444' };
        
        let color;
        if (diffHours <= 6) {
            color = '#ff4444';
        } else if (diffHours < 24) {
            color = '#ffa500';
        } else if (diffDays >= 5) {
            color = '#44ff44';
        } else if (diffDays >= 3) {
            color = '#4444ff';
        } else {
            color = '#ffffff';
        }
        
        let text;
        if (diffDays >= 1) {
            text = `${Math.floor(diffDays)}d ${Math.floor(diffHours % 24)}h`;
        } else if (diffHours >= 1) {
            text = `${Math.floor(diffHours)}h`;
        } else {
            const diffMinutes = Math.max(0, Math.floor(diffMs / (1000 * 60)));
            text = `${diffMinutes}m`;
        }

        return { text, color };
    }

    function formatPrice(price) {
        return (parseInt(price) / 1000000000000000000).toFixed(5);
    }

    function getRarityName(rarityNumber) {
        switch(rarityNumber) {
            case 1: return 'legendary';
            case 2: return 'epic';
            case 3: return 'rare';
            case 4: return 'common';
            default: return 'unknown';
        }
    }

    function isBot(traderAddress) {
        if (!traderAddress) return false;
        return KNOWN_BOTS.some(bot => 
            bot.address.toLowerCase() === traderAddress.toLowerCase()
        );
    }

    // Initial fetch
    fetchBids();
    </script>
</body>
</html>

