<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player Listings</title>
    <link rel="stylesheet" href="../styles.css?v=8e4c2f">
    <link rel="icon" type="image/png" href="../icons/favicon.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        .card-image {
            width: 30px;  /* This makes the image 80% smaller than original */
            height: auto; /* Maintains aspect ratio */
            vertical-align: middle;
        }
        .hero-cell {
            text-align: left;
            min-width: 150px;
        }
        table td {
            padding: 8px;
        }
        .profile-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            min-width: 80px; /* Add a minimum width */
            width: 100%; /* Take up full width of parent */
        }
        .profile-pic {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            margin: 0 auto; /* Center horizontally */
            display: block; /* Make image a block element */
        }
        .seller-info {
            display: block;
            font-size: 0.8em;
            color: #777;
            margin-top: 2px;
            text-align: center;
            width: 100%; /* Take up full width of parent */
        }
        .section-divider {
            border-left: 1px solid #ddd;
            padding-left: 12px;
        }
        .floor-container {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            width: 100%;
            gap: 12px;
        }
        
        .floor-value {
            text-align: left;
            white-space: nowrap;
            flex-shrink: 0;  /* Prevents floor value from shrinking */
        }
        
        .price-diff {
            font-size: 0.8em;
            color: #777;
            margin-top: 2px;
        }
        
        .last-sale-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .last-sale-value {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .last-sale-time {
            font-size: 0.8em;
            color: #777;
        }

        .section-header {
            background-color: #2a2a2a;
            color: #aaa;
            padding: 8px;
            font-weight: bold;
            border-top: 1px solid #404040;
            border-bottom: 1px solid #404040;
        }
        .price-range {
            position: relative;
            height: 4px;
            background: #2a2a2a;
            border-radius: 2px;
            margin: 12px 0;
            width: 200px;
        }

        .price-range-fill {
            position: absolute;
            height: 100%;
            background: #333;
            border-radius: 2px;
        }

        .price-marker {
            position: absolute;
            width: 3px;
            height: 12px;
            transform: translateX(-50%);
            top: -4px;
        }

        .price-marker.floor {
            background: #48DA7E;
        }

        .price-marker.bid {
            background: #4A9EFF;
        }

        .price-marker.last {
            background: #7B61FF;  /* Sapphire color */
        }

        .range-values {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #777;
            margin-top: 4px;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
            color: #aaa;
            font-size: 0.9em;
            justify-content: flex-end;  /* Right align the legend items */
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-marker {
            width: 3px;
            height: 12px;
            display: inline-block;
        }
        
        .legend-marker.floor { background: #48DA7E; }
        .legend-marker.bid { background: #4A9EFF; }
        .legend-marker.last { background: #7B61FF; }

        .score-cell {
            text-align: left;  /* Changed from center to left */
            white-space: nowrap;
            padding: 8px;
        }

        .score-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: flex-start;  /* Changed from center to flex-start */
        }

        .score-value {
            display: block;
            font-size: 0.9em;
        }

        .rank-container {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            margin-right: 8px;
        }

        .rank-1 {
            background-color: #FFD700;  /* Gold */
            color: #000;
        }

        .rank-2 {
            background-color: #C0C0C0;  /* Silver */
            color: #000;
        }

        .rank-3 {
            background-color: #CD7F32;  /* Bronze */
            color: #fff;
        }

        .rank-other {
            background-color: #2d2d2d;
            color: #fff;
        }

        .rank-placeholder {
            visibility: hidden;
            width: 30px;  /* Adjust this value to match your rank container width */
            display: inline-block;
        }

        .listing-cell {
            text-align: right;  /* Changed from left to right */
            white-space: nowrap;
        }

        .listing-price {
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }

        .price-diff {
            display: block;
            text-align: right;  /* Ensure price diff is also right-aligned */
            font-size: 0.8em;
            color: #777;
            margin-top: 2px;
        }

        /* Filter container styles */
        .filter-container {
            width: 68%;
            margin: 0 auto 20px auto;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap;
            font-size: 80%; /* Reduce text size by 20% */
        }
        
        .search-box {
            flex: 0 0 auto; /* Change from flex: 1 to prevent expansion */
            width: 180px; /* Reduced width (was approximately 300px) */
            position: relative;
            background: #2a2a2a;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #333;
        }
        
        .search-box label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #fff;
            font-size: 80%; /* Reduce text size by 20% */
        }
        
        .search-input-container {
            position: relative;
            width: 100%;
            display: block;
        }
        
        #heroHandleSearch {
            width: 100%;
            box-sizing: border-box;
            padding: 8px 10px; /* Slightly smaller padding */
            padding-right: 35px;
            border: 1px solid #333;
            border-radius: 6px;
            font-size: 11px; /* Reduced from default (~14px) */
            background: #1a1a1a;
            color: #fff;
            transition: border-color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        #heroHandleSearch:focus {
            outline: none;
            border-color: #444;
        }
        
        .clear-search {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 3px; /* Reduced from 4px */
            display: none;
            font-size: 14px; /* Reduce to fit narrower box */
            transition: color 0.2s;
        }
        
        .clear-search:hover {
            color: #fff;
        }
        
        .clear-search.visible {
            display: block;
        }
        
        .autocomplete-results {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%; /* Use 100% of the container, which matches search box */
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 6px;
            margin-top: 4px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-sizing: border-box;
        }
        
        .autocomplete-item {
            padding: 4px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.2s;
            color: #fff;
            font-size: 12px;
        }
        
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        
        .autocomplete-item:hover {
            background-color: #3a3a3a;
        }
        
        .player-preview-pic {
            width: 21px;
            height: 21px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #444;
        }

        /* Add styles for the selected hero handle tag */
        .selected-player-tag {
            display: inline-flex;
            align-items: center;
            background: #333;
            color: #fff;
            padding: 4px 8px;
            border-radius: 20px;
            margin: 4px 0;
            font-size: 11px;
            position: relative;
            max-width: 90%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .selected-player-tag .remove-player {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #444;
            color: #fff;
            border: none;
            margin-left: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: background-color 0.2s;
            min-width: 16px;
            flex-shrink: 0;
        }

        .selected-player-tag .remove-player:hover {
            background: #555;
        }

        /* Hide the input when a player is selected */
        .search-input-container.has-selected-player #playerHandleSearch {
            display: none;
        }

        /* Show the selected player tag when a player is selected */
        .search-input-container.has-selected-player .selected-player-tag {
            display: inline-flex;
        }

        /* Hide the selected player tag when no player is selected */
        .selected-player-tag {
            display: none;
        }
    </style>
</head>
<body>
    <h1>Player Listings</h1>
        <div class="filter-container">
            <div class="search-box">
                <label for="playerSearch">Search by Player:</label>
                <div class="search-input-container">
                    <input type="text" id="playerHandleSearch" placeholder="Enter player..." autocomplete="off">
                    <button class="clear-search"></button>
                </div>
                <div id="autocompleteResults" class="autocomplete-results"></div>
            </div>
        </div>
    <div id="tableContainer"></div>

    <script>

        // Function to fetch all unique player handles with profile pictures
        async function fetchPlayers() {
            try {
                console.log('Executing query: Fetching unique players with profile pictures');
                const { data, error } = await supabaseClient
                    .from('vwplayer_listing_totals')
                    .select('player_name, player_handle, profile_picture, sell_orders, total_value')
                    .order('sell_orders', { ascending: false });  // Sort by sell_orders descending

                if (error) {
                    console.error('Error fetching players:', error);
                    return;
                }
                
                // Map and store the data in allPlayers 
                allPlayers = data
                    .map(item => ({
                        handle: item.player_handle,
                        pfp: item.profile_picture
                    }));
                
                console.log('Total unique players loaded:', allPlayers.length);
                console.log('First 10 players:', allPlayers.slice(0, 10));
                
                // If we have players, show the first 10 by default
                if (allPlayers.length > 0) {
                    showAutocompleteResults('');
                }
                
            } catch (error) {
                console.error('Unexpected error fetching players:', error);
            }
        }

        // Add Supabase client initialization at the top of your file
        const supabaseUrl = 'https://hhcuqhvmzwmehdsaamhn.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoY3VxaHZtendtZWhkc2FhbWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzIwMTIsImV4cCI6MjA1MDU0ODAxMn0.xJNGoFLnpnmQGLj8RY_4VLmefPmFzuOyiVHLvFtPkkE';
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);

        // Add this function near the top of your script section
        async function fetchSupabaseListingData() {
            try {
                const { data, error } = await supabaseClient
                    .from('listing_view')
                    .select(`
                        hero_id,
                        hero_handle,
                        rarity,
                        hero_rarity_index,
                        last_sale,
                        last_sale_time,
                        lowest_sale,
                        highest_sale,
                        score_24hr,
                        score_7d,
                        score_main,
                        trade_timeline,
                        bid_pct,
                        market_pct
                    `);

                if (error) {
                    console.error('Error fetching listing data:', error);
                    return null;
                }

                // Store the data in localStorage for later use
                localStorage.setItem('listingData', JSON.stringify(data));

                return data;
            } catch (error) {
                console.error('Error in fetchSupabaseListingData:', error);
                return null;
            }
        }

        // Add this function after the other fetch functions
        async function fetchPlayerData(addresses) {
            try {
                const { data, error } = await supabaseClient
                    .from('players')
                    .select('player_address,player_pfp_url,player_name')
                    .in('player_address', addresses);

                if (error) {
                    console.error('Error fetching player data:', error);
                    return null;
                }

                // Create a map for easy lookup
                const playerMap = new Map(
                    data.map(player => [player.player_address.toLowerCase(), player])
                );

                return playerMap;
            } catch (error) {
                console.error('Error in fetchPlayerData:', error);
                return null;
            }
        }

        async function fetchListingRank(hero_rarity_index) {
            try {
                const response = await fetch(`https://api-v2.fantasy.top/marketplace/sell-orders/${hero_rarity_index}?type=short`, {
                    headers: {
                        'accept': 'application/json',
                        'x-api-key': 'cbc57228-5495-47b0-ae2f-b43ba6d5a9b6'
                    }
                });
                const data = await response.json();
                
                // Sort orders by price and calculate dense rank
                if (data.orders && data.orders.length > 0) {
                    let currentRank = 1;
                    let currentPrice = data.orders[0].price;
                    let previousPrice = null;
                    
                    // Add rank property to each order
                    data.orders = data.orders.map((order, index) => {
                        if (previousPrice !== null && order.price !== previousPrice) {
                            currentRank = index + 1; // Skip ranks for ties
                        }
                        previousPrice = order.price;
                        return { ...order, dense_rank: currentRank };
                    });
                }
                
                return data.orders;
            } catch (error) {
                console.error('Error fetching listing rank:', error);
                return null;
            }
        }

        async function fetchListings() {
            try {
                // Fetch initial data
                const [apiResponse, supabaseData] = await Promise.all([
                    fetch('https://api-v2.fantasy.top/player/listings/0x162F95a9364c891028d255467F616902A479681a', {
                        headers: {
                            'accept': 'application/json',
                            'x-api-key': 'cbc57228-5495-47b0-ae2f-b43ba6d5a9b6'
                        }
                    }).then(res => res.json()),
                    fetchSupabaseListingData()
                ]);

                // Create map for Supabase data
                const supabaseMap = new Map(
                    supabaseData.map(item => [item.hero_rarity_index.toString(), item])
                );

                // Fetch rank data for each listing
                const rankPromises = apiResponse.map(listing => 
                    fetchListingRank(listing.hero_rarity_index)
                );
                const rankResults = await Promise.all(rankPromises);

                // Get unique top traders from rank results
                const topTraders = new Set(
                    rankResults
                        .flatMap(orders => {
                            console.log('Processing orders:', orders);
                            // Get the first order from each array (lowest price)
                            const firstOrder = orders?.[0];
                            console.log('First order:', firstOrder);
                            return firstOrder?.trader || [];
                        })
                        .filter(trader => trader)
                        .map(trader => trader.toLowerCase())
                );
                
                console.log('Top traders addresses:', Array.from(topTraders));

                // Fetch player data for top traders
                const playerData = await fetchPlayerData(Array.from(topTraders));
                console.log('Player data from Supabase:', Object.fromEntries(playerData || new Map()));

                // Log enriched listings for debugging
                const enrichedListings = apiResponse.map((listing, index) => {
                    const supabaseInfo = supabaseMap.get(listing.hero_rarity_index.toString());
                    const rankOrders = rankResults[index];
                    
                    // Find the order with matching token_id and get its dense_rank
                    const matchingOrder = rankOrders?.find(order => order.token_id === listing.token_id);
                    const rank = matchingOrder?.dense_rank || null;

                    // Get top trader info if available (get first order directly)
                    const topOrder = rankOrders?.[0];  // Changed this line
                    const topTraderAddress = topOrder?.trader?.toLowerCase();
                    const topTraderInfo = topTraderAddress ? playerData?.get(topTraderAddress) : null;
                    
                    console.log('Top trader info for listing:', {
                        address: topTraderAddress,
                        info: topTraderInfo,
                        orderDetails: topOrder // Add this to see full order details
                    });

                    return {
                        ...listing,
                        supabaseInfo: supabaseInfo || {},
                        rank: rank,
                        topTrader: topTraderInfo ? {
                            name: topTraderInfo.player_name,
                            pfpUrl: topTraderInfo.player_pfp_url
                        } : null
                    };
                });

                displayListings(enrichedListings);
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        function format_eth_tight(value) {
            if (value === null || value === undefined || isNaN(value)) return '-'; // Handle invalid values

            const num = parseFloat(value);
            if (num > 10) {
                return num.toFixed(0); // Format as ## for values greater than 10
            } else if (num > 1) {
                return num.toFixed(2); // Format as #.# for values greater than 1
            } else {
                return num.toFixed(3); // Format as #.## for values less than or equal to 1
            }
        }
        
        
        function format_eth(value) {
            if (value === null || value === undefined || isNaN(value)) return '-'; // Handle invalid values

            const num = parseFloat(value);
            if (num > 10) {
                return num.toFixed(2); // Format as ## for values greater than 10
            } else if (num > 1) {
                return num.toFixed(3); // Format as #.# for values greater than 1
            } else {
                return num.toFixed(5); // Format as #.## for values less than or equal to 1
            }
        }
        
        function getRarityName(rarityNumber) {
            switch(rarityNumber) {
                case 1: return 'legendary';
                case 2: return 'epic';
                case 3: return 'rare';
                case 4: return 'common';
                default: return 'unknown';
            }
        }

        function formatTimeUntilExpiration(expirationTime) {
            const now = Math.floor(Date.now() / 1000);
            const expTime = parseInt(expirationTime);
            const diffMinutes = Math.floor((expTime - now) / 60);
            
            if (diffMinutes <= 0) {
                return 'Expired';
            }
            
            if (diffMinutes <= 120) {  // 2 hours
                return `${diffMinutes}m`;
            } else if (diffMinutes <= 2880) {  // 48 hours
                const hours = Math.floor(diffMinutes / 60);
                return `${hours}h`;
            } else {
                const days = Math.floor(diffMinutes / 1440);
                return `${days}d`;
            }
        }

        function formatLastSaleTime(lastSaleTime) {
            if (!lastSaleTime) return '';
            
            const now = new Date();
            const saleTime = new Date(lastSaleTime);
            const diffMinutes = Math.floor((now - saleTime) / (1000 * 60));
            
            if (diffMinutes <= 120) {  // 2 hours
                return `${diffMinutes}m ago`;
            } else if (diffMinutes <= 2880) {  // 48 hours
                const hours = Math.floor(diffMinutes / 60);
                return `${hours}h ago`;
            } else {
                const days = Math.floor(diffMinutes / 1440);
                return `${days}d ago`;
            }
        }

        function calculatePosition(value, min, max) {
            if (!value || !min || !max) return 0;
            const position = ((parseFloat(value) - parseFloat(min)) / (parseFloat(max) - parseFloat(min))) * 100;
            return Math.min(Math.max(position, 0), 100); // Clamp between 0 and 100
        }

        function formatPricePercentage(percentage) {
            if (percentage >= 100) {
                return `${Math.round(percentage)}%`;  // ###%
            } else if (percentage >= 10) {
                return `${Math.round(percentage)}%`;  // ##%
            } else {
                return `${percentage.toFixed(2)}%`;   // #.##%
            }
        }

        function getPriceDiffColor(percentage) {
            if (percentage > 50) {
                return '#FF5733'; // Red for high difference
            } else if (percentage > 20) {
                return '#FFC300'; // Yellow for moderate difference
            } else {
                return '#48DA7E'; // Green for low difference
            }
        }

        // Add this function to your script section
        function getScoreColor(score) {
            // Handle invalid scores
            if (!score || score < 0) return '#777777';
            
            // Normalize score to 0-1 range
            const normalizedScore = Math.min(Math.max(score / 1000, 0), 1);
            
            // Define color stops for RYG (Red -> Yellow -> Green) gradient
            const colors = [
                { point: 0, color: [255, 50, 50] },    // Red
                { point: 0.5, color: [255, 255, 50] }, // Yellow
                { point: 1, color: [50, 255, 50] }     // Green
            ];
            
            // Find the two colors to interpolate between
            let lower = colors[0];
            let upper = colors[colors.length - 1];
            
            for (let i = 0; i < colors.length - 1; i++) {
                if (normalizedScore >= colors[i].point && normalizedScore <= colors[i + 1].point) {
                    lower = colors[i];
                    upper = colors[i + 1];
                    break;
                }
            }
            
            // Calculate interpolation factor
            const range = upper.point - lower.point;
            const factor = range === 0 ? 0 : (normalizedScore - lower.point) / range;
            
            // Interpolate RGB values
            const r = Math.round(lower.color[0] * (1 - factor) + upper.color[0] * factor);
            const g = Math.round(lower.color[1] * (1 - factor) + upper.color[1] * factor);
            const b = Math.round(lower.color[2] * (1 - factor) + upper.color[2] * factor);
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        function calculateTotalPrice(listings) {
            return listings.reduce((sum, listing) => sum + parseFloat(listing.price_numeric), 0);
        }

        // Add this function to create the line chart
        function createPriceChart(tradeData) {
            if (!tradeData) return '';
            
            const width = 200;
            const height = 40;
            const padding = 4;
            
            // Handle both string and object inputs
            const sortedData = (typeof tradeData === 'string' ? JSON.parse(tradeData) : tradeData)
                .sort((a, b) => new Date(a.date_hour) - new Date(b.date_hour));
            
            if (!sortedData.length) return '';
            
            const now = new Date();
            const timeRange = {
                max: new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours())),
                min: new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() - 14, now.getUTCHours()))
            };
            
            const priceRange = {
                min: Math.min(...sortedData.map(d => d.avg_price)),
                max: Math.max(...sortedData.map(d => d.avg_price))
            };

            // Scale functions remain the same
            const scaleX = (date) => {
                const percent = (new Date(date) - timeRange.min) / (timeRange.max - timeRange.min);
                return padding + percent * (width - 2 * padding);
            };
            
            const scaleY = (price) => {
                const percent = (price - priceRange.min) / (priceRange.max - priceRange.min);
                return height - padding - percent * (height - 2 * padding);
            };

            // Create points with trend information
            const points = [];
            const windowSize = 5; // Increased from 3 to 5 points
            const minChangeThreshold = 0.005; // 0.5% minimum change to show trend
            
            sortedData.forEach((d, i) => {
                const point = {
                    x: scaleX(d.date_hour),
                    y: scaleY(d.avg_price),
                    price: d.avg_price,
                    date: new Date(d.date_hour).toLocaleDateString(),
                    time: new Date(d.date_hour).toLocaleTimeString(),
                    priceFormatted: format_eth(d.avg_price)
                };

                // Calculate trend with minimum threshold
                if (i >= windowSize - 1) {
                    const window = sortedData.slice(i - windowSize + 1, i + 1);
                    const firstPrice = window[0].avg_price;
                    const lastPrice = window[window.length - 1].avg_price;
                    const priceChange = (lastPrice - firstPrice) / firstPrice;
                    
                    if (Math.abs(priceChange) >= minChangeThreshold) {
                        point.trend = priceChange > 0 ? 'up' : 'down';
                    } else {
                        point.trend = 'neutral';
                    }
                } else {
                    point.trend = 'neutral';
                }

                points.push(point);
            });

            // Create SVG path segments with different colors
            const segments = points.map((point, i) => {
                if (i === 0) return '';
                
                const prevPoint = points[i - 1];
                const color = point.trend === 'up' ? '#4ADE80' : 
                             point.trend === 'down' ? '#EF4444' : 
                             '#404040'; // Changed neutral color to a darker grey

                return `
                    <line 
                        x1="${prevPoint.x}" 
                        y1="${prevPoint.y}" 
                        x2="${point.x}" 
                        y2="${point.y}"
                        stroke="${color}"
                        stroke-width="1.5"
                    />
                `;
            });

            return `
                <svg width="${width}" height="${height}" style="background: #2a2a2a; border-radius: 2px;">
                    ${segments.join('')}
                    ${points.map(p => `
                        <circle 
                            cx="${p.x}" 
                            cy="${p.y}" 
                            r="3" 
                            fill="transparent"
                            stroke="transparent"
                            style="cursor: pointer;"
                        >
                            <title>${p.date} ${p.time}
Price: ${p.priceFormatted} ETH</title>
                        </circle>
                    `).join('')}
                </svg>
            `;
        }

        // Add this function to create the donut chart
        function createDonutChart(bid_pct, market_pct) {
            // Convert decimal values to percentages and ensure they're numbers
            bid_pct = Math.round((Number(bid_pct) || 0) * 100);
            market_pct = Math.round((Number(market_pct) || 0) * 100);
            
            // Check if we have any data to show
            if (bid_pct === 0 && market_pct === 0) return '';
            
            const size = 40;
            const strokeWidth = 4;
            const radius = (size - strokeWidth) / 2;
            const center = size / 2;
            
            // Calculate angles
            const total = bid_pct + market_pct;
            if (total === 0) return '';
            
            const bidAngle = (bid_pct / total) * 360;
            const marketAngle = (market_pct / total) * 360;
            
            const circumference = 2 * Math.PI * radius;
            const bidDash = (bidAngle / 360) * circumference;
            const marketDash = (marketAngle / 360) * circumference;

            const bidColor = "#4A9EFF";    // Blue
            const marketColor = "#FF00FF";  // Magenta

            // Determine highest percentage and its color
            const highestPct = Math.max(bid_pct, market_pct);
            const highestColor = bid_pct >= market_pct ? bidColor : marketColor;
            const dominantType = bid_pct >= market_pct ? 'B' : 'M';

            return `
                <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="margin-left: 8px;">
                    ${bid_pct > 0 ? `
                        <circle 
                            cx="${center}" 
                            cy="${center}" 
                            r="${radius}"
                            fill="none"
                            stroke="${bidColor}"
                            stroke-width="${strokeWidth}"
                            stroke-dasharray="${bidDash} ${circumference}"
                            transform="rotate(-90, ${center}, ${center})"
                        />
                    ` : ''}
                    ${market_pct > 0 ? `
                        <circle 
                            cx="${center}" 
                            cy="${center}" 
                            r="${radius}"
                            fill="none"
                            stroke="${marketColor}"
                            stroke-width="${strokeWidth}"
                            stroke-dasharray="${marketDash} ${circumference}"
                            transform="rotate(${bidAngle - 90}, ${center}, ${center})"
                        />
                    ` : ''}
                    <text 
                        x="${center}" 
                        y="${center - 3}" 
                        text-anchor="middle" 
                        dominant-baseline="middle" 
                        fill="${highestColor}"
                        style="font-size: 12px; font-weight: bold;"
                    >${highestPct}</text>
                    <text 
                        x="${center}" 
                        y="${center + 8}" 
                        text-anchor="middle" 
                        dominant-baseline="middle" 
                        fill="${highestColor}"
                        style="font-size: 10px; font-weight: bold;"
                    >${dominantType}</text>
                </svg>
            `;
        }

        // Function to display autocomplete results
        function showAutocompleteResults(inputValue) {
            const resultsContainer = document.getElementById('autocompleteResults');
            resultsContainer.innerHTML = '';
            
            // Check if we have players loaded
            if (!allPlayers || allPlayers.length === 0) {
                console.warn('No players available for autocomplete');
                return;
            }
            
            let matchingPlayers;
            if (!inputValue || inputValue.trim() === '') {
                // Show all players if no input
                matchingPlayers = allPlayers.slice(0, 10); // Only show first 10 by default
                console.log('Showing first 10 players:', matchingPlayers);
            } else {
                // Filter players based on input
                matchingPlayers = allPlayers.filter(item => 
                    item.handle.toLowerCase().includes(inputValue.toLowerCase())
                );
            }
            
            // Display matching players
            resultsContainer.innerHTML = matchingPlayers.map(player => `
                <div class="autocomplete-item">
                    <img class="player-pfp" src="${player.pfp || '../icons/ft_logo.webp'}" alt="Profile">
                    <span>${player.handle}</span>
                </div>
            `).join('');
            
            resultsContainer.style.display = matchingPlayers.length ? 'block' : 'none';

            displayPlayerHandle(matchingPlayers);
        }

        function displayPlayerHandle(players) {
            const resultsContainer = document.getElementById('autocompleteResults');
            
            if (players.length === 0) {
                resultsContainer.style.display = 'none';
                return;
            }
            
            // Clear previous results
            resultsContainer.innerHTML = '';
            
            players.forEach(item => {
                const div = document.createElement('div');
                div.className = 'autocomplete-item';
                
                const img = document.createElement('img');
                img.src = item.pfp || '/icons/ft_logo.webp';
                img.alt = item.handle;
                img.className = 'player-preview-pic';
                img.onerror = function() {
                    this.src = '/icons/ft_logo.webp';
                };
                
                const span = document.createElement('span');
                span.textContent = item.handle;
                
                div.appendChild(img);
                div.appendChild(span);
                
                div.addEventListener('click', () => {
                    selectPlayerHandle(item.handle);
                });
                
                resultsContainer.appendChild(div);
            });
            
            resultsContainer.style.display = 'block';
            console.log('Displayed players count:', players.length);
        }

        function selectPlayerHandle(playerHandle) {
            const searchInput = document.getElementById('playerHandleSearch');
            const searchContainer = searchInput.parentNode;
            
            // Create or update the selected hero tag
            let playerTag = searchContainer.querySelector('.selected-player-tag');
            if (!playerTag) {
                playerTag = document.createElement('div');
                playerTag.className = 'selected-player-tag';
                searchContainer.insertBefore(playerTag, searchInput);
            }
            
            playerTag.innerHTML = `
                ${handle}
                <button class="remove-player" title="Remove player">×</button>
            `;
            
            // Add click handler to remove button
            playerTag.querySelector('.remove-player').addEventListener('click', () => {
                removeplayerandle();
            });
            
            // Update container state
            searchContainer.classList.add('has-selected-player');
            
            // Hide autocomplete results
            document.getElementById('autocompleteResults').style.display = 'none';
            
            // Update current filter and fetch data
            currentFilter = handle;
            fetchAndDisplayCardHolders(handle);
        }

        function removePlayerHandle() {
            const searchInput = document.getElementById('playerHandleSearch');
            const searchContainer = searchInput.parentNode;
            const playerTag = searchContainer.querySelector('.selected-player-tag');
            
            if (playerTag) {
                playerTag.remove();
                searchContainer.classList.remove('has-selected-player');
                currentFilter = null;
                // Clear the table without making a query
                const tableBody = document.getElementById('tableBody');
                tableBody.innerHTML = '';
                currentData = [];
            }
        }


        function calculateTradesPerDay(tradeData) {
            if (!tradeData) return 0;
            
            // Parse data if it's a string
            const data = typeof tradeData === 'string' ? JSON.parse(tradeData) : tradeData;
            
            // Sum all transactions
            const totalTrades = data.reduce((sum, d) => sum + d.txn, 0);
            
            // Calculate daily average (divide by 14 days)
            return (totalTrades / 14).toFixed(1);
        }

        function displayListings(listings) {
            const ethIcon = `<svg width="16" height="16" viewBox="0 0 256 417" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid" style="vertical-align: middle;">
                <path fill="#8A92B2" d="M127.961 0l-2.795 9.5v275.668l2.795 2.79 127.962-75.638z"></path>
                <path fill="#62688F" d="M127.962 0L0 212.32l127.962 75.639V154.158z"></path>
                <path fill="#454A75" d="M127.961 312.187l-1.575 1.92v98.199l1.575 4.6L256 236.587z"></path>
                <path fill="#62688F" d="M127.962 416.905v-104.72L0 236.585z"></path>
                <path fill="#8A92B2" d="M127.961 287.958l127.96-75.637-127.96-58.162z"></path>
                <path fill="#62688F" d="M0 212.32l127.96 75.638v-133.8z"></path>
            </svg>`;

            // Update the legend
            const legend = `
                <div class="legend">
                    <div class="legend-item">
                        <svg width="20" height="2">
                            <line x1="0" y1="1" x2="20" y2="1" stroke="#4A9EFF" stroke-width="2"/>
                        </svg>
                        <span>Bid</span>
                    </div>
                    <div class="legend-item">
                        <svg width="20" height="2">
                            <line x1="0" y1="1" x2="20" y2="1" stroke="#FF00FF" stroke-width="2"/>
                        </svg>
                        <span>Market</span>
                    </div>
                </div>
            `;

            // Split listings into floor and non-floor prices
            const floorListings = listings.filter(listing => 
                parseFloat(listing.price_numeric) <= parseFloat(listing.floor_price)
            );
            const otherListings = listings.filter(listing => 
                parseFloat(listing.price_numeric) > parseFloat(listing.floor_price)
            );

            const createTableRows = (listings) => listings.map(listing => `
                <tr>
                    <td>
                        <img 
                            class="card-image" 
                            src="https://r2.fantasy.top/v2/${getRarityName(listing.rarity)}/${listing.hero_id}_${listing.heroes.stars}.png" 
                            alt="Hero Card"
                            onerror="this.src='../icons/ft_logo.webp'"
                        >
                    </td>
                    <td class="hero-cell">
                        ${listing.heroes.name}
                        <a href="https://x.com/${listing.heroes.handle}" target="_blank" style="margin-left: 4px; text-decoration: none;">
                            <i class="fa-brands fa-x-twitter" style="font-size: 0.8em; color: #777;"></i>
                        </a>
                    </td>
                    <td class="score-cell">
                        <div class="score-container">
                            <span class="score-value score-24h" title="24 hour score">
                                <span style="color: ${getScoreColor(listing.supabaseInfo.score_24hr)}">
                                    24h: ${listing.supabaseInfo.score_24hr ? Math.round(listing.supabaseInfo.score_24hr) : '-'}
                                </span>
                            </span>
                            <span class="score-value score-7d" title="7 day score">
                                <span style="color: ${getScoreColor(listing.supabaseInfo.score_7d)}">
                                    7d: ${listing.supabaseInfo.score_7d ? Math.round(listing.supabaseInfo.score_7d) : '-'}
                                </span>
                            </span>
                            <span class="score-value score-main" title="Main score">
                                <span style="color: ${getScoreColor(listing.supabaseInfo.score_main)}">
                                    Main: ${listing.supabaseInfo.score_main ? Math.round(listing.supabaseInfo.score_main) : '-'}
                                </span>
                            </span>                      
                        </div>
                    </td>
                    <td>${formatTimeUntilExpiration(listing.expiration_time)}</td>
                    <td class="listing-cell">
                        <span class="rank-container ${listing.rank ? (
                            listing.rank === 1 ? 'rank-1' : 
                            listing.rank === 2 ? 'rank-2' : 
                            listing.rank === 3 ? 'rank-3' : 
                            'rank-other'
                        ) : 'rank-placeholder'}">${listing.rank ? `#${listing.rank}` : ''}</span>
                        <span class="listing-price">
                            <span style="color: ${parseFloat(listing.price_numeric) === parseFloat(listing.floor_price) ? '#4ADE80' : 'inherit'}">${format_eth(listing.price_numeric)}</span>${ethIcon}
                        </span>
                    </td>
                    <td class="section-divider">
                        <div class="floor-container">
                            <div class="floor-value">
                                ${format_eth(listing.floor_price)} ${ethIcon}
                            </div>
                            <div class="profile-container">
                                ${listing.topTrader ? `
                                    <img 
                                        class="profile-pic" 
                                        src="${listing.topTrader.pfpUrl}" 
                                        alt="Profile"
                                        onerror="this.src='../icons/ft_logo.webp'"
                                    >
                                    <span class="seller-info">
                                        ${listing.topTrader.name ? 
                                            (listing.topTrader.name.length > 12 ? 
                                            listing.topTrader.name.substring(0, 12) + '...' : 
                                            listing.topTrader.name) 
                                            : ''}
                                    </span>
                                ` : ''}
                            </div>
                        </div>
                    </td>
                    <td class="section-divider">
                        <div class="last-sale-container">
                            ${listing.supabaseInfo.last_sale ? `
                                <div class="last-sale-value">
                                    ${format_eth(listing.supabaseInfo.last_sale)} ${ethIcon}
                                </div>
                                <div class="last-sale-time" title="${new Date(listing.supabaseInfo.last_sale_time).toUTCString()}">
                                    ${formatLastSaleTime(listing.supabaseInfo.last_sale_time)}
                                </div>
                            ` : '-'}
                        </div>
                    </td>
                    <td class="section-divider">
                        ${listing.supabaseInfo.trade_timeline ? createPriceChart(listing.supabaseInfo.trade_timeline) : ''}
                        <div style="display: inline-block; margin: 0 8px; font-size: 11px; color: #777;">
                            <span style="font-weight: bold; color: #aaa; display: block;">${
                                typeof listing.supabaseInfo.trade_timeline === 'string' 
                                    ? JSON.parse(listing.supabaseInfo.trade_timeline).reduce((sum, d) => sum + d.txn, 0)
                                    : listing.supabaseInfo.trade_timeline?.reduce((sum, d) => sum + d.txn, 0) || 0
                            }</span>
                            <span style="font-weight: bold; color: #aaa;">${calculateTradesPerDay(listing.supabaseInfo.trade_timeline)}</span>/d
                        </div>
                        ${createDonutChart(
                            listing.supabaseInfo.bid_pct || 0, 
                            listing.supabaseInfo.market_pct || 0
                        )}
                    </td>
                </tr>
            `).join('');

            const table = `
                ${legend}
                <table>
                    <thead>
                        <tr>
                            <th>Card</th>
                            <th class="hero-cell"></th>
                            <th class="score-cell" title="Performance Score 24h/7d">Score</th>
                            <th>Time Left</th>
                            <th>Price</th>
                            <th class="section-divider">Floor</th>
                            <th class="section-divider">Last Sale</th>  <!-- Add this line -->
                            <th class="section-divider">Price Range L14D</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${floorListings.length > 0 ? `
                            <tr>
                                <td colspan="8" class="section-header">
                                    My Floor Price Listings (${floorListings.length}) - Total: ${format_eth(calculateTotalPrice(floorListings))} ${ethIcon}
                                </td>
                            </tr>
                            ${createTableRows(floorListings)}
                        ` : ''}
                        ${otherListings.length > 0 ? `
                            <tr>
                                <td colspan="8" class="section-header" style="margin-top: 20px;">
                                    Other Listings (${otherListings.length}) - Total: ${format_eth(calculateTotalPrice(otherListings))} ${ethIcon}
                                </td>
                            </tr>
                            ${createTableRows(otherListings)}
                        ` : ''}
                    </tbody>
                </table>
            `;
            
            document.getElementById('tableContainer').innerHTML = table;
        }

        // Fetch data when page loads
        document.addEventListener('DOMContentLoaded', () => {
            fetchListings();
            fetchPlayers();
        });
    </script>
</body>
</html>