<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXJ5Q7LKKE"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LXJ5Q7LKKE');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hero Trades</title>
    <link rel="icon" type="image/png" href="icons/favicon.webp">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" as="style">
    <link rel="stylesheet" href="./styles.css">
    <script src="/js/tradeChart.js?v=1.0.4"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: row;
            gap: 12px;
            padding: 20px 32px;
            width: 100%;
            box-sizing: border-box;
            flex-wrap: nowrap;
            overflow-x: hidden;
        }

        #trades {
            visibility: visible;
            opacity: 1;
            flex: 1;
            max-width: 50vw;
            min-width: 600px;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 16px;
            box-sizing: border-box;
            position: relative;
            left: auto;
            top: auto;
        }

        #trades.visible {
            visibility: visible;
            opacity: 1;
        }

        #trade-chart {
            width: 100%;
            margin-bottom: 20px;
        }

        #trade-details {
            width: 100%;
            overflow-x: auto;
        }

        /* Add these styles for better column control */
        #heroesTable th,
        #heroesTable td {
            text-align: left;
            padding: 8px;
        }

        /* Set specific widths for each column */
        #heroesTable th:nth-child(1),
        #heroesTable td:nth-child(1) {
            width: 25%;  /* Hero column */
        }

        #heroesTable th:nth-child(2),
        #heroesTable td:nth-child(2),
        #heroesTable th:nth-child(3),
        #heroesTable td:nth-child(3) {
            width: 10%;  /* Star columns */
        }

        #heroesTable th:nth-child(4),
        #heroesTable td:nth-child(4),
        #heroesTable th:nth-child(5),
        #heroesTable td:nth-child(5),
        #heroesTable th:nth-child(6),
        #heroesTable td:nth-child(6) {
            width: 15%;  /* Score columns */
        }

        #heroesTable th:nth-child(7),
        #heroesTable td:nth-child(7) {
            width: 10%;  /* Chart button column */
            text-align: center;
        }

        /* Add this new style for price column alignment */
        #tradesTable td:nth-child(7) {
            text-align: right;
        }

        /* Style for the chart button */
        .chart-button {
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            border: 1px solid #ccc;
        }

        .chart-button:hover {
            background: #f0f0f0;
        }

        .filter-icon {
            cursor: pointer;
        }
        
        .filter-icon:hover {
            color: #80bdff;
        }

        /* Add these new styles */
        .filter-popup {
            position: absolute;
            background: var(--background-color, #1a1a1a);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
            color: #fff;
        }

        .filter-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            cursor: pointer;
        }

        .filter-option:hover {
            background: rgba(255,255,255,0.1);
        }

        .filter-option input[type="checkbox"] {
            margin: 0;
        }

        .filter-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #eee;
        }

        .filter-actions button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #2a2a2a;
            color: #fff;
            transition: background 0.2s;
        }

        .filter-actions button:hover {
            background: #3a3a3a;
        }

        .filter-actions button.apply {
            background: #3b82f6;
        }

        .filter-actions button.apply:hover {
            background: #2563eb;
        }

        .price-range {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 8px;
        }

        .price-range input {
            padding: 6px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            width: 120px;
        }

        .price-range input::placeholder {
            color: #666;
        }

        .price-range input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .price-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .price-input-group label {
            min-width: 40px;
            color: #fff;
        }

        .price-input-group input {
            padding: 6px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            width: 120px;
        }

        /* Add these new styles for the active filter state */
        .filter-icon.active {
            color: #3b82f6;  /* Same blue as hover */
        }

        .filter-icon:hover {
            color: #3b82f6;
        }

        /* Update the price input styling */
        .price-input-group input {
            padding: 6px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            width: 120px;
        }

        .price-input-group input::-webkit-inner-spin-button,
        .price-input-group input::-webkit-outer-spin-button {
            opacity: 1;
            background: #2a2a2a;
        }

        #tradesTable tr.buyer-match,
        #tradesTable tr.buyer-match td {
            background-color: rgba(34, 197, 94, 0.1) !important;
        }
        #tradesTable tr.seller-match,
        #tradesTable tr.seller-match td {
            background-color: rgba(239, 68, 68, 0.1) !important;
        }

        #heroSelect {
            background: var(--background-color, #1a1a1a);
            color: #fff;
            border: 1px solid #333;
            min-width: 200px;
        }

        #heroSelect option {
            background: var(--background-color, #1a1a1a);
            color: #fff;
        }

        /* Add these new styles */
        #heroSelectContainer {
            position: fixed;
            top: 20px;
            left: 32px;
            z-index: 1000;
            background: var(--background-color, #1a1a1a);
            padding: 8px;
            border-radius: 4px;
        }

        /* Adjust body padding to account for fixed header */
        body {
            padding-top: 80px;
            padding-left: 32px;
            padding-right: 32px;
            padding-bottom: 20px;
        }

        /* Add these new styles */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            margin: 16px 0;  /* Equal spacing top and bottom */
        }

        .toggle-switch {
            position: relative;
            width: 200px;
            height: 34px;
            background: #2a2a2a;
            border-radius: 17px;
            padding: 4px;
            cursor: pointer;
            transition: 0.3s;
        }

        .toggle-slider {
            position: absolute;
            width: 96px;
            height: 26px;
            border-radius: 13px;
            transition: 0.3s ease-in-out;
            background: var(--slider-color, #48EE4B);  /* Default to common color */
        }

        .toggle-switch[data-state="rare"] .toggle-slider {
            transform: translateX(96px);
            background: var(--slider-color-rare, #02E0F4);  /* Rare color */
        }

        .toggle-options {
            position: relative;
            display: flex;
            justify-content: space-between;
            z-index: 1;
        }

        .toggle-option {
            flex: 1;
            text-align: center;
            padding: 4px;
            z-index: 2;
            user-select: none;
            transition: 0.3s;
        }

        /* Center the trade chart and details vertically */
        #trades {
            display: flex;
            flex-direction: column;
            gap: 16px;  /* Consistent spacing between elements */
        }

        #trade-chart {
            margin: 0;  /* Remove default margins */
        }

        /* Add these new styles */
        .hero-select-btn {
            background: var(--background-color, #1a1a1a);
            color: #fff;
            border: 1px solid #333;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
        }

        .hero-select-btn:hover {
            background: #2a2a2a;
        }

        .hero-selector-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--background-color, #1a1a1a);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 24px;
            z-index: 1001;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            gap: 24px;
        }

        .search-container {
            position: relative;
            width: 300px;
            display: flex;
            align-items: center;
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            pointer-events: none;
            z-index: 1;
        }

        #heroSearch {
            width: 100%;
            padding: 10px 12px 10px 36px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #2a2a2a;
            color: #fff;
            font-size: 16px;
        }

        #heroSearch:focus {
            outline: none;
            border-color: #3b82f6;
        }

        #heroSearch::placeholder {
            color: #666;
        }

        .close-popup {
            background: transparent;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 20px;
            padding: 4px;
        }

        .close-popup:hover {
            color: #fff;
        }

        .stars-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, 200px);  /* Changed from auto-fit to auto-fill */
            gap: 24px;
            justify-content: center;
            width: 100%;  /* Ensure grid takes full width */
            margin: 0 auto;  /* Center the grid */
        }

        .star-column {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: fit-content;  /* Allow column to fit card width */
            min-width: 200px;  /* Match hero-card width */
        }

        .star-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
            color: #ffd700;
        }

        .hero-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            font-size: 0.7em;
            width: 200px;  /* Reduced fixed width */
            min-width: 200px;
            max-width: 200px;
            box-sizing: border-box;
        }

        .hero-card:hover {
            transform: translateY(-2px);
            background: #333;
        }

        .hero-image {
            width: 29px;
            height: 38px;
            border-radius: 6px;
            object-fit: cover;
            margin-right: 2px;
        }

        .hero-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
            overflow: hidden;
        }

        .hero-scores {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: flex-end;
            min-width: 80px;
            flex-shrink: 0;
        }

        .score-value {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.85em;
            min-width: 24px;
            text-align: center;
            color: white;
            background-color: #3b82f6;  /* Add this line for default blue background */
        }

        .score-label {
            color: #666;
            margin-right: 4px;
            font-size: 0.85em;
            white-space: nowrap;
        }

        .floor-price {
            color: #22c55e;
            font-size: 0.85em;
            display: flex;
            align-items: center;
        }

        .hero-handle {
            color: #fff;
            margin-bottom: 2px;
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .fantasy-score {
            display: inline-block;
            background: #3b82f6;
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.85em;
            margin-right: 4px;
        }

        .score-label {
            color: #fff;
            margin-right: 2px;
        }

        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .price-filter-container {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #333;
            flex-wrap: wrap;
        }

        .price-filter-container > *:not(:first-child) {
            margin-left: 18px;
        }

        .price-filter-container label {
            color: #fff;
            font-weight: 500;
            white-space: nowrap;
            margin-right: 4px;
        }

        .price-inputs {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            margin-left: 0;
        }

        .price-inputs input {
            width: 60px;
            padding: 2px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
        }

        .price-inputs span {
            color: #666;
        }

        .price-inputs input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* Update these score styles */
        .score-value {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.85em;
            min-width: 24px;
            text-align: center;
            color: white;
            background-color: #3b82f6;  /* Add this line for default blue background */
        }

        /* Add specific background colors for each score type */
        .seven-day-score .score-value {
            background-color: #3b82f6;  /* Blue for 7-day score */
        }

        .last-main-score .score-value {
            background-color: #8b5cf6;  /* Purple for last main score */
        }

        .score-per-eth {
            font-size: 0.85em;
            color: #666;
        }

        .score-per-eth span {
            color: #fff;
        }


        /* Update star column to handle fixed-width cards */
        .star-column {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: fit-content;  /* Allow column to fit card width */
            min-width: 200px;  /* Match hero-card width */
        }

        /* Add these new styles */
        .star-column.wide {
            min-width: 424px;  /* 200px * 2 + 24px gap */
        }

        .star-column.wide .hero-cards-container {
            display: grid;
            grid-template-columns: repeat(2, 200px);
            gap: 24px;
        }

        /* Ensure the grid doesn't force different widths */
        .stars-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, 200px);  /* Changed from auto-fit to auto-fill */
            gap: 24px;
            justify-content: center;
            width: 100%;  /* Ensure grid takes full width */
            margin: 0 auto;  /* Center the grid */
        }

        .stars-grid.wide-columns {
            grid-template-columns: repeat(auto-fill, 424px);
        }

        /* Add these new styles for superwide columns */
        .star-column.superwide {
            min-width: 848px;  /* 200px * 4 + (24px * 3 gaps) */
        }

        .star-column.superwide .hero-cards-container {
            display: grid;
            grid-template-columns: repeat(4, 200px);
            gap: 24px;
        }

        .stars-grid.superwide-columns {
            grid-template-columns: repeat(auto-fill, 848px);
        }

                
        .star-filter {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .star-buttons {
            display: flex;
            gap: 8px;
        }

        .star-btn {
            background: transparent;
            border: 1px solid #333;
            color: #666;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }  

        .star-btn:hover {
            border-color: #ffd700;
            color: #ffd700;
        }

        .star-btn.active {
            border-color: #ffd700;
            color: #ffd700;  /* Keep text/emoji gold */
            background: transparent;  /* Ensure background remains transparent */
        }

        .sort-arrows {
            cursor: pointer;
            margin-right: 4px;
            display: inline-flex;
            flex-direction: column;
            vertical-align: middle;
            height: 16px;  /* Fixed height to match text */
            position: relative;
            top: -1px;  /* Fine-tune vertical alignment */
        }

        .sort-arrows i {
            display: block;
            height: 8px;
            color: #666;
            transition: color 0.2s;
            line-height: 8px;
        }

        .sort-arrows .fa-sort-up {
            margin-bottom: -4px;  /* Adjusted for better spacing */
        }

        /* Add specific color states */
        .sort-arrows.asc .fa-sort-up {
            color: #22c55e;  /* Green for ascending */
        }

        .sort-arrows.desc .fa-sort-down {
            color: #ef4444;  /* Red for descending */
        }

        /* Add default descending state styling */
        .sort-arrows.default .fa-sort-down {
            color: #ef4444;  /* Red for descending */
        }

        /* Add these new styles */
        .value-filter {
            margin-left: 24px;
        }

        .value-btn {
            color: #666;  /* Matches star-btn color */
        }

        .value-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
        }

        .value-btn.active {
            border-color: #3b82f6;
            color: #3b82f6;
        }
    </style>
</head>
<body>
    <div id="heroSelectContainer">
        <button id="heroSelectButton" class="hero-select-btn">
            Select a Hero <i class="fas fa-chevron-down"></i>
        </button>
    </div>

    <div id="heroSelectorPopup" class="hero-selector-popup">
        <div class="popup-header">
            <div class="search-container">
                <i class="fas fa-search search-icon"></i>
                <input type="text" id="heroSearch" placeholder="Search heroes...">
            </div>
            <div class="star-filter">
                <div class="star-buttons">
                    <button class="star-btn" data-stars="all">All</button>
                    <button class="star-btn" data-stars="8">8⭐</button>
                    <button class="star-btn" data-stars="7">7⭐</button>
                    <button class="star-btn" data-stars="6">6⭐</button>
                    <button class="star-btn" data-stars="5">5⭐</button>
                    <button class="star-btn" data-stars="4">4⭐</button>
                    <button class="star-btn" data-stars="3">3⭐</button>
                    <button class="star-btn" data-stars="2">2⭐</button>
                    <button class="star-btn" data-stars="1">1⭐</button>
                </div>
            </div>
            <div class="value-filter">
                <button class="star-btn value-btn" onclick="toggleBestValue()">Best Value 💎</button>
            </div>
            <button class="close-popup"><i class="fas fa-times"></i></button>
        </div>
        <div class="price-filter-container">
            <label>
                <span class="sort-arrows" data-sort="price">
                    <i class="fas fa-sort-up"></i>
                    <i class="fas fa-sort-down"></i>
                </span>
                Price:
            </label>
            <div class="price-inputs">
                <input type="number" id="popupMinPrice" placeholder="Min" step="0.0001">
                <span>to</span>
                <input type="number" id="popupMaxPrice" placeholder="Max" step="0.0001">
            </div>
            <label>
                <span class="sort-arrows" data-sort="7d">
                    <i class="fas fa-sort-up"></i>
                    <i class="fas fa-sort-down"></i>
                </span>
                7D Score:
            </label>
            <div class="price-inputs">
                <input type="number" id="popupMin7DScore" placeholder="Min" step="1" value="0">
                <span>to</span>
                <input type="number" id="popupMax7DScore" placeholder="Max" step="1" value="1000">
            </div>
            <label>
                <span class="sort-arrows" data-sort="lm">
                    <i class="fas fa-sort-up"></i>
                    <i class="fas fa-sort-down"></i>
                </span>
                LM Score:
            </label>
            <div class="price-inputs">
                <input type="number" id="popupMinLMScore" placeholder="Min" step="1" value="0">
                <span>to</span>
                <input type="number" id="popupMaxLMScore" placeholder="Max" step="1" value="1000">
            </div>
            <label>
                <span class="sort-arrows" data-sort="l3m">
                    <i class="fas fa-sort-up"></i>
                    <i class="fas fa-sort-down"></i>
                </span>
                L3M Score:
            </label>
            <div class="price-inputs">
                <input type="number" id="popupMinL3MScore" placeholder="Min" step="1" value="0">
                <span>to</span>
                <input type="number" id="popupMaxL3MScore" placeholder="Max" step="1" value="1000">
            </div>
        </div>
        <div class="stars-grid"></div>
    </div>

    <div id="trades">
        <div class="toggle-switch-container">
            <div class="toggle-switch" data-state="common">
                <div class="toggle-slider"></div>
                <div class="toggle-options">
                    <div class="toggle-option">Common</div>
                    <div class="toggle-option">Rare</div>
                </div>
            </div>
        </div>
        <div id="trade-chart" style="height: 400px; width: 100%;">
            <canvas id="tradesCanvas"></canvas>
        </div>
        <div id="trade-details">
            <table id="tradesTable">
                <thead>
                    <tr>
                        <th>Hero</th>
                        <th>Rarity</th>
                        <th>Time Ago</th>
                        <th>Buyer</th>
                        <th>Seller</th>
                        <th>Price <i class="fa-solid fa-filter filter-icon" style="font-size: 0.8em; margin-left: 4px;"></i></th>
                        <th>Change</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Trade data will be populated here -->
                </tbody>
            </table>
        </div>
    </div>

    <div id="rarityFilter" class="filter-popup">
        <div class="filter-options">
            <!-- Options will be populated dynamically -->
        </div>
        <div class="filter-actions">
            <button class="clear">Clear</button>
            <button class="apply">Apply</button>
        </div>
    </div>

    <div id="priceFilter" class="filter-popup">
        <div class="filter-options">
            <div class="price-range">
                <div class="price-input-group">
                    <label for="minPrice">Min:</label>
                    <input type="number" id="minPrice" placeholder="Min Price" step="0.0001">
                </div>
                <div class="price-input-group">
                    <label for="maxPrice">Max:</label>
                    <input type="number" id="maxPrice" placeholder="Max Price" step="0.0001">
                </div>
            </div>
        </div>
        <div class="filter-actions">
            <button class="clear">Clear</button>
            <button class="apply">Apply</button>
        </div>
    </div>

    <script>
        console.log('Script loaded');
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded');

            // Add search functionality
            const searchInput = document.getElementById('heroSearch');
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                const heroCards = document.querySelectorAll('.hero-card');
                
                heroCards.forEach(card => {
                    const heroHandle = card.querySelector('.hero-handle').textContent.toLowerCase();
                    const shouldShow = heroHandle.includes(searchTerm);
                    card.style.display = shouldShow ? 'flex' : 'none';
                });

                // Show/hide star columns based on whether they have visible heroes
                const starColumns = document.querySelectorAll('.star-column');
                starColumns.forEach(column => {
                    const visibleHeroes = column.querySelectorAll('.hero-card[style*="display: flex"]').length;
                    column.style.display = visibleHeroes > 0 ? 'flex' : 'none';
                });
            });
        });

        function getRarityColor(rarity) {
            const rarityColors = {
                "common": "#48EE4B",
                "rare": "#02E0F4",
                "epic": "#CD2FD7",
                "legendary": "#7F76F5",
                "all": "#666666"
            };
            return rarityColors[rarity.toLowerCase()] || '#666666';
        }

        function formatPrice(price) {
            const numPrice = parseFloat(price);
            if (numPrice >= 1) {
                return numPrice.toFixed(4);
            } else {
                return numPrice.toFixed(4).replace(/^0/, '');
            }
        }

        // Add this variable at the top of your script to track the current chart
        let currentChart = null;

        // Add these variables at the top of your script
        let activeFilters = {
            rarity: new Set(),
            price: {
                min: null,
                max: null
            }
        };

        // Add this at the top of your script section, outside any functions
        let tradesData = []; // Global variable to store trades
        let pricesData = []; // Global variable to store prices

        // Add this function to handle filters
        function setupFilters() {
            const filterIcons = document.querySelectorAll('.filter-icon');
            
            filterIcons.forEach(icon => {
                const column = icon.closest('th').textContent.trim().toLowerCase().split(' ')[0];
                
                icon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const rect = icon.getBoundingClientRect();
                    const filterPopup = document.getElementById(`${column}Filter`);
                    
                    if (column === 'rarity') {
                        // Get unique rarity values from the table
                        const rarities = new Set(Array.from(document.querySelectorAll('#tradesTable tbody tr'))
                            .map(row => row.cells[1].textContent.trim()));
                        
                        // Populate rarity filter options
                        const filterOptions = filterPopup.querySelector('.filter-options');
                        filterOptions.innerHTML = Array.from(rarities)
                            .map(rarity => `
                                <div class="filter-option">
                                    <input type="checkbox" id="rarity-${rarity}" value="${rarity}" 
                                        ${activeFilters.rarity.has(rarity) ? 'checked' : ''}>
                                    <label for="rarity-${rarity}" style="color: ${getRarityColor(rarity)}">${rarity}</label>
                                </div>
                            `).join('');
                    } else if (column === 'price') {
                        // Get min/max prices from current trades
                        const prices = Array.from(document.querySelectorAll('#tradesTable tbody tr'))
                            .map(row => parseFloat(row.cells[6].textContent));
                        const minPrice = Math.min(...prices);
                        const maxPrice = Math.max(...prices);

                        const minInput = document.getElementById('minPrice');
                        const maxInput = document.getElementById('maxPrice');

                        // Set step size based on price range
                        const step = minPrice < 1 ? 0.0001 : 0.01;
                        minInput.step = step;
                        maxInput.step = step;

                        // Only set placeholder/value if not already set
                        if (!minInput.value) {
                            minInput.value = minPrice.toFixed(4);
                        }
                        if (!maxInput.value) {
                            maxInput.value = maxPrice.toFixed(4);
                        }

                        // Update icon state
                        if (activeFilters.price.min !== null || activeFilters.price.max !== null) {
                            icon.classList.add('active');
                        } else {
                            icon.classList.remove('active');
                        }
                    }

                    filterPopup.style.display = 'block';
                    filterPopup.style.top = `${rect.top + window.scrollY - filterPopup.offsetHeight - 5}px`;
                    filterPopup.style.left = `${rect.left + window.scrollX - 100}px`;
                });
            });

            // Setup rarity filter actions
            const rarityFilter = document.getElementById('rarityFilter');
            
            rarityFilter.querySelector('.apply').addEventListener('click', () => {
                const checkboxes = rarityFilter.querySelectorAll('input[type="checkbox"]');
                activeFilters.rarity.clear();
                
                checkboxes.forEach(checkbox => {
                    if (checkbox.checked) {
                        activeFilters.rarity.add(checkbox.value);
                    }
                });
                
                const icon = document.querySelector('th:nth-child(2) .filter-icon');
                if (icon) {
                    if (activeFilters.rarity.size > 0) {
                        icon.classList.add('active');
                    } else {
                        icon.classList.remove('active');
                    }
                }
                
                applyFilters();
                rarityFilter.style.display = 'none';
            });

            rarityFilter.querySelector('.clear').addEventListener('click', () => {
                const checkboxes = rarityFilter.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(checkbox => checkbox.checked = false);
                activeFilters.rarity.clear();
                
                const icon = document.querySelector('th:nth-child(2) .filter-icon');
                if (icon) {
                    icon.classList.remove('active');
                }
                
                applyFilters();
                rarityFilter.style.display = 'none';
            });

            // Update price filter actions
            const priceFilter = document.getElementById('priceFilter');
            
            priceFilter.querySelector('.apply').addEventListener('click', () => {
                const minInput = document.getElementById('minPrice');
                const maxInput = document.getElementById('maxPrice');
                const icon = document.querySelector('th:nth-child(7) .filter-icon');
                
                activeFilters.price.min = minInput.value ? parseFloat(minInput.value) : null;
                activeFilters.price.max = maxInput.value ? parseFloat(maxInput.value) : null;
                
                if (icon) {
                    if (activeFilters.price.min !== null || activeFilters.price.max !== null) {
                        icon.classList.add('active');
                    } else {
                        icon.classList.remove('active');
                    }
                }
                
                applyFilters();
                priceFilter.style.display = 'none';
            });

            priceFilter.querySelector('.clear').addEventListener('click', () => {
                const minInput = document.getElementById('minPrice');
                const maxInput = document.getElementById('maxPrice');
                const icon = document.querySelector('th:nth-child(7) .filter-icon');
                
                minInput.value = '';
                maxInput.value = '';
                activeFilters.price.min = null;
                activeFilters.price.max = null;
                
                if (icon) {
                    icon.classList.remove('active');
                }
                
                applyFilters();
                priceFilter.style.display = 'none';
            });

            // Handle clicks outside the popup
            document.addEventListener('click', (e) => {
                const filterPopups = document.querySelectorAll('.filter-popup');
                filterPopups.forEach(popup => {
                    if (!popup.contains(e.target) && !e.target.classList.contains('filter-icon')) {
                        popup.style.display = 'none';
                    }
                });
            });
        }

        function applyFilters() {
            const rows = document.querySelectorAll('#tradesTable tbody tr');
            
            rows.forEach(row => {
                const rarity = row.cells[1].textContent.trim();
                const price = parseFloat(row.cells[6].textContent);
                
                const rarityMatch = activeFilters.rarity.size === 0 || activeFilters.rarity.has(rarity);
                const priceMatch = (activeFilters.price.min === null || price >= activeFilters.price.min) &&
                                  (activeFilters.price.max === null || price <= activeFilters.price.max);
                
                row.style.display = rarityMatch && priceMatch ? '' : 'none';
            });
        }

        // Update the loadHeroTrades function to store the data globally
        async function loadHeroTrades(heroHandle) {
            try {
                // Destroy existing chart if it exists
                if (currentChart) {
                    currentChart.destroy();
                    currentChart = null;
                }

                const timestamp = new Date().getTime();
                const response = await fetch(`/data/heroes/${heroHandle}_trades.json?t=${timestamp}`, {
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const data = await response.json();
                tradesData = data.trades; // Store trades in global variable
                pricesData = data.prices; // Store prices in global variable
                
                // Sort trades by timestamp in descending order
                tradesData.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                // Calculate tradesByRarity for price coloring
                const tradesByRarity = {};
                tradesData.forEach(trade => {
                    if (!tradesByRarity[trade.rarity]) {
                        tradesByRarity[trade.rarity] = {
                            trades: [],
                            minPrice: Infinity,
                            maxPrice: -Infinity
                        };
                    }
                    tradesByRarity[trade.rarity].trades.push(trade);
                    tradesByRarity[trade.rarity].minPrice = Math.min(tradesByRarity[trade.rarity].minPrice, trade.price);
                    tradesByRarity[trade.rarity].maxPrice = Math.max(tradesByRarity[trade.rarity].maxPrice, trade.price);
                });
                
                // Get current toggle state
                const toggleState = document.querySelector('.toggle-switch').getAttribute('data-state');
                
                // Find the matching price data for current rarity
                const priceData = data.prices.find(p => p.rarity.toLowerCase() === toggleState);
                const bidPrice = priceData ? priceData.bid : null;
                const floorPrice = priceData ? priceData.floor : null;

                const filteredTrades = tradesData.filter(trade => trade.rarity.toLowerCase() === toggleState);

                const datasets = [{
                    label: toggleState,
                    data: filteredTrades
                        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                        .map(trade => ({
                            x: trade.timestamp,
                            y: trade.price
                        })),
                    borderWidth: 1,
                    fill: true,
                    backgroundColor: `${getRarityColor(toggleState)}33`,
                    borderColor: getRarityColor(toggleState)
                }];

                const chartData = {
                    datasets: datasets
                };
                
                window.myChart = createLineChart('tradesCanvas', chartData, {
                    chartTitle: 'My Chart',
                    xAxisLabel: 'Time',
                    yAxisLabel: 'Price',
                    bidPrice: bidPrice,
                    floorPrice: floorPrice
                });
                
                const tbody = document.querySelector('#tradesTable tbody');
                tbody.innerHTML = tradesData.map((trade, index) => {
                    // Get selected player handle from localStorage
                    const selectedPlayer = localStorage.getItem('selectedPlayerHandle');
                    
                    // Determine row background color based on buyer/seller match
                    let rowClass = '';
                    if (selectedPlayer) {
                        if (trade.buyer === selectedPlayer) {
                            rowClass = 'buyer-match';
                        } else if (trade.seller === selectedPlayer) {
                            rowClass = 'seller-match';
                        }
                    }
                    
                    // Find the most recent previous trade with the same rarity
                    let priceChange = '';
                    const prevTradeWithSameRarity = tradesData.slice(index + 1).find(t => t.rarity === trade.rarity);
                    
                    if (prevTradeWithSameRarity) {
                        const prevPrice = prevTradeWithSameRarity.price;
                        const changePercent = ((trade.price - prevPrice) / prevPrice) * 100;
                        const triangle = changePercent >= 0 ? '▲' : '▼';
                        const color = changePercent >= 0 ? '#22c55e' : '#ef4444';
                        priceChange = `<span style="color: ${color}">${triangle} ${Math.abs(Math.round(changePercent))}%</span>`;
                    }
                    
                    // Calculate normalized position (0 to 1) for price within its rarity group
                    const rarityGroup = tradesByRarity[trade.rarity];
                    const normalizedPrice = (trade.price - rarityGroup.minPrice) / 
                                          (rarityGroup.maxPrice - rarityGroup.minPrice);
                    
                    // Generate background color using RdYlGn-like gradient
                    const backgroundColor = getPriceBackgroundColor(normalizedPrice);

                    return `
                        <tr class="${rowClass}">
                            <td>
                                <img src="${trade.card_picture}" alt="${trade.hero_handle}" 
                                     style="width: 30px; height: 40px; vertical-align: middle; margin-right: 8px;">
                                ${trade.hero_handle}
                            </td>
                            <td style="color: ${getRarityColor(trade.rarity)}">${trade.rarity}</td>
                            <td title="${new Date(trade.timestamp).toLocaleString('en-US', {
                                month: 'short',    // Jan
                                day: '2-digit',    // DD
                                hour: '2-digit',   // HH
                                minute: '2-digit', // MM
                                second: '2-digit', // SS
                                weekday: 'short',  // Mon
                                hour12: false      // 24-hour format
                            }).replace(',', '')}">${calculateTimeDifference(
                                new Date(),
                                new Date(trade.timestamp)
                            )}</td>
                            <td>${trade.buyer}</td>
                            <td>${trade.seller}</td>
                            <td style="background-color: ${backgroundColor}; color: ${getTextColor(backgroundColor)}">${formatPrice(trade.price)}</td>
                            <td>${priceChange}</td>
                        </tr>
                    `;
                }).join('');

                setupFilters();

                // Apply initial rarity filter based on toggle state
                const currentToggleState = document.querySelector('.toggle-switch').getAttribute('data-state');
                const rows = document.querySelectorAll('#tradesTable tbody tr');
                rows.forEach(row => {
                    const rowRarity = row.cells[1].textContent.trim().toLowerCase();
                    row.style.display = rowRarity === currentToggleState ? '' : 'none';
                });

            } catch (error) {
                console.error('Error loading trades:', error);
            }
        }

        function calculateTimeDifference(currentDate, tradeDate) {
            const diffMs = currentDate - tradeDate;
            const diffMinutes = Math.floor(diffMs / (1000 * 60));
            
            if (diffMinutes < 60) {
                return `${diffMinutes}m ago`;
            }
            
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            if (diffHours < 24) {
                return `${diffHours}h ago`;
            }
            
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            return `${diffDays}d ago`;
        }

        // Add these new helper functions
        function getPriceBackgroundColor(normalizedValue) {
            // Handle edge cases (NaN, undefined, or when min equals max price)
            if (isNaN(normalizedValue) || normalizedValue === undefined) {
                return `rgba(255, 255, 191, 0.2)`; // Default to yellow for equal prices
            }

            // RdYlGn color stops from matplotlib (inverted: red=high, green=low)
            const colors = [
                { pos: 0, color: [26, 152, 80] },     // Dark green (lowest)
                { pos: 0.25, color: [145, 207, 96] }, // Light green
                { pos: 0.5, color: [255, 255, 191] }, // True yellow
                { pos: 0.75, color: [252, 141, 89] }, // Light red-orange
                { pos: 1, color: [215, 48, 39] }      // Dark red (highest)
            ];
            
            // Find the two colors to interpolate between
            let startColor, endColor, fraction;
            for (let i = 0; i < colors.length - 1; i++) {
                if (normalizedValue <= colors[i + 1].pos) {
                    startColor = colors[i];
                    endColor = colors[i + 1];
                    fraction = (normalizedValue - startColor.pos) / (endColor.pos - startColor.pos);
                    break;
                }
            }
            
            // If normalizedValue is 1 or we didn't find a range, use the last color
            if (normalizedValue === 1 || !startColor || !endColor) {
                const lastColor = colors[colors.length - 1].color;
                return `rgba(${lastColor[0]}, ${lastColor[1]}, ${lastColor[2]}, 1)`;
            }
            
            // Interpolate between the two colors
            const r = Math.round(startColor.color[0] + (endColor.color[0] - startColor.color[0]) * fraction);
            const g = Math.round(startColor.color[1] + (endColor.color[1] - startColor.color[1]) * fraction);
            const b = Math.round(startColor.color[2] + (endColor.color[2] - startColor.color[2]) * fraction);
            
            // Return with consistent opacity
            return `rgba(${r}, ${g}, ${b}, 0.2)`;
        }

        function getTextColor(backgroundColor) {
            // Always return the default text color since we're using light backgrounds
            return 'inherit';
        }

        function getFloorPriceColor(price, allPrices) {
            if (!price || price === 'N/A') return 'inherit';
            
            // Calculate normalized value (0 to 1)
            const validPrices = allPrices.filter(p => p !== null && p !== undefined);
            const minPrice = Math.min(...validPrices);
            const maxPrice = Math.max(...validPrices);
            const normalizedValue = (price - minPrice) / (maxPrice - minPrice);
            
            // Color stops from green (low) to red (high)
            const colors = [
                { pos: 0, color: [39, 174, 96] },    // Green (lowest)
                { pos: 0.25, color: [119, 194, 116] }, // Light green
                { pos: 0.5, color: [241, 196, 15] },   // Yellow
                { pos: 0.75, color: [230, 126, 34] },  // Orange
                { pos: 1, color: [231, 76, 60] }       // Red (highest)
            ];
            
            // Find the two colors to interpolate between
            let startColor, endColor, fraction;
            for (let i = 0; i < colors.length - 1; i++) {
                if (normalizedValue <= colors[i + 1].pos) {
                    startColor = colors[i];
                    endColor = colors[i + 1];
                    fraction = (normalizedValue - startColor.pos) / (endColor.pos - startColor.pos);
                    break;
                }
            }
            
            // If value is 1 or we didn't find a range, use the last color
            if (normalizedValue === 1 || !startColor || !endColor) {
                const lastColor = colors[colors.length - 1].color;
                return `rgb(${lastColor[0]}, ${lastColor[1]}, ${lastColor[2]})`;
            }
            
            // Interpolate between the two colors
            const r = Math.round(startColor.color[0] + (endColor.color[0] - startColor.color[0]) * fraction);
            const g = Math.round(startColor.color[1] + (endColor.color[1] - startColor.color[1]) * fraction);
            const b = Math.round(startColor.color[2] + (endColor.color[2] - startColor.color[2]) * fraction);
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Add this to your existing script section, after the DOMContentLoaded event
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('DOM Content Loaded');
            
            // Remove the existing hero select dropdown code and add this:
            const heroSelectButton = document.getElementById('heroSelectButton');
            const heroSelectorPopup = document.getElementById('heroSelectorPopup');
            const closePopupButton = document.querySelector('.close-popup');
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            document.body.appendChild(overlay);

            // Load and organize hero data
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`/hero_stats.json?t=${timestamp}`, {
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const data = await response.json();

                // Calculate allFloorPrices FIRST
                const allFloorPrices = data.heroes
                    .map(hero => hero.common_floor)
                    .filter(price => price !== null && price !== undefined);

                // Then group heroes by stars and continue with the rest of the code
                const heroesByStars = data.heroes.reduce((acc, hero) => {
                    const stars = hero.current_stars;
                    if (!acc[stars]) acc[stars] = [];
                    acc[stars].push(hero);
                    return acc;
                }, {});

                // Sort each star group by fantasy score
                Object.keys(heroesByStars).forEach(stars => {
                    heroesByStars[stars].sort((a, b) => 
                        b.seven_day_fantasy_score - a.seven_day_fantasy_score
                    );
                });

                // Create star columns
                const starsGrid = document.querySelector('.stars-grid');
                const starLevels = Object.keys(heroesByStars)
                    .map(Number)
                    .sort((a, b) => b - a); // Sort stars descending

                starLevels.forEach(stars => {
                    const column = document.createElement('div');
                    column.className = 'star-column';

                    // Create star header
                    const header = document.createElement('div');
                    header.className = 'star-header';
                    header.innerHTML = `${stars} ⭐`;
                    column.appendChild(header);

                    // Create hero cards
                    heroesByStars[stars].forEach(hero => {
                        const card = document.createElement('div');
                        card.className = 'hero-card';
                        card.innerHTML = `
                            <img src="${hero.hero_image_url}" alt="${hero.hero_handle}" class="hero-image">
                            <div class="hero-info" data-stars="${hero.current_stars}">
                                <div class="hero-handle" data-name="${hero.hero_name || ''}">${hero.hero_handle}</div>
                                <div class="floor-price" style="display: flex; align-items: center;">
                                    <img src="/icons/eth.webp" alt="ETH" style="width: 12px; height: 12px; margin-right: 2px;">
                                    <span title="Common Floor" style="color: ${getFloorPriceColor(hero.common_floor, allFloorPrices)}">
                                        ${hero.common_floor ? formatFloorPrice(hero.common_floor) : 'N/A'}
                                    </span>
                                </div>
                                <div class="score-per-eth" title="Score Per ETH, Higher = more score for the price (better value)
                                    Calc = AVG(7D,LM) / Floor / 100" style="display: flex; align-items: center;">
                                    <img src="/icons/scale.webp" alt="Score/ETH" style="width: 12px; height: 12px; margin-right: 2px;">
                                    <span style="color: ${getFloorPriceColor(
                                        Math.max(...data.heroes.map(h => h.score_per_eth)) - hero.score_per_eth, 
                                        data.heroes.map(h => Math.max(...data.heroes.map(h2 => h2.score_per_eth)) - h.score_per_eth)
                                    )}">
                                        ${Math.round(hero.score_per_eth)}
                                    </span>
                                </div>
                            </div>
                            <div class="hero-scores">
                                <span class="seven-day-score" title="Seven Day Score">
                                    <span class="score-label">7D:</span>
                                    <span class="score-value" style="background-color: ${getScoreColor(hero.seven_day_fantasy_score, 'seven_day')}">${Math.round(hero.seven_day_fantasy_score)}</span>
                                </span>
                                <span class="last-main-score" title="Last Main Score">
                                    <span class="score-label">LM:</span>
                                    <span class="score-value" style="background-color: ${getScoreColor(hero.last_main, 'last_main')}">${Math.round(hero.last_main)}</span>
                                </span>
                                <span class="l3-main-score" title="L3 Main Median Score">
                                    <span class="score-label">L3:</span>
                                    <span class="score-value" style="background-color: ${getScoreColor(hero.l3_main_median, 'l3_main_median')}">${Math.round(hero.l3_main_median)}</span>
                                </span>
                            </div>
                        `;

                        card.addEventListener('click', () => {
                            loadHeroTrades(hero.hero_handle);
                            heroSelectorPopup.style.display = 'none';
                            overlay.style.display = 'none';
                        });

                        column.appendChild(card);
                    });

                    starsGrid.appendChild(column);
                });

                // Show popup when button is clicked
                heroSelectButton.addEventListener('click', () => {
                    heroSelectorPopup.style.display = 'block';
                    overlay.style.display = 'block';
                    // Add this line to focus the search input
                    document.getElementById('heroSearch').focus();
                });


                // Close popup when close button is clicked
                closePopupButton.addEventListener('click', () => {
                    heroSelectorPopup.style.display = 'none';
                    overlay.style.display = 'none';
                });

                // Close popup when clicking overlay
                overlay.addEventListener('click', () => {
                    heroSelectorPopup.style.display = 'none';
                    overlay.style.display = 'none';
                });

                // Find min and max floor prices
                const floorPrices = data.heroes
                    .map(hero => hero.common_floor)
                    .filter(price => price !== null && price !== undefined);
                const minFloor = Math.min(...floorPrices);
                const maxFloor = Math.max(...floorPrices);

                // Set default values for price inputs
                const minPriceInput = document.getElementById('popupMinPrice');
                const maxPriceInput = document.getElementById('popupMaxPrice');
                minPriceInput.value = minFloor.toFixed(4);
                maxPriceInput.value = maxFloor.toFixed(4);

                // Add price filter event listeners
                function filterHeroes() {
                    const searchTerm = document.getElementById('heroSearch').value.toLowerCase();
                    const minPrice = parseFloat(minPriceInput.value) || 0;
                    const maxPrice = parseFloat(maxPriceInput.value) || Infinity;
                    const min7DScore = parseFloat(document.getElementById('popupMin7DScore').value) || 0;
                    const max7DScore = parseFloat(document.getElementById('popupMax7DScore').value) || Infinity;
                    const minLMScore = parseFloat(document.getElementById('popupMinLMScore').value) || 0;
                    const maxLMScore = parseFloat(document.getElementById('popupMaxLMScore').value) || Infinity;
                    const minL3MScore = parseFloat(document.getElementById('popupMinL3MScore').value) || 0;
                    const maxL3MScore = parseFloat(document.getElementById('popupMaxL3MScore').value) || Infinity;

                    const heroCards = document.querySelectorAll('.hero-card');
                    heroCards.forEach(card => {
                        const heroHandleEl = card.querySelector('.hero-handle');
                        const heroHandle = heroHandleEl.textContent.toLowerCase();
                        const heroName = heroHandleEl.dataset.name.toLowerCase();
                        const floorPriceEl = card.querySelector('.floor-price span[title="Common Floor"]');
                        const floorPrice = parseFloat(floorPriceEl.textContent);
                        
                        // Get scores from the card
                        const sevenDayScore = parseInt(card.querySelector('.seven-day-score .score-value').textContent);
                        const lastMainScore = parseInt(card.querySelector('.last-main-score .score-value').textContent);
                        
                        const matchesSearch = heroHandle.includes(searchTerm) || heroName.includes(searchTerm);
                        const matchesPrice = !isNaN(floorPrice) && floorPrice >= minPrice && floorPrice <= maxPrice;
                        const matches7DScore = sevenDayScore >= min7DScore && sevenDayScore <= max7DScore;
                        const matchesLMScore = lastMainScore >= minLMScore && lastMainScore <= maxLMScore;
                        
                        card.style.display = matchesSearch && matchesPrice && matches7DScore && matchesLMScore ? 'flex' : 'none';
                    });

                    // Show/hide star columns based on whether they have visible heroes
                    const starColumns = document.querySelectorAll('.star-column');
                    starColumns.forEach(column => {
                        const visibleHeroes = column.querySelectorAll('.hero-card[style*="display: flex"]').length;
                        column.style.display = visibleHeroes > 0 ? 'flex' : 'none';
                    });
                }

                minPriceInput.addEventListener('input', filterHeroes);
                maxPriceInput.addEventListener('input', filterHeroes);
                document.getElementById('popupMin7DScore').addEventListener('input', filterHeroes);
                document.getElementById('popupMax7DScore').addEventListener('input', filterHeroes);
                document.getElementById('popupMinLMScore').addEventListener('input', filterHeroes);
                document.getElementById('popupMaxLMScore').addEventListener('input', filterHeroes);
                document.getElementById('popupMinL3MScore').addEventListener('input', filterHeroes);
                document.getElementById('popupMaxL3MScore').addEventListener('input', filterHeroes);

                // Update existing search input event listener to also check price
                const searchInput = document.getElementById('heroSearch');
                searchInput.addEventListener('input', filterHeroes);

            } catch (error) {
                console.error('Error loading hero stats:', error);
            }
        });

        // Add this to your existing script section
        document.addEventListener('DOMContentLoaded', function() {
            const toggleSwitch = document.querySelector('.toggle-switch');
            
            // Set initial colors
            const commonColor = getRarityColor('common');
            const rareColor = getRarityColor('rare');
            
            // Set CSS variables for the colors
            toggleSwitch.style.setProperty('--slider-color', commonColor);
            toggleSwitch.style.setProperty('--slider-color-rare', rareColor);
            
            toggleSwitch.addEventListener('click', function() {
                const currentState = this.getAttribute('data-state');
                const newState = currentState === 'common' ? 'rare' : 'common';
                this.setAttribute('data-state', newState);
                
                // Update active text colors
                const options = this.querySelectorAll('.toggle-option');
                options.forEach(option => {
                    if (option.textContent.toLowerCase() === newState) {
                        option.style.color = '#fff';
                    } else {
                        option.style.color = 'rgba(255, 255, 255, 0.5)';
                    }
                });

                // Filter table rows
                const rows = document.querySelectorAll('#tradesTable tbody tr');
                rows.forEach(row => {
                    const rowRarity = row.cells[1].textContent.trim().toLowerCase();
                    row.style.display = rowRarity === newState ? '' : 'none';
                });

                // Only proceed with chart update if we have data
                if (pricesData && tradesData) {
                    // Find the matching price data for new rarity state
                    const priceData = pricesData.find(p => p.rarity.toLowerCase() === newState);
                    const bidPrice = priceData ? priceData.bid : null;
                    const floorPrice = priceData ? priceData.floor : null;

                    // Update chart with filtered data and new bid/floor prices
                    const filteredTrades = tradesData.filter(trade => trade.rarity.toLowerCase() === newState);
                    const datasets = [{
                        label: newState,
                        data: filteredTrades
                            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                            .map(trade => ({
                                x: trade.timestamp,
                                y: trade.price
                            })),
                        borderWidth: 1,
                        fill: true,
                        backgroundColor: `${getRarityColor(newState)}33`,
                        borderColor: getRarityColor(newState)
                    }];

                    if (window.myChart) {
                        window.myChart.destroy();
                        window.myChart = createLineChart('tradesCanvas', { datasets }, {
                            chartTitle: 'My Chart',
                            xAxisLabel: 'Time',
                            yAxisLabel: 'Price',
                            bidPrice: bidPrice,
                            floorPrice: floorPrice
                        });
                    }
                }
            });
            
            // Set initial text colors
            const options = toggleSwitch.querySelectorAll('.toggle-option');
            options[0].style.color = '#fff';
            options[1].style.color = 'rgba(255, 255, 255, 0.5)';
            
            // Apply initial filter for 'common'
            const rows = document.querySelectorAll('#tradesTable tbody tr');
            rows.forEach(row => {
                const rowRarity = row.cells[1].textContent.trim().toLowerCase();
                row.style.display = rowRarity === 'common' ? '' : 'none';
            });
        });

        function formatFloorPrice(price) {
            if (price >= 1) {
                return price.toFixed(1);
            } else {
                return price.toFixed(3).replace(/\.?0+$/, '');
            }
        }

        function getScoreColor(score, type) {
            // Normalize score between 0 and 1
            const normalizedScore = Math.min(Math.max(score, 0), 1000) / 1000;
            
            // 8 distinct colors from red (lowest) to purple (highest)
            const colorStops = [
                { pos: 0, color: [220, 20, 60] },    // Crimson red (lowest)
                { pos: 0.143, color: [199, 21, 133] }, // Medium violet red
                { pos: 0.286, color: [148, 0, 211] },  // Dark violet
                { pos: 0.429, color: [138, 43, 226] }, // Blue violet
                { pos: 0.572, color: [75, 0, 130] },   // Indigo
                { pos: 0.715, color: [106, 90, 205] }, // Slate blue
                { pos: 0.858, color: [147, 112, 219] },// Medium purple
                { pos: 1, color: [128, 0, 128] }      // Purple (highest)
            ];
            
            // Find the two colors to interpolate between
            let startColor, endColor, fraction;
            for (let i = 0; i < colorStops.length - 1; i++) {
                if (normalizedScore <= colorStops[i + 1].pos) {
                    startColor = colorStops[i];
                    endColor = colorStops[i + 1];
                    fraction = (normalizedScore - startColor.pos) / (endColor.pos - startColor.pos);
                    break;
                }
            }
            
            // If score is at max or we didn't find a range, use the last color
            if (normalizedScore === 1 || !startColor || !endColor) {
                const lastColor = colorStops[colorStops.length - 1].color;
                return `rgb(${lastColor[0]}, ${lastColor[1]}, ${lastColor[2]})`;
            }
            
            // Interpolate between the two colors
            const r = Math.round(startColor.color[0] + (endColor.color[0] - startColor.color[0]) * fraction);
            const g = Math.round(startColor.color[1] + (endColor.color[1] - startColor.color[1]) * fraction);
            const b = Math.round(startColor.color[2] + (endColor.color[2] - startColor.color[2]) * fraction);
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Add after your existing DOMContentLoaded event listener
        document.addEventListener('DOMContentLoaded', function() {
            // Change this line to only select star buttons within the star-buttons div
            const starButtons = document.querySelectorAll('.star-buttons .star-btn');
            const activeStars = new Set();

            starButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const stars = button.dataset.stars;
                    
                    if (stars === 'all') {
                        // Toggle all buttons (only within star-buttons)
                        const allActive = Array.from(starButtons).every(btn => btn.classList.contains('active'));
                        starButtons.forEach(btn => {
                            if (allActive) {
                                btn.classList.remove('active');
                                activeStars.clear();
                            } else {
                                btn.classList.add('active');
                                if (btn.dataset.stars !== 'all') {
                                    activeStars.add(btn.dataset.stars);
                                }
                            }
                        });
                    } else {
                        // Toggle individual star button
                        button.classList.toggle('active');
                        if (activeStars.has(stars)) {
                            activeStars.delete(stars);
                        } else {
                            activeStars.add(stars);
                        }
                        
                        // Update "All" button state
                        const allButton = document.querySelector('.star-btn[data-stars="all"]');
                        const allStarButtons = Array.from(starButtons).filter(btn => btn.dataset.stars !== 'all');
                        const allActive = allStarButtons.every(btn => btn.classList.contains('active'));
                        allButton.classList.toggle('active', allActive);
                    }

                    // Filter star columns
                    const starColumns = document.querySelectorAll('.star-column');
                    starColumns.forEach(column => {
                        const columnStars = column.querySelector('.star-header').textContent.split(' ')[0];
                        if (activeStars.size === 0 || activeStars.has(columnStars)) {
                            column.style.display = 'flex';
                        } else {
                            column.style.display = 'none';
                        }
                    });

                    adjustColumnWidths();
                });
            });
        });

        // Update your existing filterHeroes function to include star filtering
        function filterHeroes() {
            const searchTerm = document.getElementById('heroSearch').value.toLowerCase();
            const minPrice = parseFloat(minPriceInput.value) || 0;
            const maxPrice = parseFloat(maxPriceInput.value) || Infinity;
            const activeStars = new Set(
                Array.from(document.querySelectorAll('.star-btn.active'))
                    .map(btn => btn.dataset.stars)
            );

            // ... existing price and score filtering ...

            // Add star filtering to the visibility check
            const starColumns = document.querySelectorAll('.star-column');
            starColumns.forEach(column => {
                const columnStars = column.querySelector('.star-header').textContent.split(' ')[0];
                const matchesStars = activeStars.size === 0 || activeStars.has(columnStars);
                column.style.display = matchesStars ? 'flex' : 'none';
            });

            // Add this at the end of the function
            adjustColumnWidths();
        }

        // Add this function to handle dynamic column sizing
        function adjustColumnWidths() {
            const visibleColumns = document.querySelectorAll('.star-column[style*="display: flex"]');
            const starsGrid = document.querySelector('.stars-grid');
            
            // Remove all width-related classes first
            starsGrid.classList.remove('wide-columns', 'superwide-columns');
            visibleColumns.forEach(column => {
                column.classList.remove('wide', 'superwide');
            });

            if (visibleColumns.length <= 2) {
                // Make columns super wide (4 cards per row)
                starsGrid.classList.add('superwide-columns');
                visibleColumns.forEach(column => {
                    column.classList.add('superwide');
                    
                    // Wrap hero cards in a container if not already wrapped
                    const cards = Array.from(column.querySelectorAll('.hero-card'));
                    if (!column.querySelector('.hero-cards-container')) {
                        const container = document.createElement('div');
                        container.className = 'hero-cards-container';
                        cards.forEach(card => {
                            if (card !== column.querySelector('.star-header')) {
                                container.appendChild(card);
                            }
                        });
                        column.appendChild(container);
                    }
                });
            } else if (visibleColumns.length <= 3) {
                // Make columns wide (2 cards per row)
                starsGrid.classList.add('wide-columns');
                visibleColumns.forEach(column => {
                    column.classList.add('wide');
                    
                    // Wrap hero cards in a container if not already wrapped
                    const cards = Array.from(column.querySelectorAll('.hero-card'));
                    if (!column.querySelector('.hero-cards-container')) {
                        const container = document.createElement('div');
                        container.className = 'hero-cards-container';
                        cards.forEach(card => {
                            if (card !== column.querySelector('.star-header')) {
                                container.appendChild(card);
                            }
                        });
                        column.appendChild(container);
                    }
                });
            } else {
                // Reset to normal width (1 card per row)
                visibleColumns.forEach(column => {
                    // Unwrap cards if needed
                    const container = column.querySelector('.hero-cards-container');
                    if (container) {
                        const cards = Array.from(container.querySelectorAll('.hero-card'));
                        cards.forEach(card => {
                            container.parentNode.insertBefore(card, container);
                        });
                        container.remove();
                    }
                });
            }
        }

        // Add this new function to handle sorting
        function setupSorting() {
            const sortArrows = document.querySelectorAll('.sort-arrows');
            const sortStates = new Map(); // Track sort state for each column

            // Initialize all sort states to 'none'
            sortArrows.forEach(arrows => {
                sortStates.set(arrows.dataset.sort, 'none');
            });

            // Set initial 7D score sort to descending
            const sevenDayArrows = document.querySelector('.sort-arrows[data-sort="7d"]');
            if (sevenDayArrows) {
                sevenDayArrows.classList.add('desc');
                sortStates.set('7d', 'desc');
                sortCards('7d', 'desc');
            }

            sortArrows.forEach(arrows => {
                arrows.addEventListener('click', () => {
                    const sortType = arrows.dataset.sort;
                    let sortDirection = sortStates.get(sortType);

                    // Reset all other sort arrows
                    sortArrows.forEach(other => {
                        if (other !== arrows) {
                            other.classList.remove('asc', 'desc');
                            sortStates.set(other.dataset.sort, 'none');
                        }
                    });

                    // If not currently sorted, start with descending
                    if (sortDirection === 'none') {
                        sortDirection = 'desc';
                        arrows.classList.add('desc');
                    } else if (sortDirection === 'desc') {
                        sortDirection = 'asc';
                        arrows.classList.add('asc');
                        arrows.classList.remove('desc');
                    } else {
                        sortDirection = 'desc';
                        arrows.classList.add('desc');
                        arrows.classList.remove('asc');
                    }

                    sortStates.set(sortType, sortDirection);
                    sortCards(sortType, sortDirection);
                });
            });

            // Separate sorting logic into its own function
            function sortCards(sortType, sortDirection) {
                const heroCards = Array.from(document.querySelectorAll('.hero-card'));
                heroCards.sort((a, b) => {
                    let valueA, valueB;
                    switch (sortType) {
                        case 'price':
                            valueA = parseFloat(a.querySelector('.floor-price span').textContent) || 0;
                            valueB = parseFloat(b.querySelector('.floor-price span').textContent) || 0;
                            break;
                        case '7d':
                            valueA = parseInt(a.querySelector('.seven-day-score .score-value').textContent) || 0;
                            valueB = parseInt(b.querySelector('.seven-day-score .score-value').textContent) || 0;
                            break;
                        case 'lm':
                            valueA = parseInt(a.querySelector('.last-main-score .score-value').textContent) || 0;
                            valueB = parseInt(b.querySelector('.last-main-score .score-value').textContent) || 0;
                            break;
                        case 'l3m':
                            valueA = parseInt(a.querySelector('.l3-main-score .score-value').textContent) || 0;
                            valueB = parseInt(b.querySelector('.l3-main-score .score-value').textContent) || 0;
                            break;
                    }
                    
                    return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
                });

                // Reinsert cards in new order
                const starColumns = document.querySelectorAll('.star-column');
                starColumns.forEach(column => {
                    const columnStars = column.querySelector('.star-header').textContent.split(' ')[0];
                    const columnCards = heroCards.filter(card => {
                        const cardStars = card.closest('.star-column').querySelector('.star-header').textContent.split(' ')[0];
                        return cardStars === columnStars;
                    });
                    
                    // Remove existing cards
                    column.querySelectorAll('.hero-card').forEach(card => card.remove());
                    
                    // Add sorted cards
                    columnCards.forEach(card => {
                        column.appendChild(card);
                    });
                });
            }
        }

        // Call setupSorting in your DOMContentLoaded event
        document.addEventListener('DOMContentLoaded', function() {
            // ... existing code ...
            setupSorting();
        });

        // Replace the existing setupBestValueFilter function with this updated version
        function setupBestValueFilter() {
            const valueBtn = document.querySelector('.value-btn');
            
            valueBtn.addEventListener('click', () => {
                valueBtn.classList.toggle('active');
                
                const starColumns = document.querySelectorAll('.star-column');
                
                starColumns.forEach(column => {
                    // Get all visible hero cards in this column (respecting current filters)
                    const heroCards = Array.from(column.querySelectorAll('.hero-card[style*="display: flex"]'));
                    
                    if (valueBtn.classList.contains('active')) {
                        // If we have visible cards, find the one with highest score per eth
                        if (heroCards.length > 0) {
                            // Map cards to their score per eth values
                            const cardValues = heroCards.map(card => ({
                                card,
                                scorePerEth: parseInt(card.querySelector('.score-per-eth span').textContent) ||0
                            }));
                            
                            // Sort by score per eth descending
                            cardValues.sort((a, b) => b.scorePerEth - a.scorePerEth);
                            
                            // Show only the highest value card, hide others
                            heroCards.forEach(card => {
                                const isHighestValue = card === cardValues[0].card;
                                card.style.display = isHighestValue ? 'flex' : 'none';
                                card.style.border = isHighestValue ? '2px solid #3b82f6' : 'none';
                            });
                        }
                    } else {
                        // Reset display of all cards and remove highlights
                        const allCards = column.querySelectorAll('.hero-card');
                        allCards.forEach(card => {
                            card.style.display = 'flex';
                            card.style.border = 'none';
                        });
                        
                        // Re-apply any existing filters
                        filterHeroes();
                    }
                });
                
                // Adjust column widths after filtering
                adjustColumnWidths();
            });
        }

        // Update the filterHeroes function to handle best value filtering correctly
        function filterHeroes() {
            const searchTerm = document.getElementById('heroSearch').value.toLowerCase();
            const minPrice = parseFloat(document.getElementById('popupMinPrice').value) || 0;
            const maxPrice = parseFloat(document.getElementById('popupMaxPrice').value) || Infinity;
            const min7DScore = parseFloat(document.getElementById('popupMin7DScore').value) || 0;
            const max7DScore = parseFloat(document.getElementById('popupMax7DScore').value) || Infinity;
            const minLMScore = parseFloat(document.getElementById('popupMinLMScore').value) || 0;
            const maxLMScore = parseFloat(document.getElementById('popupMaxLMScore').value) || Infinity;
            const valueBtn = document.querySelector('.value-btn');
            
            const starColumns = document.querySelectorAll('.star-column');
            starColumns.forEach(column => {
                const heroCards = Array.from(column.querySelectorAll('.hero-card'));
                
                // First apply regular filters
                const filteredCards = heroCards.filter(card => {
                    const heroHandle = card.querySelector('.hero-handle').textContent.toLowerCase();
                    const floorPrice = parseFloat(card.querySelector('.floor-price span').textContent);
                    const sevenDayScore = parseInt(card.querySelector('.seven-day-score .score-value').textContent);
                    const lastMainScore = parseInt(card.querySelector('.last-main-score .score-value').textContent);
                    
                    return heroHandle.includes(searchTerm) &&
                           floorPrice >= minPrice && floorPrice <= maxPrice &&
                           sevenDayScore >= min7DScore && sevenDayScore <= max7DScore &&
                           lastMainScore >= minLMScore && lastMainScore <= maxLMScore;
                });

                if (valueBtn.classList.contains('active') && filteredCards.length > 0) {
                    // Find the card with highest score-per-eth among filtered cards
                    const cardValues = filteredCards.map(card => ({
                        card,
                        scorePerEth: parseInt(card.querySelector('.score-per-eth span').textContent)
                    }));
                    
                    cardValues.sort((a, b) => b.scorePerEth - a.scorePerEth);
                    
                    // Show only the highest value card in this column
                    heroCards.forEach(card => {
                        const isHighestValue = card === cardValues[0].card;
                        card.style.display = isHighestValue ? 'flex' : 'none';
                        card.style.border = isHighestValue ? '2px solid #3b82f6' : 'none';
                    });
                } else {
                    // Show all filtered cards without best value filtering
                    heroCards.forEach(card => {
                        const heroHandle = card.querySelector('.hero-handle').textContent.toLowerCase();
                        const floorPrice = parseFloat(card.querySelector('.floor-price span').textContent);
                        const sevenDayScore = parseInt(card.querySelector('.seven-day-score .score-value').textContent);
                        const lastMainScore = parseInt(card.querySelector('.last-main-score .score-value').textContent);
                        
                        const shouldShow = heroHandle.includes(searchTerm) &&
                                         floorPrice >= minPrice && floorPrice <= maxPrice &&
                                         sevenDayScore >= min7DScore && sevenDayScore <= max7DScore &&
                                         lastMainScore >= minLMScore && lastMainScore <= maxLMScore;
                        
                        card.style.display = shouldShow ? 'flex' : 'none';
                        card.style.border = 'none';
                    });
                }
                
                // Show/hide star columns based on whether they have visible heroes
                const visibleHeroes = column.querySelectorAll('.hero-card[style*="display: flex"]').length;
                column.style.display = visibleHeroes > 0 ? 'flex' : 'none';
            });
        }

    function toggleBestValue() {
        const valueBtn = document.querySelector('.value-btn');
        valueBtn.classList.toggle('active');
        
        // Get all hero cards
        const heroCards = document.querySelectorAll('.hero-card');
        
        if (!valueBtn.classList.contains('active')) {
            // Reset all cards and reapply existing filters
            heroCards.forEach(card => {
                card.style.display = 'flex';
                card.style.border = 'none';
            });
            filterHeroes();
            return;
        }
        
        // Group cards by star rating
        const cardsByStars = {};
        heroCards.forEach(card => {
            const stars = card.querySelector('.hero-info').dataset.stars;
            if (!cardsByStars[stars]) {
                cardsByStars[stars] = [];
            }
            cardsByStars[stars].push(card);
        });
        
        // Find and show only the best value card for each star rating
        Object.entries(cardsByStars).forEach(([stars, cards]) => {
            // Hide all cards initially
            cards.forEach(card => {
                card.style.display = 'none';
                card.style.border = 'none';
            });
            
            // Find card with highest score per ETH
            const bestCard = cards.reduce((best, current) => {
                const currentScore = parseInt(current.querySelector('.score-per-eth span').textContent) || 0;
                const bestScore = parseInt(best.querySelector('.score-per-eth span').textContent) || 0;
                return currentScore > bestScore ? current : best;
            }, cards[0]);
            
            // Show and highlight the best value card
            if (bestCard) {
                bestCard.style.display = 'flex';
            }
        });
        
        // Adjust column visibility
        const starColumns = document.querySelectorAll('.star-column');
        starColumns.forEach(column => {
            const visibleCards = column.querySelectorAll('.hero-card[style*="display: flex"]').length;
            column.style.display = visibleCards > 0 ? 'flex' : 'none';
        });
        
        // Adjust column widths after filtering
        adjustColumnWidths();
    }
    </script>
</body>
</html>