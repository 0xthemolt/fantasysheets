<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tactic Scores</title>
    <link rel="stylesheet" href="../styles.css?v=8e4c2f">
    <link rel="icon" type="image/png" href="../icons/favicon.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        .hero-cell {
            display: flex;
            align-items: center;
            padding: 8px;
        }

        .score-container {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 500;
        }

        .score-low {
            background-color: rgba(215, 48, 39, 0.2);  /* matplotlib RdYlGn red */
        }

        .score-medium {
            background-color: rgba(255, 255, 191, 0.2);  /* matplotlib RdYlGn yellow */
        }

        .score-high {
            background-color: rgba(26, 152, 80, 0.2);  /* matplotlib RdYlGn green */
        }

        .score-per-salary::before {
            display: none;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        td, th {
            padding: 8px;
            text-align: left;
        }

        th {
            cursor: pointer;
        }

        .tactic-summary {
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .tactic-summary h3 {
            margin: 0 0 8px 0;
        }

        .tactic-details {
            display: flex;
            gap: 24px;
        }

        .tactic-detail {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tactic-detail i {
            color: #666;
        }

        .number-cell {
            text-align: right;
        }

        .center-cell {
            text-align: center !important;
        }

        .salary-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }
        
        .salary-value {
            font-weight: 500;
            width: 24px;  /* Set fixed width */
            height: 24px; /* Set fixed height */
            border-radius: 50%; /* Make it circular */
            color: #444;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
        }

        /* Update the salary background colors to be more vibrant */
        .salary-low { 
            background-color: #f5f5f5; 
            border: 1px solid #e0e0e0;
        }
        .salary-medium { 
            background-color: #FFD700;  /* Solid gold color */
            border: 1px solid #FFB700;
        }
        .salary-high { 
            background-color: #FFA500;  /* Solid orange color */
            border: 1px solid #FF8C00;
        }
    </style>
</head>
<body>
    <div class="tactic-summary">
        <h3 id="tacticName"></h3>
        <div class="tactic-details">
            <div class="tactic-detail">
                <i class="fas fa-clock"></i>
                <span id="tacticDuration"></span>
            </div>
            <div class="tactic-detail">
                <i class="fas fa-calendar"></i>
                <span id="tacticDates"></span>
            </div>
        </div>
    </div>
    <div id="tableContainer">
        <h2>Hero Scores</h2>
        <table id="heroScores">
            <thead>
                <tr>
                    <th data-sort="rank">Rank</th>
                    <th data-sort="name">Hero</th>
                    <th data-sort="score" class="number-cell">Score</th>
                    <th data-sort="salary" class="center-cell">Salary Cap</th>
                    <th data-sort="value">Value</th>
                    <th data-sort="usage" class="number-cell">Own %</th>
                    <th data-sort="views" class="number-cell">Views</th>
                    <th data-sort="tweets" class="number-cell">Tweets</th>
                </tr>
            </thead>
            <tbody id="heroTableBody"></tbody>
        </table>
    </div>

    <script>
        // Change the initial sort state
        let currentSort = { column: 'score', ascending: false };  // Default to score descending

        function sortData(heroes, column, ascending) {
            return [...heroes].sort((a, b) => {
                let aValue, bValue;
                
                switch(column) {
                    case 'name':
                        aValue = a.heroes.name.toLowerCase();
                        bValue = b.heroes.name.toLowerCase();
                        break;
                    case 'score':
                        aValue = parseFloat(a.fantasy_score);
                        bValue = parseFloat(b.fantasy_score);
                        break;
                    case 'salary':
                        aValue = parseFloat(a.salary_cap);
                        bValue = parseFloat(b.salary_cap);
                        break;
                    case 'value':
                        aValue = parseFloat(a.fantasy_score) / parseFloat(a.salary_cap);
                        bValue = parseFloat(b.fantasy_score) / parseFloat(b.salary_cap);
                        break;
                    case 'rank':
                        aValue = parseInt(a.current_rank);
                        bValue = parseInt(b.current_rank);
                        break;
                    case 'views':
                        aValue = parseInt(a.views);
                        bValue = parseInt(b.views);
                        break;
                    case 'tweets':
                        aValue = parseInt(a.tweet_count);
                        bValue = parseInt(b.tweet_count);
                        break;
                    case 'usage':
                        aValue = parseFloat(a.usage);
                        bValue = parseFloat(b.usage);
                        break;
                }
                
                if (!ascending) {
                    return aValue < bValue ? 1 : -1;
                }
                return aValue > bValue ? 1 : -1;
            });
        }

        async function fetchHeroData() {
            try {
                const [heroResponse, usageData] = await Promise.all([
                    fetch(`https://api-v2.fantasy.top/tactics/hero-scores/c169c857-0b4d-4a6c-aff1-14629f4adb2f?orderBy.fantasy_score=desc&pagination.page=1&pagination.limit=500`, {
                        headers: {
                            'accept': 'application/json',
                            'x-api-key': 'cbc57228-5495-47b0-ae2f-b43ba6d5a9b6'
                        }
                    }),
                    fetchTacticHeroUsage()
                ]);

                const heroData = await heroResponse.json();        
                
                // Create a map of hero usage data for quick lookup
                const usageMap = new Map(usageData.map(item => [item.hero_id, item]));
                
                // Merge hero data with usage data using hero_id
                window.heroesData = heroData.data.map(hero => {
                    const usage = usageMap.get(hero.hero_id);  // Changed from hero.heroes.id to hero.hero_id
                    if (!usage) {
                    }
                    return {
                        ...hero,
                        usage: usage?.hero_usage_pct || 0
                    };
                });
                
                displayHeroData(window.heroesData);
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        // Add Supabase client initialization at the top of your file
        const supabaseUrl = 'https://hhcuqhvmzwmehdsaamhn.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoY3VxaHZtendtZWhkc2FhbWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzIwMTIsImV4cCI6MjA1MDU0ODAxMn0.xJNGoFLnpnmQGLj8RY_4VLmefPmFzuOyiVHLvFtPkkE';
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);

        async function fetchTacticHeroUsage() {
            try {
                const { data, error } = await supabaseClient
                    .from('vwtactic_hero_usage')
                    .select('hero_id,hero_usage_count,hero_usage_pct');

                if (error) {
                    throw error;
                }

                // Store data globally for later use
                window.tacticHeroUsageData = data;
                return data;
            } catch (error) {
                console.error('Error fetching hero usage data:', error);
                return [];
            }
        }

        async function fetchTacticData() {
            try {
                const { data, error } = await supabaseClient
                    .from('vwtactics')
                    .select('config_name,config_duration,config_salary_cap,payout_structure_price_pool,payout_structure_max_tickets,start_date,end_date,total_players')
                    .single();

                if (error) throw error;

                // Format dates
                const startDate = new Date(data.start_date);
                const endDate = new Date(data.end_date);
                const dateFormatOptions = { weekday: 'short', month: 'short', day: 'numeric' };
                const formattedDateRange = `${startDate.toLocaleDateString('en-US', dateFormatOptions)} - ${endDate.toLocaleDateString('en-US', dateFormatOptions)}`;

                // Update all summary items
                document.getElementById('tacticName').textContent = data.config_name;
                document.getElementById('tacticDuration').textContent = `${data.config_duration} hours`;
                document.getElementById('tacticDates').textContent = formattedDateRange;

                // Add the new details to the tactic-details div
                document.querySelector('.tactic-details').innerHTML += `
                    <div class="tactic-detail">
                        <i class="fas fa-trophy"></i>
                        <span>$${data.payout_structure_price_pool}</span>
                    </div>
                    <div class="tactic-detail">
                        <span>${data.total_players}</span>
                        <i class="fas fa-users"></i>
                        <span>/</span>
                        <span>${data.payout_structure_max_tickets}</span>
                        <i class="fas fa-ticket"></i>
                    </div>
                    <div class="tactic-detail">
                        <i class="fas fa-coins"></i>
                        <span>${data.config_salary_cap} Cap</span>
                    </div>
                `;

            } catch (error) {
                console.error('Error fetching tactic data:', error);
            }
        }

        function formatViews(views) {
            if (views >= 1000000) {
                return (views / 1000000).toFixed(1) + 'M';
            } else if (views >= 1000) {
                return Math.round(views / 1000) + 'K';
            }
            return views;
        }

        // Add this function before getColorForRank
        function lerp(start, end, amt) {
            return start * (1 - amt) + end * amt;
        }

        // Cache color calculations
        const colorCache = new Map();

        function getColorForRank(value, maxValue = 1000, higherIsBetter = true) {
            const cacheKey = `${value}_${maxValue}_${higherIsBetter}`;
            if (colorCache.has(cacheKey)) {
                return colorCache.get(cacheKey);
            }

            let ratio;
            if (higherIsBetter) {
                ratio = Math.min(value / maxValue, 1);
            } else {
                // For ranks - lower is better
                ratio = 1 - (Math.min(value / maxValue, 1));
            }

            if (ratio < 0.5) {
                // Red to Orange/Gold transition
                const r = Math.round(lerp(215, 230, ratio * 2));
                const g = Math.round(lerp(48, 140, ratio * 2));  // Reduced from 224 to 140
                const b = Math.round(lerp(39, 0, ratio * 2));    // Changed to 0 for more saturation
                const color = `rgb(${r}, ${g}, ${b})`;
                colorCache.set(cacheKey, color);
                return color;
            } else {
                // Orange/Gold to Green transition
                const r = Math.round(lerp(230, 44, (ratio - 0.5) * 2));
                const g = Math.round(lerp(140, 162, (ratio - 0.5) * 2));
                const b = Math.round(lerp(0, 95, (ratio - 0.5) * 2));
                const color = `rgb(${r}, ${g}, ${b})`;
                colorCache.set(cacheKey, color);
                return color;
            }
        }

        function getOwnershipColor(percentage) {
            // Define the color stops from the gradient (left to right)
            const colorStops = [
                '#9e0142', // Deep red
                '#d53e4f', // Red
                '#f46d43', // Orange-red
                '#fdae61', // Light orange
                '#fee08b', // Light yellow
                '#ffffbf', // Pale yellow
                '#e6f598', // Light green
                '#abdda4', // Green
                '#66c2a5', // Teal
                '#3288bd', // Blue
                '#5e4fa2'  // Purple
            ].reverse(); // Reverse so purple is highest

            // Normalize the percentage to 0-1 range
            const ratio = Math.min(percentage / 100, 1);
            
            // Find the appropriate color range based on ratio
            const colorIndex = Math.min(Math.floor(ratio * (colorStops.length - 1)), colorStops.length - 2);
            const colorRatio = (ratio * (colorStops.length - 1)) - colorIndex;

            // Get the two colors to interpolate between
            const color1 = colorStops[colorIndex];
            const color2 = colorStops[colorIndex + 1];

            // Convert hex to RGB for interpolation
            const rgb1 = hexToRgb(color1);
            const rgb2 = hexToRgb(color2);

            // Interpolate between the colors
            const r = Math.round(lerp(rgb1.r, rgb2.r, colorRatio));
            const g = Math.round(lerp(rgb1.g, rgb2.g, colorRatio));
            const b = Math.round(lerp(rgb1.b, rgb2.b, colorRatio));

            return `rgb(${r}, ${g}, ${b})`;
        }

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function displayHeroData(heroes) {
            const tableBody = document.getElementById('heroTableBody');
            const sortedHeroes = sortData(heroes, currentSort.column, currentSort.ascending);
            tableBody.innerHTML = '';

            // Calculate value scores for each hero once
            const heroValues = sortedHeroes.map(hero => ({
                ...hero,
                valueScore: parseFloat(hero.fantasy_score) / parseFloat(hero.salary_cap)
            }));

            // Find min and max values using the raw valueScore
            const minScore = Math.min(...heroValues.map(h => h.valueScore));
            const maxScore = Math.max(...heroValues.map(h => h.valueScore));
            const range = maxScore - minScore;

            heroValues.forEach(hero => {
                const salaryCapRounded = parseFloat(hero.salary_cap).toFixed(1);
                const normalizedScore = (hero.valueScore - minScore) / range;
                
                // Determine score category using normalized value
                let scoreClass;
                if (normalizedScore < 0.33) {
                    scoreClass = 'score-low';
                } else if (normalizedScore < 0.66) {
                    scoreClass = 'score-medium';
                } else {
                    scoreClass = 'score-high';
                }
                
                // Display value as X.X multiplier
                const displayScorePerSalary = (hero.valueScore / 100).toFixed(1);

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="text-align: center; font-weight: 500;">
                        ${hero.current_rank}
                    </td>
                    <td class="hero-cell">
                        <img src="${hero.heroes.profile_image_url_https}" alt="${hero.heroes.name}" class="hero-image">
                        ${hero.heroes.name}
                        <a href="https://x.com/${hero.heroes.handle}" target="_blank" style="margin-left: 4px; text-decoration: none;">
                            <i class="fa-brands fa-x-twitter" style="font-size: 0.8em; color: #777;"></i>
                        </a>
                        <div style="display: flex; align-items: center; gap: 2px; background: transparent;border-radius: 10px; padding: 1px 5px;">
                            <i class="fas fa-users" style="font-size: 8px; color: #1DA1F2;"></i>
                            <span style="font-size: 10px; font-weight: bold; color: #1DA1F2;">${formatViews(hero.heroes.followers_count)}</span>
                        </div>
                    </td>
                    <td class="number-cell">
                        <span style="background-color: ${getColorForRank(parseFloat(hero.fantasy_score), Math.max(...heroes.map(h => parseFloat(h.fantasy_score))), true)}; 
                                     border-radius: 4px; 
                                     padding: 4px 8px; 
                                     color: white; 
                                     font-weight: 500;">
                            ${parseFloat(hero.fantasy_score).toFixed(1)}
                        </span>
                    </td>
                    <td class="center-cell">
                        <div class="salary-display">
                            <span class="salary-value ${
                                parseFloat(hero.salary_cap) <= 3 ? 'salary-low' : 
                                parseFloat(hero.salary_cap) <= 6 ? 'salary-medium' : 
                                'salary-high'
                            }">${salaryCapRounded}</span>
                        </div>
                    </td>
                    <td>
                        <span class="score-container ${scoreClass}" 
                              title="${parseFloat(hero.fantasy_score).toFixed(2)} / ${hero.salary_cap} = ${hero.valueScore.toFixed(2)}">
                            ${displayScorePerSalary}X
                        </span>
                    </td>
                    <td class="number-cell">
                        <span style="background-color: ${getOwnershipColor(parseFloat(hero.usage))}; 
                                    border-radius: 4px; 
                                    padding: 4px 8px; 
                                    color: white; 
                                    font-weight: 500;">
                            ${hero.usage.toFixed(0)}%
                        </span>
                    </td>
                    <td class="number-cell">${hero.views.toLocaleString()}</td>
                    <td class="number-cell">${hero.tweet_count}</td>
                `;
                tableBody.appendChild(row);
            });
        }

        // Load data when page loads
        document.addEventListener('DOMContentLoaded', () => {
            fetchTacticData();
            fetchHeroData();
            fetchTacticHeroUsage();
        });

        // Modify the column click handler
        document.querySelectorAll('#heroScores th').forEach(header => {
            header.addEventListener('click', () => {
                const column = header.dataset.sort;
                if (currentSort.column === column) {
                    currentSort.ascending = !currentSort.ascending;
                } else {
                    currentSort.column = column;
                    currentSort.ascending = false;  // Always start with descending when changing columns
                }
                displayHeroData(window.heroesData);
            });
        });
    </script>
</body>
</html>