<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXJ5Q7LKKE"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LXJ5Q7LKKE');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Stats</title>
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" as="style">
    <link rel="stylesheet" href="./styles.css">
    <link rel="icon" type="image/png" href="icons/favicon.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .total-row {
            font-weight: bold;
            border-top: 2px solid #666;
            background-color: #f5f5f5;
        }
        
        /* Add modal styles */
        .modal-overlay {
            display: none; /* Initially hidden */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-button {
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #333;
            background-color: #222;
            color: white;
            width: 40px;  /* Fixed width for consistency */
        }

        .modal-button:hover {
            background-color: #333;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            position: relative;
            overflow-y: auto;
        }

        .close-button {
            position: absolute;
            right: 20px;
            top: 10px;
            font-size: 24px;
            cursor: pointer;
        }

        .close-button:hover {
            color: #666;
        }
    </style>
</head>
<body>
    <div class="title-container">
        <div style="text-align: center;">
            <h1 class="title-header" style="margin-bottom: 0;">
                <a href="index.html" class="home-link">
                    <i class="fas fa-home"></i>
                </a>
                Tournament Entry Stats
            </h1>
            <div id="tournamentStatus" style="font-size: 0.6em; color: #888; margin-top: 5px;">
                <script>
                    fetch('./data/tournaments/tournaments_stats.json')
                        .then(response => response.json())
                        .then(data => {
                            // Sort tournaments by tournament number and get the latest one
                            const latestTournament = Object.values(data)
                                .sort((a, b) => parseInt(b.tournament_number) - parseInt(a.tournament_number))[0];

                            document.getElementById('tournamentStatus').innerHTML = 
                                `${latestTournament.tournament_unique_key} | Deck Counts: Live`;
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            document.getElementById('tournamentStatus').innerHTML = 'Error loading tournament status';
                        });
                </script>
            </div>
        </div>
    </div>
    <div id="tableContainer" style="margin-top: 20px;"></div></div>

    <script>
        let charts = {}; // Add this at the top of your script to store chart instances

        function isNumeric(v) {
            return typeof v === 'number' && !isNaN(v);
        }
        function fmt(v) {
            return isNumeric(v) ? v.toLocaleString() : '-';
        }
        function safeSum(arr, key) {
            return arr.reduce((s, it) => s + (isNumeric(it[key]) ? it[key] : 0), 0);
        }

        async function fetchTournamentRegistrations() {
            try {
                const response = await fetch("https://api-v2.fantasy.top/tournaments/next-tournaments");
                const data = await response.json();

                const tournamentData = {
                    fetch_time: new Date().toISOString(),
                    tournaments: {}
                };

                // Log raw API response for debugging
                console.log('Raw API Response:', data);

                data.forEach(tournament => {
                    const tournamentNumber = tournament.tournament_number.toString(); // Convert to string
                    const playersCount = tournament.registered_players_count || 0;
                    const league = tournament.name ? 
                        tournament.name.replace(' Score', '').toLowerCase() : 
                        'unknown'; // Normalize league name and remove "Score" if present

                    // Create tournament entry if it doesn't exist
                    if (tournamentNumber && !tournamentData.tournaments[tournamentNumber]) {
                        tournamentData.tournaments[tournamentNumber] = {
                            tournament_number: tournamentNumber,
                            leagues: {}
                        };
                    }

                    // Add league data to the tournament
                    if (tournamentNumber && league) {
                        tournamentData.tournaments[tournamentNumber].leagues[league] = {
                            registered_players: playersCount
                        };
                    }
                });

                // Debug logging
                console.log('Processed Tournament Data:');
                Object.entries(tournamentData.tournaments).forEach(([tournamentNum, data]) => {
                    console.log(`\nMain ${tournamentNum}:`);
                    Object.entries(data.leagues).forEach(([league, stats]) => {
                        console.log(`  ${league}: ${stats.registered_players} players`);
                    });
                });

                return tournamentData;
            } catch (error) {
                console.error(`âœ— Error fetching tournament data:`, error);
                return null;
            }
        }

        async function fetchAndDisplayData() {
            try {
                // Fetch both data sources
                const timestamp = new Date().getTime();
                const [statsResponse, registrationData] = await Promise.all([
                    fetch(`/data/tournaments/tournaments_stats.json?_=${timestamp}`),
                    fetchTournamentRegistrations()
                ]);
                
                const data = await statsResponse.json();

                // Process the data and create HTML
                Object.entries(data).forEach(([tournamentKey, tournamentData]) => {
                    console.log(`Processing tournament: ${tournamentKey}`);
                    console.log(`Status: ${tournamentData.tournament_status}`);

                    if (tournamentData.tournament_status === 'not started' && registrationData) {
                        // Use tournament_number directly from the data
                        const tournamentNumber = tournamentData.tournament_number;
                        
                        console.log(`Using tournament number: ${tournamentNumber}`);
                        console.log(`Available registration data:`, registrationData.tournaments);

                        // Update player counts with registration data
                        tournamentData.leagues.forEach(league => {
                            console.log(`\nMatching league: ${league.league}`);
                            console.log(`Looking for match in registration data for tournament ${tournamentNumber}`);
                            
                            // Convert both league names to lowercase for comparison
                            const registrationMatch = registrationData.tournaments[tournamentNumber]?.leagues[league.league.toLowerCase()];
                            
                            console.log(`Registration match found:`, registrationMatch);

                            if (registrationMatch) {
                                console.log(`Updating deck count from ${league.deck_count} to ${registrationMatch.registered_players}`);
                                league.deck_count = registrationMatch.registered_players;
                                
                                // Update total deck count
                                const newTotal = Object.values(
                                    registrationData.tournaments[tournamentNumber].leagues
                                ).reduce((sum, reg) => sum + reg.registered_players, 0);
                                console.log(`Updating total deck count to ${newTotal}`);
                                tournamentData.total_deck_count = newTotal;
                            }
                        });
                    }
                });

                let html = '<table class="matrix-table">';
                
                // Header row with tournament names
                html += '<tr><th></th>'; // Empty corner cell
                Object.keys(data).forEach(tournamentKey => {
                    const [part1, part2] = tournamentKey.split('|');
                    html += `<th>${part1}${part2 ? '<br><span style="margin-top: 4px; display: inline-block">' + part2 + '</span>' : ''}</th>`;
                });
                html += '<th>Trend</th></tr>';
                
                // League rows
                html += `<tr><th colspan="${Object.keys(data).length + 2}">
                    Deck Counts By Leagues
                </th></tr>`;
                // Get all unique leagues
                const leagues = [...new Set(Object.values(data).flatMap(t => t.leagues.map(l => l.league)))];
                
                // Replace with manually sorted leagues
                const sortedLeagues = ["Diamond", "Platinum", "Gold", "Silver", "Bronze", "Reverse"];
                
                // League color mapping in a muted earthy tone
                const leagueColors = {
                    "diamond": "#a997b3",
                    "platinum": "#6a82a0",
                    "gold": "#d3b76e",
                    "silver": "#8e8e8e",
                    "bronze": "#a6744a",
                    "reverse": "#8ccf91"
                };
                
                sortedLeagues.forEach(league => {
                    const leagueLower = league.toLowerCase();
                    html += `<tr><td style="background-color: ${leagueColors[leagueLower]}40">
                        <img src="/icons/${leagueLower}.webp" alt="${league}" style="height: 20px; vertical-align: middle;">
                        <span style="color: ${leagueColors[leagueLower]}; margin-left: 5px; font-size: 1.1em; font-weight: bold;">${league}</span>
                    </td>`;
                    
                    let previousCount = null;
                    const values = []; // numeric values only for sparkline
                    Object.values(data).forEach(tournamentData => {
                        const leagueData = (tournamentData.leagues || []).find(l => l.league === league);
                        const currentCount = leagueData && isNumeric(leagueData.deck_count) ? leagueData.deck_count : null;

                        // push only numeric values for sparkline calculations
                        if (isNumeric(currentCount)) values.push(currentCount);

                        let changeHtml = '';
                        if (previousCount !== null && isNumeric(previousCount) && isNumeric(currentCount)) {
                            const change = currentCount - previousCount;
                            const color = change > 0 ? 'green' : change < 0 ? 'red' : 'gray';
                            changeHtml = `<br><span style="font-size: 0.7em; color: ${color}">${change > 0 ? '+' : ''}${change.toLocaleString()}</span>`;
                        }

                        html += `<td style="background-color: ${leagueColors[leagueLower]}40; vertical-align: top; padding-top: 8px;">
                            <span style="font-size: 1.1em">${fmt(currentCount)}</span>${changeHtml}
                        </td>`;

                        previousCount = isNumeric(currentCount) ? currentCount : previousCount;
                    });

                    // Add sparkline only when we have at least 2 numeric points (history)
                    if (values.length > 1) {
                        const sparklineWidth = 180;
                        const sparklineHeight = 40;
                        const max = Math.max(...values);
                        const min = Math.min(...values);
                        const range = (max - min) || 1;

                        const firstValue = values[0];
                        const lastValue = values[values.length - 1];

                        let sparkline = `<td style="padding: 0; background-color: ${leagueColors[leagueLower]}40"><svg width="${sparklineWidth}" height="${sparklineHeight}">
                            <polyline 
                                points="${values.map((value, index) => {
                                    const x = (index / (values.length - 1)) * (sparklineWidth - 80) + 40;
                                    const y = (sparklineHeight - 8) - ((value - min) / range) * (sparklineHeight - 16) + 4;
                                    return `${x},${y}`;
                                }).join(' ')}"
                                fill="none"
                                stroke="${leagueColors[leagueLower]}"
                                stroke-width="2"
                            />
                            <text x="2" y="${(sparklineHeight - 8) - ((firstValue - min) / range) * (sparklineHeight - 16) + 4}" fill="${leagueColors[leagueLower]}" font-size="10px" text-anchor="start" dy="4">${fmt(firstValue)}</text>
                            <text x="${sparklineWidth - 2}" y="${(sparklineHeight - 8) - ((lastValue - min) / range) * (sparklineHeight - 16) + 4}" fill="${leagueColors[leagueLower]}" font-size="10px" text-anchor="end" dy="4">${fmt(lastValue)}</text>
                        </svg></td>`;
                        html += sparkline + '</tr>';
                    } else {
                        // not enough history -> empty trend cell
                        html += `<td style="background-color: ${leagueColors[leagueLower]}40">-</td></tr>`;
                    }
                });
                
                // Add Leagues Total row with sparkline
                html += '<tr class="total-row"><td>Total Decks</td>';
                let previousTotal = null;
                const totalDeckValues = []; // Add this to collect values for sparkline
                Object.values(data).forEach(tournamentData => {
                    const total = safeSum(tournamentData.leagues || [], 'deck_count');
                    totalDeckValues.push(total); // Collect the total values
                    
                    let changeHtml = '';
                    if (previousTotal !== null) {
                        const change = total - previousTotal;
                        const color = change > 0 ? 'green' : change < 0 ? 'red' : 'gray';
                        changeHtml = `<br><span style="font-size: 0.7em; color: ${color}">${change > 0 ? '+' : ''}${change.toLocaleString()}</span>`;
                    }
                    html += `<td style="vertical-align: top; padding-top: 8px;">
                        <span style="font-size: 1.1em">${fmt(total)}</span>${changeHtml}
                    </td>`;
                    previousTotal = total;
                });
                
                // Add sparkline for Total Decks
                if (totalDeckValues.length > 1) {
                    const sparklineWidth = 180;
                    const sparklineHeight = 40;
                    const max = Math.max(...totalDeckValues);
                    const min = Math.min(...totalDeckValues);
                    const range = (max - min) || 1;
                    const firstValue = totalDeckValues[0];
                    const lastValue = totalDeckValues[totalDeckValues.length - 1];
                    
                    let sparkline = `<td style="padding: 0;"><svg width="${sparklineWidth}" height="${sparklineHeight}">
                        <polyline 
                            points="${totalDeckValues.map((value, index) => {
                                const x = (index / (totalDeckValues.length - 1)) * (sparklineWidth - 80) + 40;
                                const y = (sparklineHeight - 8) - ((value - min) / range) * (sparklineHeight - 16) + 4;
                                return `${x},${y}`;
                            }).join(' ')}"
                            fill="none"
                            stroke="white"
                            stroke-width="2"
                        />
                        <text x="2" y="${(sparklineHeight - 8) - ((firstValue - min) / range) * (sparklineHeight - 16) + 4}" fill="white" font-size="10px" text-anchor="start" dy="4">${fmt(firstValue)}</text>
                        <text x="${sparklineWidth - 2}" y="${(sparklineHeight - 8) - ((lastValue - min) / range) * (sparklineHeight - 16) + 4}" fill="white" font-size="10px" text-anchor="end" dy="4">${fmt(lastValue)}</text>
                    </svg></td>`;
                    html += sparkline + '</tr>';
                } else {
                    html += '<td>-</td></tr>';
                }
                
                // Add spacing between Deck Counts and Player Counts
                html += `<tr style="height: 30px; background-color: #000000 !important;"><td colspan="${Object.keys(data).length + 2}"></td></tr>`;
                
                // Player Count rows
                html += `<tr><th colspan="${Object.keys(data).length + 2}">
                    Player Counts By Leagues
                    <span onclick="openPlayerModal()" style="margin-left: 10px;">
                      Full History View:  <button class="modal-button"><i class="fas fa-chart-line"></i></button>
                    </span>
                </th></tr>`;
                
                // Use the same sorted leagues for player counts
                sortedLeagues.forEach(league => {
                    const leagueLower = league.toLowerCase();
                    html += `<tr><td style="background-color: ${leagueColors[leagueLower]}40">
                        <img src="/icons/${leagueLower}.webp" alt="${league}" style="height: 20px; vertical-align: middle;">
                        <span style="color: ${leagueColors[leagueLower]}; margin-left: 5px; font-size: 1.1em; font-weight: bold;">${league}</span>
                    </td>`;
                    
                    let previousCount = null;
                    const values = [];
                    Object.values(data).forEach(tournamentData => {
                        const leagueData = (tournamentData.leagues || []).find(l => l.league === league);
                        const currentCount = leagueData && isNumeric(leagueData.player_count) ? leagueData.player_count : null;

                        if (isNumeric(currentCount)) values.push(currentCount);

                        if (isNumeric(currentCount)) {
                            let changeHtml = '';
                            if (previousCount !== null && isNumeric(previousCount)) {
                                const change = currentCount - previousCount;
                                const color = change > 0 ? 'green' : change < 0 ? 'red' : 'gray';
                                changeHtml = `<br><span style="font-size: 0.7em; color: ${color}">${change > 0 ? '+' : ''}${change.toLocaleString()}</span>`;
                            }
                            html += `<td style="background-color: ${leagueColors[leagueLower]}40; vertical-align: top; padding-top: 8px;">
                                <span style="font-size: 1.1em">${fmt(currentCount)}</span>${changeHtml}
                            </td>`;
                            previousCount = currentCount;
                        } else {
                            html += `<td style="background-color: ${leagueColors[leagueLower]}40; vertical-align: top; padding-top: 8px;">
                                <span style="font-size: 1.1em">-</span>
                            </td>`;
                        }
                    });

                    if (values.length > 1) {
                        const sparklineWidth = 180;
                        const sparklineHeight = 40;
                        const max = Math.max(...values);
                        const min = Math.min(...values);
                        const range = (max - min) || 1;
                        const firstValue = values[0];
                        const lastValue = values[values.length - 1];
                        let sparkline = `<td style="padding: 0; background-color: ${leagueColors[leagueLower]}40"><svg width="${sparklineWidth}" height="${sparklineHeight}">
                            <polyline points="${values.map((value, index) => {
                                const x = (index / (values.length - 1)) * (sparklineWidth - 80) + 40;
                                const y = (sparklineHeight - 8) - ((value - min) / range) * (sparklineHeight - 16) + 4;
                                return `${x},${y}`;
                            }).join(' ')}" fill="none" stroke="${leagueColors[leagueLower]}" stroke-width="2" />
                            <text x="2" y="${(sparklineHeight - 8) - ((firstValue - min) / range) * (sparklineHeight - 16) + 4}" fill="${leagueColors[leagueLower]}" font-size="10px" text-anchor="start" dy="4">${fmt(firstValue)}</text>
                            <text x="${sparklineWidth - 2}" y="${(sparklineHeight - 8) - ((lastValue - min) / range) * (sparklineHeight - 16) + 4}" fill="${leagueColors[leagueLower]}" font-size="10px" text-anchor="end" dy="4">${fmt(lastValue)}</text>
                        </svg></td>`;
                        html += sparkline + '</tr>';
                    } else {
                        html += `<td style="background-color: ${leagueColors[leagueLower]}40">-</td></tr>`;
                    }
                });
                
                // Add Total Players row with sparkline
                html += '<tr class="total-row"><td>Total Players</td>';
                let previousPlayerTotal = null;
                const totalPlayerValues = []; // Add this to collect values for sparkline
                Object.values(data).forEach(tournamentData => {
                    const total = tournamentData.total_player_count !== undefined ? tournamentData.total_player_count : 0;
                    if (total !== 0) totalPlayerValues.push(total); // Only collect non-zero values
                    
                    let changeHtml = '';
                    if (total !== 0 && previousPlayerTotal !== null) {
                        const change = total - previousPlayerTotal;
                        const color = change > 0 ? 'green' : change < 0 ? 'red' : 'gray';
                        changeHtml = `<br><span style="font-size: 0.7em; color: ${color}">${change > 0 ? '+' : ''}${change.toLocaleString()}</span>`;
                    }
                    
                    html += `<td style="vertical-align: top; padding-top: 8px;">
                        <span style="font-size: 1.1em">${total !== 0 ? total.toLocaleString() : ''}</span>${changeHtml}
                    </td>`;
                    
                    if (total !== 0) previousPlayerTotal = total;
                });

                // Add sparkline for Total Players
                if (totalPlayerValues.length > 1) {
                    const sparklineWidth = 180;
                    const sparklineHeight = 40;
                    const max = Math.max(...totalPlayerValues);
                    const min = Math.min(...totalPlayerValues);
                    const range = (max - min) || 1;
                    const firstValue = totalPlayerValues[0];
                    const lastValue = totalPlayerValues[totalPlayerValues.length - 1];
                    
                    let sparkline = `<td style="padding: 0;"><svg width="${sparklineWidth}" height="${sparklineHeight}">
                        <polyline 
                            points="${totalPlayerValues.map((value, index) => {
                                const x = (index / (totalPlayerValues.length - 1)) * (sparklineWidth - 80) + 40;
                                const y = (sparklineHeight - 8) - ((value - min) / range) * (sparklineHeight - 16) + 4;
                                return `${x},${y}`;
                            }).join(' ')}"
                            fill="none"
                            stroke="white"
                            stroke-width="2"
                        />
                        <text x="2" y="${(sparklineHeight - 8) - ((firstValue - min) / range) * (sparklineHeight - 16) + 4}" fill="white" font-size="10px" text-anchor="start" dy="4">${fmt(firstValue)}</text>
                        <text x="${sparklineWidth - 2}" y="${(sparklineHeight - 8) - ((lastValue - min) / range) * (sparklineHeight - 16) + 4}" fill="white" font-size="10px" text-anchor="end" dy="4">${fmt(lastValue)}</text>
                    </svg></td>`;
                    html += sparkline + '</tr>';
                } else {
                    html += '<td>-</td></tr>';
                }
                
                // Add spacing between sections
                html += `<tr style="height: 30px; background-color: #000000 !important;"><td colspan="${Object.keys(data).length + 2}"></td></tr>`;
                
                
                // Add this new section for Card Counts By Hero Rarity
                html += '<tr><th colspan="' + (Object.keys(data).length + 2) + '">Card Counts By Rarity</th></tr>';
                // Get all unique rarity values
                const rarities = [...new Set(Object.values(data).flatMap(t => t.rarity ? t.rarity.map(r => r.hero_rarity) : []))];
                
                // Define the desired order of rarities
                const rarityOrder = ["legendary", "epic", "rare", "common"];
                // Sort rarities based on the defined order (lowercased)
                rarities.sort((a, b) => rarityOrder.indexOf(a.toLowerCase()) - rarityOrder.indexOf(b.toLowerCase()));
                
                const rarityColors = {
                    "common": "#93FF01",
                    "rare": "#00FFDF",
                    "epic": "#F1A3FD",
                    "legendary": "#FBE7FF"
                };

                rarities.forEach(rarity => {
                    html += `<tr style="background-color: ${rarityColors[rarity.toLowerCase()]}25;">
                        <td style="background-color: ${rarityColors[rarity.toLowerCase()]}25; color: ${rarityColors[rarity.toLowerCase()] || '#000'};">
                            ${rarity.charAt(0).toUpperCase() + rarity.slice(1)}
                        </td>`;
                    const values = [];
                    Object.values(data).forEach(tournamentData => {
                        const rarityData = (tournamentData.rarity || []).find(r => r.hero_rarity && r.hero_rarity.toLowerCase() === (rarity || '').toLowerCase());
                        const cardCount = rarityData && isNumeric(rarityData.card_count) ? rarityData.card_count : null;
                        html += `<td style="background-color: ${rarityColors[rarity.toLowerCase()]}25;">${fmt(cardCount)}</td>`;
                        if (isNumeric(cardCount)) values.push(cardCount);
                    });

                    if (values.length > 1) {
                        const sparklineWidth = 180;
                        const sparklineHeight = 40;
                        const max = Math.max(...values);
                        const min = Math.min(...values);
                        const range = (max - min) || 1;
                        const firstValue = values[0];
                        const lastValue = values[values.length - 1];
                        let sparkline = `<td style="padding: 0; background-color: ${rarityColors[rarity.toLowerCase()]}25"><svg width="${sparklineWidth}" height="${sparklineHeight}">
                            <polyline points="${values.map((value, index) => {
                                const x = (index / (values.length - 1)) * (sparklineWidth - 80) + 40;
                                const y = (sparklineHeight - 8) - ((value - min) / range) * (sparklineHeight - 16) + 4;
                                return `${x},${y}`;
                            }).join(' ')}" fill="none" stroke="${rarityColors[rarity.toLowerCase()]}" stroke-width="2" />
                            <text x="2" y="${(sparklineHeight - 8) - ((firstValue - min) / range) * (sparklineHeight - 16) + 4}" fill="${rarityColors[rarity.toLowerCase()]}" font-size="10px" text-anchor="start" dy="4">${fmt(firstValue)}</text>
                            <text x="${sparklineWidth - 2}" y="${(sparklineHeight - 8) - ((lastValue - min) / range) * (sparklineHeight - 16) + 4}" fill="${rarityColors[rarity.toLowerCase()]}" font-size="10px" text-anchor="end" dy="4">${fmt(lastValue)}</text>
                        </svg></td>`;
                        html += sparkline + '</tr>';
                    } else {
                        html += `<td style="background-color: ${rarityColors[rarity.toLowerCase()]}25">-</td></tr>`;
                    }
                });
                
                // Add Rarity Total row
                html += '<tr class="total-row"><td>Total Cards</td>';
                Object.values(data).forEach(tournamentData => {
                    const total = tournamentData.rarity.reduce((sum, rarity) => sum + rarity.card_count, 0);
                    html += `<td>${total.toLocaleString()}</td>`;
                });
                html += '<td></td></tr>';
                html += '</table>';
                
                document.getElementById('tableContainer').innerHTML = html;
            } catch (error) {
                console.error('Error fetching or displaying data:', error);
                document.getElementById('tableContainer').innerHTML = 'Error loading data';
            }
        }

        fetchAndDisplayData();
    </script>

    <div id="modalOverlay" class="modal-overlay" onclick="closeModal()">
        <div class="modal-content" onclick="event.stopPropagation()" style="width: 90%; max-width: 1200px; height: 90vh; padding: 20px; background-color: #000; overflow-x: hidden;">
            <span class="close-button" onclick="closeModal()" style="color: white;">&times;</span>
            <h2 style="color: white;">Decks by League</h2>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(3, minmax(250px, 1fr)); gap: 5px; height: calc(100% - 60px);">
                <div style="height: 250px;">
                    <canvas id="diamondChart"></canvas>
                </div>
                <div style="height: 250px;">
                    <canvas id="goldChart"></canvas>
                </div>
                <div style="height: 250px;">
                    <canvas id="silverChart"></canvas>
                </div>
                <div style="height: 250px;">
                    <canvas id="bronzeChart"></canvas>
                </div>
                <div style="height: 250px;">
                    <canvas id="reverseChart"></canvas>
                </div>
                <div style="height: 250px;"></div>
            </div>
        </div>
    </div>

    <div id="playerModalOverlay" class="modal-overlay" onclick="closePlayerModal()">
        <div class="modal-content" onclick="event.stopPropagation()" style="width: 95%; max-width: 1400px; height: 60vh; padding: 20px; background-color: #000; overflow-x: hidden;">
            <span class="close-button" onclick="closePlayerModal()" style="color: white;">&times;</span>
            <h2 style="color: white;">Player & Deck History</h2>
            <div style="height: calc(100% - 60px);">
                <canvas id="playerDeckHistoryChart" style="height: 100%;"></canvas>
            </div>
        </div>
    </div>

    <script>
        function openModal() {
            document.getElementById('modalOverlay').style.display = 'flex';
            createLeagueCharts();
        }

        async function createLeagueCharts() {
            try {
                // Destroy existing charts first
                Object.values(charts).forEach(chart => {
                    if (chart) chart.destroy();
                });
                charts = {}; // Reset the charts object

                const timestamp = new Date().getTime(); // Get current timestamp
                const response = await fetch(`/data/tournaments/tournaments_stats.json?_=${timestamp}`);
                const data = await response.json();

                // Sort tournaments by name
                const sortedTournaments = Object.entries(data).sort(([a], [b]) => a.localeCompare(b));
                const labels = sortedTournaments.map(([name]) => name);

                ["Diamond", "Platinum", "Gold", "Silver", "Bronze", "Reverse"].forEach(league => {
                    const leagueLower = league.toLowerCase();
                    const chartData = sortedTournaments.map(([_, tournamentData]) => {
                        const leagueData = tournamentData.leagues.find(l => l.league === league);
                        return leagueData ? leagueData.deck_count : 0;
                    });

                    const ctx = document.getElementById(`${leagueLower}Chart`);
                    const chartOptions = {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: league,
                                font: { size: 24 },
                                color: leagueColors[leagueLower],
                                padding: { top: 10, bottom: 30 }
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            x: {
                                display: false
                            },
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    color: 'white',
                                    font: { size: 14 }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                },
                                suggestedMax: Math.max(...chartData) * 1.15
                            }
                        },
                        plugins: [{
                            afterDraw: (chart) => {
                                const ctx = chart.ctx;
                                ctx.save();
                                ctx.font = '12px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillStyle = 'white';

                                const dataset = chart.data.datasets[0];
                                dataset.data.forEach((value, index) => {
                                    const meta = chart.getDatasetMeta(0);
                                    const bar = meta.data[index];
                                    
                                    // Draw deck count inside bar
                                    ctx.fillText(
                                        value.toLocaleString(),
                                        bar.x,
                                        bar.y + (bar.height / 2)
                                    );

                                    // Calculate and draw % change
                                    if (index > 0) {
                                        const previousValue = dataset.data[index - 1];
                                        const percentChange = ((value - previousValue) / previousValue * 100).toFixed(1);
                                        const changeText = `${percentChange > 0 ? '+' : ''}${percentChange}%`;
                                        const changeColor = percentChange > 0 ? '#4CAF50' : percentChange < 0 ? '#F44336' : '#888';
                                        
                                        ctx.fillStyle = changeColor;
                                        ctx.fillText(
                                            changeText,
                                            bar.x,
                                            bar.y - 5
                                        );
                                        ctx.fillStyle = 'white'; // Reset color
                                    }
                                });
                                ctx.restore();
                            }
                        }]
                    };

                    // Store the new chart instance
                    charts[leagueLower] = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: `${league} League Decks`,
                                data: chartData,
                                backgroundColor: leagueColors[leagueLower],
                                borderColor: leagueColors[leagueLower],
                                borderWidth: 1
                            }]
                        },
                        options: chartOptions
                    });
                });
            } catch (error) {
                console.error('Error creating charts:', error);
            }
        }

        function closeModal() {
            document.getElementById('modalOverlay').style.display = 'none';
            // Destroy deck count charts
            Object.values(charts).forEach(chart => {
                if (chart && chart !== charts.playerDeckHistory) chart.destroy();
            });
            // Keep playerDeckHistory chart in the charts object but remove others
            const playerChart = charts.playerDeckHistory;
            charts = {};
            if (playerChart) charts.playerDeckHistory = playerChart;
        }

        function openPlayerModal() {
            document.getElementById('playerModalOverlay').style.display = 'flex';
            createPlayerDeckHistoryChart();
        }

        async function createPlayerDeckHistoryChart() {
            try {
                // Destroy existing chart if it exists
                if (charts.playerDeckHistory) {
                    charts.playerDeckHistory.destroy();
                }

                const timestamp = new Date().getTime();
                const response = await fetch(`/data/tournaments/deck_player_history.json?_=${timestamp}`);
                const data = await response.json();

                // Sort tournaments by start_timestamp
                const sortedTournaments = Object.entries(data).sort(([, a], [, b]) => 
                    new Date(a.start_timestamp) - new Date(b.start_timestamp)
                );

                const labels = sortedTournaments.map(([tournamentKey]) => tournamentKey);
                const playerData = sortedTournaments.map(([, tournamentData]) => tournamentData.unique_player_count);
                const deckData = sortedTournaments.map(([, tournamentData]) => tournamentData.total_deck_count);

                const ctx = document.getElementById('playerDeckHistoryChart');
                
                charts.playerDeckHistory = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Unique Players',
                            data: playerData,
                            backgroundColor: 'rgba(75, 192, 192, 0.8)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1,
                            yAxisID: 'y'
                        }, {
                            label: 'Total Decks',
                            data: deckData,
                            backgroundColor: 'rgba(255, 159, 64, 0.8)',
                            borderColor: 'rgba(255, 159, 64, 1)',
                            borderWidth: 1,
                            yAxisID: 'y1'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Tournament Player & Deck Count History',
                                font: { size: 20 },
                                color: 'white',
                                padding: { top: 10, bottom: 20 }
                            },
                            legend: {
                                labels: {
                                    color: 'white',
                                    font: { size: 14 }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    afterBody: function(context) {
                                        const index = context[0].dataIndex;
                                        const tournamentData = sortedTournaments[index][1];
                                        return `Decks per Player: ${tournamentData.decks_per_player}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                ticks: {
                                    color: 'white',
                                    font: { size: 10 },
                                    maxRotation: 45,
                                    minRotation: 45
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.1)'
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Unique Players',
                                    color: 'rgba(75, 192, 192, 1)',
                                    font: { size: 14 }
                                },
                                ticks: {
                                    color: 'rgba(75, 192, 192, 1)',
                                    font: { size: 12 }
                                },
                                grid: {
                                    color: 'rgba(75, 192, 192, 0.2)'
                                },
                                beginAtZero: true
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Total Decks',
                                    color: 'rgba(255, 159, 64, 1)',
                                    font: { size: 14 }
                                },
                                ticks: {
                                    color: 'rgba(255, 159, 64, 1)',
                                    font: { size: 12 }
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        },
                        plugins: [{
                            afterDraw: (chart) => {
                                const ctx = chart.ctx;
                                ctx.save();
                                ctx.font = '10px Arial';
                                ctx.textAlign = 'center';

                                // Draw values on top of bars
                                chart.data.datasets.forEach((dataset, datasetIndex) => {
                                    const meta = chart.getDatasetMeta(datasetIndex);
                                    meta.data.forEach((bar, index) => {
                                        const value = dataset.data[index];
                                        ctx.fillStyle = dataset.borderColor;
                                        
                                        if (datasetIndex === 0) { // Players - show above bar
                                            ctx.fillText(
                                                value.toLocaleString(),
                                                bar.x,
                                                bar.y - 5
                                            );
                                        } else { // Decks - show inside bar at top
                                            ctx.fillText(
                                                value.toLocaleString(),
                                                bar.x,
                                                bar.y + 15
                                            );
                                        }
                                    });
                                });
                                ctx.restore();
                            }
                        }]
                    }
                });
            } catch (error) {
                console.error('Error creating player/deck history chart:', error);
            }
        }

        function closePlayerModal() {
            document.getElementById('playerModalOverlay').style.display = 'none';
            if (charts.playerDeckHistory) {
                charts.playerDeckHistory.destroy();
                delete charts.playerDeckHistory;
            }
        }
    </script>
</body>
</html>