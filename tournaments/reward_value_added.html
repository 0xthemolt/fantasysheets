<!DOCTYPE html>
<html>
<head>
    <title>Tournament Rewards Value Added</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXJ5Q7LKKE"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LXJ5Q7LKKE');
    </script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../../styles.css?v=8e4c2f">
    <link rel="icon" type="image/png" href="../../icons/favicon.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        .league-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            border-bottom: 2px solid #555;
        }
        
        .league-tab {
            padding: 10px 20px;
            background: #444;
            color: white;
            cursor: pointer;
            border: none;
            border-radius: 5px 5px 0 0;
            transition: background 0.3s;
        }
        
        .league-tab.active {
            background: #666;
            border-bottom: 2px solid #666;
        }
        
        .league-tab:hover {
            background: #555;
        }
        
    </style>
</head>
<body>
    <div class="title-container">
        <h1 class="title-header">
            <a href="../../index.html" class="home-link">
                <i class="fas fa-home"></i>
            </a>
            Tournament Rewards Value Added Matrix
        </h1>
    </div>

    <div class="league-tabs" id="leagueTabs">
        <!-- Tabs will be populated dynamically -->
    </div>

    <div class="matrix-container">
        <div id="loading" class="loading">
            <i class="fas fa-spinner fa-spin"></i> Loading tournament data...
        </div>
        <table class="matrix-table" id="matrixTable" style="display: none;">
            <thead id="tableHeader">
                <!-- Headers will be populated dynamically -->
            </thead>
            <tbody id="tableBody">
                <!-- Data will be populated dynamically -->
            </tbody>
        </table>
        <div id="noData" class="no-data" style="display: none;">
            No data available for the selected league.
        </div>
    </div>

    <script>
        // Initialize Supabase client
        const supabaseUrl = 'https://hhcuqhvmzwmehdsaamhn.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoY3VxaHZtendtZWhkc2FhbWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzIwMTIsImV4cCI6MjA1MDU0ODAxMn0.xJNGoFLnpnmQGLj8RY_4VLmefPmFzuOyiVHLvFtPkkE';
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);

        let allData = [];
        let currentLeague = null;
        let currentSort = { column: 'median', direction: 'desc' };
        let colorScale = { min: 0, max: 1 }; // Add this missing variable

        // Fetch data from Supabase - ADD MORE DEBUGGING
        async function fetchRewardsData() {
            try {
                console.log('Starting to fetch rewards data...');
                
                const { data, error } = await supabaseClient
                    .from('rewardsvalueadded')
                    .select(`
                        league,
                        tournament_number,
                        hero_handle,
                        hero_stars,
                        reward_value_added
                    `)

                if (error) {
                    console.error('Detailed error:', error);
                    
                    document.getElementById('loading').innerHTML = `
                        <div style="color: #f87171;">
                            <i class="fas fa-exclamation-triangle"></i> 
                            Error loading data: ${error.message}
                        </div>
                    `;
                    return;
                }

                console.log('Fetched data:', data.length, 'records');
                console.log('Sample records:', data.slice(0, 10));
                
                // Debug: Show unique leagues and heroes
                const uniqueLeagues = [...new Set(data.map(row => row.league))];
                const uniqueHeroes = [...new Set(data.map(row => row.hero_handle))];
                console.log('Unique leagues found:', uniqueLeagues);
                console.log('Total unique heroes:', uniqueHeroes.length);
                console.log('Heroes list:', uniqueHeroes.slice(0, 20)); // Show first 20
                
                allData = data;
                setupLeagueTabs();
                
            } catch (err) {
                console.error('Exception while fetching data:', err);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #f87171;">
                        <i class="fas fa-exclamation-triangle"></i> 
                        Network error: ${err.message}
                    </div>
                `;
            }
        }

        // Setup league tabs
        function setupLeagueTabs() {
            const leagues = [...new Set(allData.map(row => row.league))].sort();
            const tabsContainer = document.getElementById('leagueTabs');
            
            tabsContainer.innerHTML = '';
            
            leagues.forEach(league => {
                const tab = document.createElement('button');
                tab.className = 'league-tab';
                tab.textContent = league;
                tab.onclick = () => selectLeague(league);
                tabsContainer.appendChild(tab);
            });
            
            // Select first league by default
            if (leagues.length > 0) {
                selectLeague(leagues[0]);
            }
        }

        // Select a league and render matrix
        function selectLeague(league) {
            currentLeague = league;
            
            // Update active tab
            document.querySelectorAll('.league-tab').forEach(tab => {
                tab.classList.toggle('active', tab.textContent === league);
            });
            
            renderMatrix(league);
        }

        // Render matrix for selected league
        function renderMatrix(league) {
            console.log('Rendering matrix for league:', league);
            const leagueData = allData.filter(row => row.league === league);
            console.log('Records for this league:', leagueData.length);
            
            if (leagueData.length === 0) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('matrixTable').style.display = 'none';
                document.getElementById('noData').style.display = 'block';
                return;
            }

            // Get unique heroes and tournament numbers
            const heroes = [...new Set(leagueData.map(row => row.hero_handle))].sort();
            const tournamentNumbers = [...new Set(leagueData.map(row => row.tournament_number))].sort((a, b) => a - b);

            console.log('Heroes in this league:', heroes.length, heroes);
            console.log('Tournament numbers:', tournamentNumbers);

            // Create matrix data structure and store hero stars per tournament
            const matrix = {};
            const starsMatrix = {};
            heroes.forEach(hero => {
                matrix[hero] = {};
                starsMatrix[hero] = {};
                
                tournamentNumbers.forEach(tournNum => {
                    matrix[hero][tournNum] = 0;
                    starsMatrix[hero][tournNum] = 0;
                });
            });

            // Populate matrix with data and stars
            leagueData.forEach(row => {
                if (matrix[row.hero_handle] && matrix[row.hero_handle].hasOwnProperty(row.tournament_number)) {
                    matrix[row.hero_handle][row.tournament_number] += row.reward_value_added || 0;
                    starsMatrix[row.hero_handle][row.tournament_number] = row.hero_stars || 0;
                }
            });

            // Calculate totals and medians
            const heroTotals = heroes.map(hero => {
                const values = tournamentNumbers.map(tournNum => matrix[hero][tournNum] || 0);
                const total = values.reduce((sum, val) => sum + val, 0);
                const median = calculateMedian(values);
                return { hero, total, median, values };
            });

            // Calculate independent color scales
            const matrixValues = [];
            const totalValues = [];
            const medianValues = [];

            heroes.forEach(hero => {
                tournamentNumbers.forEach(tournNum => {
                    matrixValues.push(matrix[hero][tournNum] || 0);
                });
            });

            heroTotals.forEach(({ total, median }) => {
                totalValues.push(total);
                medianValues.push(median);
            });

            const colorScales = {
                matrix: {
                    min: Math.min(...matrixValues),
                    max: Math.max(...matrixValues)
                },
                total: {
                    min: Math.min(...totalValues),
                    max: Math.max(...totalValues)
                },
                median: {
                    min: Math.min(...medianValues),
                    max: Math.max(...medianValues)
                }
            };

            console.log('Color scales:', colorScales);

            // Sort by median descending initially
            currentSort = { column: 'median', direction: 'desc' };
            const sortedHeroTotals = sortHeroes(heroTotals, currentSort.column, currentSort.direction);

            console.log('Hero totals calculated:', sortedHeroTotals.length);

            // Render table with independent color scales
            renderTable(sortedHeroTotals, tournamentNumbers, matrix, starsMatrix, colorScales);
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('matrixTable').style.display = 'table';
            document.getElementById('noData').style.display = 'none';
        }

        // Fix the sortHeroes function - Tournament column sorting was broken:
        function sortHeroes(heroTotals, column, direction) {
            return [...heroTotals].sort((a, b) => {
                let aVal, bVal;
                
                if (column === 'hero') {
                    aVal = a.hero;
                    bVal = b.hero;
                    // String comparison
                    if (direction === 'asc') {
                        return aVal.localeCompare(bVal);
                    } else {
                        return bVal.localeCompare(aVal);
                    }
                } else if (column === 'total') {
                    aVal = a.total;
                    bVal = b.total;
                } else if (column === 'median') {
                    aVal = a.median;
                    bVal = b.median;
                } else if (column.startsWith('T')) {
                    // Fix tournament column sorting
                    const tournNum = parseInt(column.substring(1));
                    // Find the index of this tournament number in the values array
                    const tournamentNumbers = Object.keys(matrix[a.hero] || {}).map(Number).sort((x, y) => x - y);
                    const tournIndex = tournamentNumbers.indexOf(tournNum);
                    aVal = tournIndex >= 0 ? (a.values[tournIndex] || 0) : 0;
                    bVal = tournIndex >= 0 ? (b.values[tournIndex] || 0) : 0;
                }
                
                // Numeric comparison for non-hero columns (only using reward_value_added, not stars)
                if (column !== 'hero') {
                    if (direction === 'asc') {
                        return aVal - bVal;
                    } else {
                        return bVal - aVal;
                    }
                }
            });
        }

        // Update color calculation function to accept scale type
        function getValueColor(value, colorScale, type) {
            if (colorScale.max === colorScale.min) {
                return { backgroundColor: '#2d2d2d', color: '#ffffff' };
            }
            
            if (value === 0) {
                return { backgroundColor: '#2d2d2d', color: '#888888' };
            }
            
            // Normalize value between 0 and 1
            const normalized = (value - colorScale.min) / (colorScale.max - colorScale.min);
            
            // Get background color based on type and normalized value
            let backgroundColor;
            if (type === 'matrix') {
                backgroundColor = getMatrixBackgroundColor(normalized);
            } else if (type === 'total') {
                backgroundColor = getTotalBackgroundColor(normalized);
            } else if (type === 'median') {
                backgroundColor = getMedianBackgroundColor(normalized);
            } else {
                backgroundColor = getMatrixBackgroundColor(normalized); // Default
            }
            
            // Determine text color based on background brightness
            const rgb = hexToRgb(backgroundColor);
            const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            const textColor = brightness > 128 ? '#000000' : '#ffffff';
            
            return { backgroundColor, color: textColor };
        }

        // Matrix (tournament) color palette - Green to Red scale
        function getMatrixBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#006837';
            if (normalized >= 0.8) return '#18954e';
            if (normalized >= 0.7) return '#42ab5a';
            if (normalized >= 0.6) return '#70c164';
            if (normalized >= 0.5) return '#a2d769';
            if (normalized >= 0.4) return '#d1eb85';
            if (normalized >= 0.3) return '#edf7a7';
            if (normalized >= 0.2) return '#fef9b5';
            if (normalized >= 0.1) return '#fdd884';
            if (normalized >= 0.05) return '#f7864e';
            return '#a50026';
        }

        // Total color palette - Blue scale
        function getTotalBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#08306b';
            if (normalized >= 0.8) return '#08519c';
            if (normalized >= 0.7) return '#3182bd';
            if (normalized >= 0.6) return '#6baed6';
            if (normalized >= 0.5) return '#9ecae1';
            if (normalized >= 0.4) return '#c6dbef';
            if (normalized >= 0.3) return '#deebf7';
            if (normalized >= 0.2) return '#f7fbff';
            if (normalized >= 0.1) return '#fee8c8';
            if (normalized >= 0.05) return '#fd8d3c';
            return '#d94701';
        }

        // Median color palette - Purple scale
        function getMedianBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#3f007d';
            if (normalized >= 0.8) return '#54278f';
            if (normalized >= 0.7) return '#756bb1';
            if (normalized >= 0.6) return '#9e9ac8';
            if (normalized >= 0.5) return '#bcbddc';
            if (normalized >= 0.4) return '#dadaeb';
            if (normalized >= 0.3) return '#efedf5';
            if (normalized >= 0.2) return '#fcfbfd';
            if (normalized >= 0.1) return '#fee0d2';
            if (normalized >= 0.05) return '#fc9272';
            return '#de2d26';
        }

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Update the renderTable function to pass the type parameter:
        function renderTable(heroTotals, tournamentNumbers, matrix, starsMatrix, colorScales) {
            const tableHeader = document.getElementById('tableHeader');
            const tableBody = document.getElementById('tableBody');

            // Create header with sorting
            let headerHTML = '<tr>';
            
            // Hero header (sortable)
            const heroSortClass = currentSort.column === 'hero' ? `sort-${currentSort.direction}` : '';
            headerHTML += `<th class="hero-col sortable ${heroSortClass}" onclick="handleSort('hero')">Hero</th>`;
            
            // Tournament headers (sortable)
            tournamentNumbers.forEach(tournNum => {
                const colName = `T${tournNum}`;
                const sortClass = currentSort.column === colName ? `sort-${currentSort.direction}` : '';
                headerHTML += `<th class="value-cell sortable ${sortClass}" onclick="handleSort('${colName}')">${colName}</th>`;
            });
            
            // Total and Median headers (sortable)
            const totalSortClass = currentSort.column === 'total' ? `sort-${currentSort.direction}` : '';
            const medianSortClass = currentSort.column === 'median' ? `sort-${currentSort.direction}` : '';
            headerHTML += `<th class="total-col sortable ${totalSortClass}" onclick="handleSort('total')">Total</th>`;
            headerHTML += `<th class="total-col sortable ${medianSortClass}" onclick="handleSort('median')">Median</th>`;
            headerHTML += '</tr>';
            tableHeader.innerHTML = headerHTML;

            // Create body rows with type-specific color scaling
            let bodyHTML = '';
            heroTotals.forEach(({ hero, total, median }) => {
                bodyHTML += '<tr>';
                bodyHTML += `<td class="hero-col">${hero}</td>`;
                
                tournamentNumbers.forEach(tournNum => {
                    const value = matrix[hero][tournNum] || 0;
                    const stars = starsMatrix[hero][tournNum] || 0;
                    const colors = getValueColor(value, colorScales.matrix, 'matrix'); // Pass 'matrix' type
                    
                    if (value === 0) {
                        bodyHTML += `<td class="value-cell" style="background-color: ${colors.backgroundColor}; color: ${colors.color};">-</td>`;
                    } else {
                        const formattedValue = formatCurrency(value);
                        const starDisplay = stars > 0 ? ` (${stars} <i class="fas fa-star" style="color: #ffd700;"></i>)` : '';
                        bodyHTML += `<td class="value-cell" style="background-color: ${colors.backgroundColor}; color: ${colors.color};">${formattedValue}${starDisplay}</td>`;
                    }
                });
                
                const totalColors = getValueColor(total, colorScales.total, 'total');     // Pass 'total' type
                const medianColors = getValueColor(median, colorScales.median, 'median'); // Pass 'median' type
                bodyHTML += `<td class="total-col" style="background-color: ${totalColors.backgroundColor}; color: ${totalColors.color};">${formatCurrency(total)}</td>`;
                bodyHTML += `<td class="total-col" style="background-color: ${medianColors.backgroundColor}; color: ${medianColors.color};">${formatCurrency(median)}</td>`;
                bodyHTML += '</tr>';
            });
            tableBody.innerHTML = bodyHTML;
        }

        // Add sort handler
        function handleSort(column) {
            // If clicking the same column, toggle direction
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'desc' ? 'asc' : 'desc';
            } else {
                // New column, default to descending
                currentSort.column = column;
                currentSort.direction = 'desc';
            }
            
            // Re-render the current league with new sort
            if (currentLeague) {
                renderMatrix(currentLeague);
            }
        }

        // Add the missing calculateMedian function
        function calculateMedian(values) {
            if (values.length === 0) return 0;
            
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            
            if (sorted.length % 2 === 0) {
                return (sorted[mid - 1] + sorted[mid]) / 2;
            } else {
                return sorted[mid];
            }
        }

        // Add the missing formatCurrency function
        function formatCurrency(value) {
            if (value === 0) return '0';
            if (Math.abs(value) < 0.001) {
                // For very small values, show more decimal places
                return value.toFixed(6);
            } else if (Math.abs(value) < 1) {
                // For values less than 1, show 4 decimal places
                return value.toFixed(4);
            } else {
                // For larger values, show 2 decimal places
                return value.toFixed(2);
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            fetchRewardsData();
        });
    </script>
</body>
</html>