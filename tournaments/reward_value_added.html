<!DOCTYPE html>
<html>
<head>
    <title>Hero Profitability (RVA)</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXJ5Q7LKKE"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LXJ5Q7LKKE');
    </script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../../styles.css?v=8e4c2f">
    <link rel="icon" type="image/png" href="../../icons/favicon.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        :root{
            /* Adjustable column widths - change these values to control layout */
            --col-hero-width: 150px;    /* left hero column */
            --col-avg-width: 45px;     /* Avg Per App summary column */
            --col-roi-width: 45px;      /* ROI summary column (far right) */
            --col-total-width: 50px;  /* width for Total RVA summary column (customizable) */
            --col-tournament-width: 60px; /* width for each tournament number column (default 80px) */
        }
        
        .hero-image {
            width: 32px;        /* Fixed small width */
            height: auto;       /* Maintain original aspect ratio */
            border-radius: 0px;
            object-fit: contain; /* Preserve card proportions */
            flex-shrink: 0;
        }

        /* Restrict matrix to 80% of viewport and center it */
        .matrix-container {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            min-height: 0; /* important for flex children with overflow */
            overflow: hidden; /* Prevent container overflow */
            width: 80%;            /* limit width to 80% of viewport */
            max-width: 80vw;       /* defensive clamp for very small screens */
            margin: 0 auto;        /* center horizontally */
            box-sizing: border-box;
            padding-left: 8px;     /* optional breathing room */
            padding-right: 8px;
        }

        .matrix-scroll-wrapper {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            overflow-x: auto;
            border: 1px solid #444;
            border-radius: 6px;
            background: #222;
            width: 100%;            /* ensure it fills the container */
            box-sizing: border-box;
        }
        
        .league-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            border-bottom: 2px solid #555;
        }
        
        .league-tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            border-radius: 5px 5px 0 0;
            transition: all 0.18s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            background: transparent;              /* JS will set league color */
            color: #fff;                           /* default text color */
            border-bottom: 2px solid transparent;  /* JS will set border color */
        }
        
        .league-tab:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
        }

        .league-tab .league-icon {
            width: 20px;
            height: 20px;
            vertical-align: middle;
        }

        /* Visual emphasis for the active tab (JS will set exact background + text color) */
        .league-tab.active {
            box-shadow: 0 4px 10px rgba(0,0,0,0.35);
            transform: translateY(-2px);
        }

        /* Make body and html full height */
        html, body {
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent page-level scrolling */
        }

        /* Main container should be full height flex */
        body {
            display: flex;
            flex-direction: column;
        }

        /* Title container should not grow */
        .title-container {
            flex-shrink: 0;
        }

        /* League tabs should not grow */
        .league-tabs {
            flex-shrink: 0;
        }

        .matrix-container {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            min-height: 0; /* important for flex children with overflow */
            overflow: hidden; /* Prevent container overflow */
        }
        
        .matrix-scroll-wrapper {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            overflow-x: auto;
            border: 1px solid #444;
            border-radius: 6px;
            background: #222;
            width: 100%;            /* ensure it fills the container */
            box-sizing: border-box;
        }
        
        .matrix-scroll-wrapper {
            scrollbar-width: thin;
            scrollbar-color: #444 #222;
        }

        /* For Webkit browsers (Chrome, Edge, Safari) */
        .matrix-scroll-wrapper::-webkit-scrollbar {
            width: 8px;
            background: #222;
        }
        .matrix-scroll-wrapper::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 6px;
        }
        .matrix-scroll-wrapper::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        .matrix-scroll-wrapper::-webkit-scrollbar-corner {
            background: #222;
        }

        .matrix-table thead th {
            position: sticky;
            top: 0;
            background: #222;
            z-index: 2;
        }

        .summary-col {
            border-left: 2px solid #555; /* Subtle left border */
            background-color: rgba(255, 255, 255, 0.05); /* Slightly different background */
            padding: 0 12px; /* Add horizontal padding for spacing */
        }

        /* Column width controls using CSS variables */
        .matrix-table th.hero-col,
        .matrix-table td.hero-col { 
            width: var(--col-hero-width);
            min-width: var(--col-hero-width);
            max-width: var(--col-hero-width);
        }
        .matrix-table th.avg-per-app-col,
        .matrix-table td.avg-per-app-col {
            width: var(--col-avg-width);
            min-width: var(--col-avg-width);
            max-width: var(--col-avg-width);
            text-align: right;
        }
        .matrix-table th.roi-col,
        .matrix-table td.roi-col {
            width: var(--col-roi-width);
            min-width: var(--col-roi-width);
            max-width: var(--col-roi-width);
            text-align: right;
        }
        /* Total RVA column width (customizable via --col-total-width) */
        .matrix-table th.total-col,
        .matrix-table td.total-col {
            width: var(--col-total-width);
            min-width: var(--col-total-width);
            max-width: var(--col-total-width);
            text-align: right;
            /* Make Total column header & values a bit larger; color should be set by JS based on background brightness */
            font-size: 1.08em;
            color: inherit;
        }

        /* Hide star information by default */
        .star-info {
            display: none;
        }

        /* Show star information when hovering over the table row */
        .matrix-table tbody tr:hover .star-info {
            display: inline;
        }

        /* Optional: Add a subtle transition for smooth appearance */
        .star-info {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .matrix-table tbody tr:hover .star-info {
            display: inline;
            opacity: 1;
        }

        /* Style for the dynamic info row */
        .info-row {
            background-color: #333 !important;
            border-top: 1px solid #555;
            border-bottom: 1px solid #555;
            font-size: 0.9em;
            color: #ccc;
            height: 40px; /* Fixed height to prevent jumping */
        }

        .info-row td {
            padding: 4px 8px !important;
            background-color: #333 !important;
            border: none !important;
            text-align: center;
            font-style: italic;
            vertical-align: middle;
            width: inherit; /* Inherit width from parent column */
            min-width: inherit;
            max-width: inherit;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Hide info rows by default */
        .info-row {
            display: none;
        }

        /* Show info row when hovering over tournament value cells only */
        .matrix-table tbody tr .value-cell:hover + * + * + * + .info-row,
        .matrix-table tbody tr:has(.value-cell:hover) + .info-row {
            display: table-row;
        }

        /* Alternative approach: use class-based hover detection */
        .matrix-table tbody tr.show-info + .info-row {
            display: table-row;
        }

        /* Keep info row visible when hovering over it */
        .info-row:hover {
            display: table-row;
        }

        /* Fixed table layout to prevent resizing */
        .matrix-table {
            table-layout: fixed;
            width: 100%;
        }

        /* Fixed width for tournament columns */
        .value-cell {
            width: var(--col-tournament-width);
            min-width: var(--col-tournament-width);
            max-width: var(--col-tournament-width);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .hero-column {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .hero-info {
            display: flex;
            flex-direction: column;
            line-height: 1.05;
            align-items: flex-start;
        }
        .hero-name-text {
            display: inline-block;
            font-weight: 600;
        }
        .rarity-badge {
            display: inline-block;
            padding: 1px 5px 2px 5px;
            margin-top: 2px;
            border-radius: 8px;
            font-size: 8.5px; /* ~15% smaller than 10px */
            font-weight: 600;
            line-height: 1;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            border: 1px solid rgba(0,0,0,0.25);
            box-shadow: 0 0 2px rgba(0,0,0,0.35);
        }
        .rarity-badge.rarity-common    { background:#ABFF2B; color:#102000; }
        .rarity-badge.rarity-rare      { background:#5FFFEA; color:#00322E; }
        .rarity-badge.rarity-epic      { background:#FF7BCF; color:#3C0025; }
        .rarity-badge.rarity-legendary { background:#CEEB7C; color:#223000; }
        .rarity-badge.rarity-all       { background:#666666; color:#ffffff; }

        /* Add skeleton loading animation */
        .skeleton {
            background: linear-gradient(90deg, #333 25%, #444 50%, #333 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
        }
        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        /* Smooth transitions */
        .matrix-table td, .matrix-table th {
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        
        /* Better hover states */
        .sortable:hover {
            background-color: rgba(255,255,255,0.1);
            cursor: pointer;
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        /* Filter container styles */
        .filter-container {
            width: 68%;
            margin: 0 auto 20px auto;
            padding: 10px 0; /* breathing room */
            background: transparent;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between; /* distribute 3 columns evenly */
            gap: 12px;
            font-size: 90%;
        }

        /* Three equal areas: left (search), center (rarity), right (display + actions) */
        .filter-left, .filter-center, .filter-right {
            flex: 1 1 0;
            display: flex;
            align-items: center;
            min-width: 0; /* allow children to shrink */
        }
        .filter-left { justify-content: flex-start; }
        .filter-center { justify-content: center; }
        .filter-right { justify-content: flex-end; gap: 8px; }

        /* Use same label styling for Search, Rarity, Display to keep visual consistency */
        .filter-container > div > label,
        .filter-container label[for="heroHandleSearch"] {
            display: block;
            margin: 0 6px 0 0;
            font-weight: 600;
            color: #fff;
            font-size: 11px;
        }
        
        .search-box {
            flex: 0 0 auto;
            width: 220px;
            position: relative;
            padding: 0; /* remove interior box padding */
            margin-right: 6px;
            background: transparent;
            border: none;
        }
        
        /* keep input styling but visually flat (no box around the whole search container) */
        .search-box .search-input-container {
            width: 100%;
            display: block;
        }
        
              #heroHandleSearch {
             width: 100%;
             box-sizing: border-box;
             padding: 8px 10px; /* Slightly smaller padding */
             padding-right: 35px;
             border: 1px solid #333;
             border-radius: 6px;
             font-size: 11px; /* Reduced from default (~14px) */
             background: #1a1a1a;
             color: #fff;
             transition: border-color 0.2s;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
         }
         
         #heroHandleSearch:focus {
             outline: none;
             border-color: #444;
         }
         
         .clear-search {
             position: absolute;
             right: 8px;
             top: 50%;
             transform: translateY(-50%);
             background: none;
             border: none;
             color: #666;
             cursor: pointer;
             padding: 3px; /* Reduced from 4px */
             display: none;
             font-size: 14px; /* Reduce to fit narrower box */
             transition: color 0.2s;
         }
         
         .clear-search:hover {
             color: #fff;
         }
         
         .clear-search.visible {
             display: block;
         }
         
         .autocomplete-results {
             position: absolute;
             top: 100%;
             left: 0;
             width: 100%; /* Use 100% of the container, which matches search box */
             background: #2a2a2a;
             border: 1px solid #333;
             border-radius: 6px;
             margin-top: 4px;
             max-height: 400px;
             overflow-y: auto;
             z-index: 1000;
             display: none;
             box-sizing: border-box;
         }
         
         .autocomplete-item {
             padding: 4px 8px;
             cursor: pointer;
             display: flex;
             align-items: center;
             gap: 8px;
             transition: background-color 0.2s;
             color: #fff;
             font-size: 12px;
         }
         
         .autocomplete-item:last-child {
             border-bottom: none;
         }
         
         .autocomplete-item:hover {
             background-color: #3a3a3a;
         }
         
         .hero-preview-pic {
             width: 21px;
             height: 21px;
             border-radius: 50%;
             object-fit: cover;
             border: 1px solid #444;
         }

            .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* Slightly reduced gap */
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            font-size: 11px; /* Reduced from 14px */
            cursor: pointer;
            padding: 5px 8px; /* Slightly smaller padding */
            border-radius: 4px;
            user-select: none;
            color: #fff;
            background: #1a1a1a;
            border: 1px solid #333;
            transition: all 0.2s;
        }
        
        .checkbox-label:hover {
            background: #3a3a3a;
        }
        
        .checkbox-label input {
            margin-right: 6px;
            accent-color: transparent;
            transform: scale(0.8); /* Reduce checkbox size by 20% */
        }
        
        /* Rarity-specific colors for checked state */
        .checkbox-label.legendary input:checked {
            accent-color: #CACBD4;
        }
        
        .checkbox-label.epic input:checked {
            accent-color: #E890FE;
        }
        
        .checkbox-label.rare input:checked {
            accent-color: #00FFE2;
        }
        
        .checkbox-label.common input:checked {
            accent-color: #94FF00;
        }
        
        /* Rarity-specific colors for label border */
        .checkbox-label.legendary {
            border-left: 3px solid #CACBD4;
        }
        
        .checkbox-label.epic {
            border-left: 3px solid #E890FE;
        }
        
        .checkbox-label.rare {
            border-left: 3px solid #00FFE2;
        }
        
        .checkbox-label.common {
            border-left: 3px solid #94FF00;
        }
        
        .clear-button {
            padding: 8px 16px; /* Slightly smaller padding */
            background-color: #2a2a2a;
            color: #fff;
            border: 1px solid #333;
            border-radius: 6px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
            font-size: 11px; /* Reduced from default */
        }
        
        .clear-button:hover {
            background-color: #3a3a3a;
        }

        /* Guide modal styles */
        .guide-button {
            padding: 6px 10px;
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #333;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            margin-right: 8px;
        }
        .guide-button:hover { background: #3a3a3a; }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
            box-sizing: border-box;
        }
        .modal-overlay.open { display: flex; }
        .modal {
            background: #1d1d1d;
            color: #fff;
            border: 1px solid #333;
            border-radius: 8px;
            max-width: 680px;
            width: 100%;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            overflow: hidden;
        }
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid #2e2e2e;
            font-weight: 700;
        }
        .modal-body {
            padding: 14px 16px;
            font-size: 13px;
            line-height: 1.45;
            color: #e6e6e6;
        }
        .modal-close {
            background: transparent;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 16px;
            padding: 6px;
        }
        .modal-close:hover { color: #fff; }
    </style>
</head>
<body>
    <div class="title-container">
        <h1 class="title-header">
            <a href="../../index.html" class="home-link">
                <i class="fas fa-home"></i>
            </a>
            Hero Profitability (based on RVA)
        </h1>
    </div>

    <div class="league-tabs" id="leagueTabs">
        <!-- Tabs will be populated dynamically -->
    </div>

    <div class="filter-container">
            <!-- Guide button left of the hero search -->
            <button id="guideButton" class="guide-button" type="button" aria-haspopup="dialog" aria-controls="guideModal">Guide</button>
            <div class="search-box">
                <label for="heroHandleSearch">Search by Hero Handle:</label>
                <div class="search-input-container">
                    <input type="text" id="heroHandleSearch" placeholder="Enter hero handle..." autocomplete="off">
                    <button class="clear-search"></button>
                </div>
                <div id="autocompleteResults" class="autocomplete-results"></div>
            </div>
            
            <div class="sell-orders-filter">
                 <label>Rarity:</label>
                 <div class="checkbox-group">
                     <label class="checkbox-label legendary">
                         <input type="checkbox" id="filterLegendary"> Legendary
                     </label>
                     <label class="checkbox-label epic">
                         <input type="checkbox" id="filterEpic"> Epic
                     </label>
                     <label class="checkbox-label rare">
                         <input type="checkbox" id="filterRare"> Rare
                     </label>
                     <label class="checkbox-label common">
                         <input type="checkbox" id="filterCommon"> Common
                     </label>
                 </div>
             </div>
            
            <div class="display-mode-toggle" id="displayModeToggle" style="align-self:center; display:flex; flex-direction:column; gap:6px; padding-top:6px;">
                <label style="font-size:80%; color:#fff; margin-bottom:4px;">Display Mode</label>
                <div style="display:flex; gap:8px; align-items:center;">
                    <label style="font-size:11px; color:#fff;"><input type="radio" name="displayMode" value="avg" checked> Avg Per Apperance</label>
                    <label style="font-size:11px; color:#fff;"><input type="radio" name="displayMode" value="total"> Total RVA</label>
                </div>
            </div>
 
             <button id="clearFilter" class="clear-button">Clear Filter</button>
         </div>

    <!-- Guide modal -->
    <div id="guideModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="guideModalTitle" aria-hidden="true">
        <div class="modal" role="document">
            <div class="modal-header">
                <div id="guideModalTitle">Rewards Value Added (RVA) — Guide</div>
                <button class="modal-close" id="guideCloseBtn" aria-label="Close guide">&times;</button>
            </div>
            <div class="modal-body">
                <p><strong>Definition</strong></p>
                <p>Rewards Value Added (RVA) is the ETH contribution a hero made to a deck.</p>
                <p><strong>Formula</strong></p>
                <pre style="background:#111;padding:10px;border-radius:6px;color:#dcdcdc;">RVA = (hero score / deck score) * (ETH won + (FRAG won / 100) * Frag Est Value)</pre>
                <p>Where <strong>Frag Est Value</strong> is <code>0.0031</code>.</p>
                <p><strong>Avg Per Appearance</strong></p>
                <p>The "Avg Per Appearance" shows Total RVA divided by Appearances for that rarity + league.</p>
                <p style="margin-top:10px;"><button id="guideCloseBtn2" class="clear-button" style="padding:6px 10px;">Close</button></p>
            </div>
        </div>
    </div>

     <!-- Wrap your table in a scrollable div -->
     <div class="matrix-container">
        <div id="loading" class="loading">
            <i class="fas fa-spinner fa-spin"></i> Loading...
        </div>
        <div class="matrix-scroll-wrapper">
            <table class="matrix-table" id="matrixTable">
                <thead id="tableHeader">
                </thead>
                <tbody id="tableBody">
                </tbody>
            </table>
        </div>
        <div id="noData" class="no-data" style="display: none;">
            No data available for the selected league.
        </div>
    </div>

    <script>
        // Initialize Supabase client
        const supabaseUrl = 'https://hhcuqhvmzwmehdsaamhn.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoY3VxaHZtendtZWhkc2FhbWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzIwMTIsImV4cCI6MjA1MDU0ODAxMn0.xJNGoFLnpnmQGLj8RY_4VLmefPmFzuOyiVHLvFtPkkE';
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);

        let allData = [];
        let currentLeague = null;
        let currentSort = { column: 'avgRewards', direction: 'desc' }; // Changed from 'median' to 'avgRewards'
        let colorScale = { min: 0, max: 1 }; // Add this missing variable
        // Only show loading overlay on the initial page load
        let initialLoad = true;

        // Search / autocomplete state
        let searchTerm = '';
        let selectedHeroKey = null;
        let selectedHeroBase = null; // when set, filter matches hero name across rarities
        let autocompleteIndex = -1;
        let heroLookupAll = {}; // map heroKey -> { name, handle, pfp }
        let heroLookupDistinct = {}; // map normalized baseName/handle -> { key: representativeHeroKey, name, handle, pfp }

        // true = show avg reward per appearance in tournament grid (default), 
        // false = show raw total reward_value_added
        let showAvgPerAppearance = true;

        // Add helper function to format ranks with trophy icons
        function formatRank(rank) {
            if (rank === 1) {
                return '<i class="fas fa-trophy" style="color: #FFD700;" title="1st Place"></i>';
            } else if (rank === 2) {
                return '<i class="fas fa-trophy" style="color: #C0C0C0;" title="2nd Place"></i>';
            } else if (rank === 3) {
                return '<i class="fas fa-trophy" style="color: #CD7F32;" title="3rd Place"></i>';
            } else {
                return `#${rank}`;
            }
        }

        // Display mode toggle setup (was missing)
        function setupDisplayModeToggle() {
            const container = document.getElementById('displayModeToggle');
            if (!container) return;
            const radios = container.querySelectorAll('input[name="displayMode"]');
            radios.forEach(r => {
                r.addEventListener('change', (e) => {
                    showAvgPerAppearance = (e.target.value === 'avg');
                    renderCurrentView();
                });
            });
        }

        // Setup rarity checkbox listeners and clear button
        function setupFilters() {
            const ids = ['filterLegendary','filterEpic','filterRare','filterCommon'];
            ids.forEach(id => {
                const cb = document.getElementById(id);
                if (cb) cb.addEventListener('change', () => renderCurrentView());
            });
            const clearBtn = document.getElementById('clearFilter');
            if (clearBtn) {
                clearBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    ids.forEach(id => { const c = document.getElementById(id); if (c) c.checked = false; });
                    renderCurrentView();
                });
            }
        }

        // Fetch data from Supabase - ADD MORE DEBUGGING
        async function fetchRewardsData() {
            try {
                console.log('Starting to fetch rewards data...');
                
                // Fetch data with exact count (no explicit .limit() was present previously)
                const { data, error, count } = await supabaseClient
                    .from('rewardsvalueadded')
                    .select(`
                         league,
                         tournament_number,
                         hero_handle,
                         hero_name,
                         hero_rarity,
                         hero_pfp_url,
                         hero_stars,
                         current_hero_stars,
                         hero_score,
                         hero_id,
                         common_avg_price,
                         reward_value_added,
                         appearances
                     `, { count: 'exact' })
 
                 if (error) {
                     console.error('Detailed error:', error);
                     
                     document.getElementById('loading').innerHTML = `
                         <div style="color: #f87171;">
                             <i class="fas fa-exclamation-triangle"></i> 
                             Error loading data: ${error.message}
                         </div>
                     `;
                     return;
                 }
 
-                console.log('Fetched data:', data.length, 'records');
-                console.log('Sample records:', data.slice(0, 10));
+                console.log('Fetched data array length:', Array.isArray(data) ? data.length : 0, 'records; server count:', count);
+                console.log('Sample records:', Array.isArray(data) ? data.slice(0, 10) : []);
                 
                 // Debug: Show unique leagues and heroes
                 const uniqueLeagues = [...new Set(data.map(row => row.league))];
                 const uniqueHeroes = [...new Set(data.map(row => row.hero_handle))];
                 console.log('Unique leagues found:', uniqueLeagues);
                 console.log('Total unique heroes:', uniqueHeroes.length);
                 console.log('Heroes list:', uniqueHeroes.slice(0, 20)); // Show first 20
                 
                 allData = data;
                 setupLeagueTabs();
                 setupSearch(); // initialize search/autocomplete once data loaded
                
            } catch (err) {
                console.error('Exception while fetching data:', err);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #f87171;">
                        <i class="fas fa-exclamation-triangle"></i> 
                        Network error: ${err.message}
                    </div>
                `;
            }
        }

        // Helper: convert hex -> {r,g,b} (already present lower in file, reused)
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // New helper: convert hex to rgba() string with alpha
        function hexToRgba(hex, alpha = 1) {
            const { r, g, b } = hexToRgb(hex);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Helper: convert any CSS color (hex, rgb, rgba, css-var) to {r,g,b}
        function parseColorToRgb(color) {
            // Create a temporary element to let the browser resolve any CSS color string
            const el = document.createElement('div');
            el.style.color = color;
            document.body.appendChild(el);
            const computed = getComputedStyle(el).color; // "rgb(r, g, b)" or "rgba(r, g, b, a)"
            document.body.removeChild(el);
            const m = computed.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
            return m ? { r: parseInt(m[1], 10), g: parseInt(m[2], 10), b: parseInt(m[3], 10) } : { r: 0, g: 0, b: 0 };
        }

        // Convert resolved color -> rgba(...) string with alpha
        function colorToRgba(color, alpha = 1) {
            const { r, g, b } = parseColorToRgb(color);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Choose readable text color (#000 or #fff) for a resolved color
        function readableTextColor(color) {
            const { r, g, b } = parseColorToRgb(color);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128 ? '#000000' : '#ffffff';
        }

        // Hero name truncation settings and helpers
        const HERO_TRUNCATE_THRESHOLD = 25; // if name length > threshold, truncate
        const HERO_TRUNCATE_SHOW = 25;      // show this many chars then '..'

        function truncateHeroName(name) {
            if (!name) return '';
            if (name.length > HERO_TRUNCATE_THRESHOLD) {
                return name.slice(0, HERO_TRUNCATE_SHOW) + '..';
            }
            return name;
        }

        function escapeHtml(str) {
            return String(str).replace(/[&<>"']/g, function (s) {
                return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]);
            });
        }

        // Helper: build a stable composite hero key from a data row
        // Format: "<heroName>||<rarity>" (rarity lowercased when present)
        function heroKeyFromRow(row) {
            if (!row) return null;
            const name = (row.hero_name || row.hero_handle || row.hero || '').toString().trim();
            if (!name) return null;
            const rarity = (row.hero_rarity || row.heroRarity || row.rarity || '').toString().trim().toLowerCase();
            return `${name}||${rarity}`;
        }
        
        // Parse a composite hero key produced by heroKeyFromRow()
        // Returns { name, rarity }
        function parseHeroKey(key) {
            if (!key) return { name: '', rarity: '' };
            const parts = String(key).split('||');
            return {
                name: parts[0] || '',
                rarity: (parts[1] || '').toLowerCase()
            };
        }
        
        // Return the base hero name for display (used when selecting a hero across rarities)
        function displayHeroBaseName(heroKey) {
            return parseHeroKey(heroKey).name || '';
        }
        
        // Build a small inline rarity badge (HTML) given a heroKey or rarity string
        function buildRarityBadge(heroKeyOrRarity) {
            let rarity = '';
            if (typeof heroKeyOrRarity === 'string' && heroKeyOrRarity.includes('||')) {
                rarity = parseHeroKey(heroKeyOrRarity).rarity;
            } else {
                rarity = (heroKeyOrRarity || '').toString().trim().toLowerCase();
            }
            if (!rarity) return '';
            const label = rarity.charAt(0).toUpperCase() + rarity.slice(1);
            const cls = `rarity-${rarity}`;
            return `<span class="rarity-badge ${cls}">${escapeHtml(label)}</span>`;
        }

        // Default league colors fallback (used if CSS variable missing)
        const defaultLeagueColors = {
            elite: '#C78BFF',
            gold: '#FFCE52',
            silver: '#A7B8CF',
            bronze: '#FE8946',
            reverse: '#84D24C'
        };

        // Desired league order
        const leagueOrder = ['Elite','Gold','Silver','Bronze', 'Reverse'];

        // Setup league tabs
        function setupLeagueTabs() {
            // Use leagueOrder and filter to only those present in data
            const leaguesInData = [...new Set(allData.map(row => row.league))];
            const leagues = leagueOrder.filter(lg => leaguesInData.includes(lg));
            const tabsContainer = document.getElementById('leagueTabs');
            tabsContainer.innerHTML = '';

            leagues.forEach(league => {
                const tab = document.createElement('button');
                tab.className = `league-tab ${league.toLowerCase()}`;
                
                // Add league icon
                const icon = document.createElement('img');
                icon.src = `../../icons/${league.toLowerCase()}.webp`;
                icon.alt = `${league} League`;
                icon.className = 'league-icon';
                icon.onerror = function() {
                    this.style.display = 'none';
                };
                
                // Add league text
                const text = document.createElement('span');
                text.textContent = league;
                
                tab.appendChild(icon);
                tab.appendChild(text);

                // Try to read CSS variable first, otherwise fallback to default map
                const cssVarName = `--league-${league.toLowerCase()}`;
                let colorValue = getComputedStyle(document.documentElement).getPropertyValue(cssVarName).trim();
                if (!colorValue) {
                    colorValue = defaultLeagueColors[league.toLowerCase()] || '#666666';
                }

                // Store resolved color string on the tab
                tab.dataset.leagueColor = colorValue;

                // Apply inactive (50% opacity) background and solid border color
                tab.style.backgroundColor = colorToRgba(colorValue, 0.4);
                tab.style.borderBottomColor = colorToRgba(colorValue, 1);
                // Set appropriate text color for contrast (works for both active/inactive backgrounds)
                tab.style.color = readableTextColor(colorValue);

                tab.onclick = () => selectLeague(league);
                tabsContainer.appendChild(tab);
            });
            
            // Add "By League" tab
            const byLeagueTab = document.createElement('button');
            byLeagueTab.className = 'league-tab by-league';
            byLeagueTab.innerHTML = `<i class="fas fa-layer-group"></i> <span>By League</span>`;
            byLeagueTab.dataset.leagueColor = '#888888';
            byLeagueTab.onclick = () => selectLeague('BY_LEAGUE');
            tabsContainer.appendChild(byLeagueTab);

            // Select first league by default
            if (leagues.length > 0) {
                selectLeague(leagues[0]);
            }
        }

        // Update selectLeague to handle "BY_LEAGUE"
        function selectLeague(league) {
            currentLeague = league;
            
            // Show loading immediately when switching tabs
            showLoading('Loading league data...');

            document.querySelectorAll('.league-tab').forEach(tab => {
                const tabText = tab.querySelector('span') ? tab.querySelector('span').textContent : '';
                const isByLeague = league === 'BY_LEAGUE' && tab.classList.contains('by-league');
                const colorValue = tab.dataset.leagueColor || '#666666';

                if (tabText === league || isByLeague) {
                    tab.classList.add('active');
                    tab.style.backgroundColor = colorToRgba(colorValue, 1);
                    tab.style.color = readableTextColor(colorValue);
                    tab.style.borderBottomColor = colorToRgba(colorValue, 1);
                } else {
                    tab.classList.remove('active');
                    tab.style.backgroundColor = colorToRgba(colorValue, 0.4);
                    tab.style.color = readableTextColor(colorValue);
                    tab.style.borderBottomColor = colorToRgba(colorValue, 1);
                }
            });

            if (league === 'BY_LEAGUE') {
                // Defer the actual heavy render so the browser can paint the loading indicator
                setTimeout(() => renderByLeagueMatrix(), 16);
            } else {
                setTimeout(() => renderMatrix(league), 16);
            }
        }

        // Build global hero lookups:
        // - heroLookupAll keyed by composite heroKey (name||rarity) - used elsewhere in the app
        // - heroLookupDistinct keyed by normalized hero handle/name to ensure autocomplete shows unique heroes
        function buildHeroLookupAll() {
            heroLookupAll = {};
            heroLookupDistinct = {};
            allData.forEach(row => {
                const key = heroKeyFromRow(row);
                if (!key) return;
                const name = (row.hero_name || row.hero_handle || '').trim();
                const handle = (row.hero_handle || row.hero_name || '').trim();
                const pfp = row.hero_pfp_url || row.hero_pfp_Url || row.heroPfpUrl || '';

                // populate full map by composite key (keeps existing behavior)
                if (!heroLookupAll[key]) {
                    heroLookupAll[key] = { name, handle, pfp };
                }

                // populate distinct map keyed by normalized base (prefer handle, then name)
                const base = (row.hero_handle || row.hero_name || '').trim();
                const baseKey = base.toLowerCase();
                if (!baseKey) return;
                // keep first-seen representative composite key for this base hero
                if (!heroLookupDistinct[baseKey]) {
                    heroLookupDistinct[baseKey] = {
                        key,       // representative composite hero key to use when selecting
                        name,
                        handle,
                        pfp
                    };
                }
            });
        }
        
        // Simple fuzzy match: true if query is substring OR chars appear in order in target
        function fuzzyMatch(query, target) {
            if (!query) return true;
            if (!target) return false;
            if (target.includes(query)) return true;
            // subsequence match
            let qi = 0;
            for (let i = 0; i < target.length && qi < query.length; i++) {
                if (target[i] === query[qi]) qi++;
            }
            return qi === query.length;
        }
        
        function setupSearch() {
            buildHeroLookupAll();
            const input = document.getElementById('heroHandleSearch');
            const results = document.getElementById('autocompleteResults');
            const clearBtn = document.querySelector('.clear-search');

            function updateSuggestions() {
                const q = (input.value || '').trim().toLowerCase();
                searchTerm = q;
                selectedHeroKey = null; // typing clears explicit selection
                selectedHeroBase = null; // typing clears base name across rarities
                autocompleteIndex = -1;
                if (!q) {
                    results.style.display = 'none';
                    clearBtn.classList.remove('visible');
                    renderCurrentView();
                    return;
                }
                clearBtn.classList.add('visible');

                // score: substring matches first, then fuzzy matches
                // iterate distinct heroes so autocomplete shows one entry per hero (not per rarity)
                const matches = Object.keys(heroLookupDistinct).map(k => {
                    const item = heroLookupDistinct[k];
                    const name = (item.name || '').toLowerCase();
                    const handle = (item.handle || '').toLowerCase();
                    const score = (name.includes(q) || handle.includes(q)) ? 2 : (fuzzyMatch(q, name) || fuzzyMatch(q, handle) ? 1 : 0);
                    // use representative composite key for selection (item.key)
                    return { key: item.key, name: item.name, handle: item.handle, pfp: item.pfp, score };
                }).filter(x => x.score > 0)
                    .sort((a, b) => b.score - a.score || a.name.localeCompare(b.name))
                    .slice(0, 12);

                if (matches.length === 0) {
                    results.innerHTML = `<div class="autocomplete-item">No matches</div>`;
                    results.style.display = 'block';
                    return;
                }

                results.innerHTML = matches.map(m => {
                    const pic = m.pfp ? `<img class="hero-preview-pic" src="${escapeHtml(m.pfp)}" onerror="this.style.display='none'">` : '';
                    // Show only the hero name in the autocomplete preview (no handle in parentheses)
                    const label = escapeHtml(m.name || m.handle || m.key);
                    return `<div class="autocomplete-item" data-key="${escapeHtml(m.key)}">${pic}<div><div>${label}</div></div></div>`;
                }).join('');
                results.style.display = 'block';
            }

            input.addEventListener('input', (e) => {
                updateSuggestions();
            });

            input.addEventListener('keydown', (e) => {
                const items = results.querySelectorAll('.autocomplete-item');
                if (!items.length) return;
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    autocompleteIndex = Math.min(autocompleteIndex + 1, items.length - 1);
                    items.forEach((it, i) => it.style.background = i === autocompleteIndex ? '#333' : '');
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    autocompleteIndex = Math.max(autocompleteIndex - 1, 0);
                    items.forEach((it, i) => it.style.background = i === autocompleteIndex ? '#333' : '');
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    const sel = items[autocompleteIndex] || items[0];
                    if (sel) {
                        const key = sel.dataset.key;
                        selectAutocompleteItem(key);
                    }
                } else if (e.key === 'Escape') {
                    hideAutocomplete();
                }
            });

            results.addEventListener('click', (ev) => {
                const el = ev.target.closest('.autocomplete-item');
                if (!el) return;
                const key = el.dataset.key;
                selectAutocompleteItem(key);
            });

            clearBtn.addEventListener('click', (ev) => {
                ev.preventDefault();
                clearSearch();
            });

            document.addEventListener('click', (ev) => {
                if (!ev.target.closest('.search-box')) {
                    hideAutocomplete();
                }
            });
        }

        function selectAutocompleteItem(key) {
            if (!key) return;
            // Select by base hero name so we show all rarities for this hero
            const base = displayHeroBaseName(key);
            selectedHeroBase = base || null;
            // keep selectedHeroKey null so filtering uses base name (not a single rarity)
            selectedHeroKey = null;
            searchTerm = '';
            const input = document.getElementById('heroHandleSearch');
            const results = document.getElementById('autocompleteResults');
            input.value = base || heroLookupAll[key]?.handle || '';
            results.style.display = 'none';
            document.querySelector('.clear-search').classList.add('visible');
            renderCurrentView();
        }

        function clearSearch() {
            selectedHeroKey = null;
            selectedHeroBase = null;
             searchTerm = '';
             autocompleteIndex = -1;
             const input = document.getElementById('heroHandleSearch');
             const results = document.getElementById('autocompleteResults');
             input.value = '';
             results.style.display = 'none';
             document.querySelector('.clear-search').classList.remove('visible');
             renderCurrentView();
         }

        function hideAutocomplete() {
            const results = document.getElementById('autocompleteResults');
            if (results) results.style.display = 'none';
        }

        // helper to re-render current view (league or by-league) after search/filter updates
        function renderCurrentView() {
            if (currentLeague === 'BY_LEAGUE') {
                renderByLeagueMatrix();
            } else if (currentLeague) {
                renderMatrix(currentLeague);
            }
        }

        // Render matrix for selected league
        function renderMatrix(league) {
            console.log('Rendering matrix for league:', league);
            const leagueData = allData.filter(row => row.league === league);
            console.log('Records for this league:', leagueData.length);
            
            if (leagueData.length === 0) {
                document.getElementById('loading').style.display = 'none';
                // Ensure loading indicator is hidden if no data
                hideLoading();
                 document.getElementById('matrixTable').style.display = 'none';
                 document.getElementById('noData').style.display = 'block';
                 return;
             }

            // Build hero -> pfp map and unique hero list using hero_name (fallback to hero_handle)
            const heroPfpMap = {};
            const heroCommonAvgMap = {};
            const heroStarsMap = {};
            const heroIdMap = {};
            const heroRarityMap = {};
            const heroSet = new Set();
            const heroLookupLocal = {}; // map heroKey -> {name, handle, pfp}
             leagueData.forEach(row => {
                 const heroKey = heroKeyFromRow(row);
                 if (!heroKey) return;
                 heroLookupLocal[heroKey] = heroLookupLocal[heroKey] || {
                     name: (row.hero_name || row.hero_handle || '').trim(),
                     handle: (row.hero_handle || row.hero_name || '').trim(),
                     pfp: row.hero_pfp_url || row.hero_pfp_Url || row.heroPfpUrl || ''
                 };
                 heroSet.add(heroKey);
                 // Store hero_id and hero_rarity for card URL generation
                 if (row.hero_id && !heroIdMap[heroKey]) heroIdMap[heroKey] = row.hero_id;
                 if (row.hero_rarity && !heroRarityMap[heroKey]) heroRarityMap[heroKey] = row.hero_rarity;
                
                // try multiple possible field names for the pfp (fallback only)
                const pfp = row.hero_pfp_url || row.hero_pfp_Url || row.heroPfpUrl || '';
                if (pfp && !heroPfpMap[heroKey]) heroPfpMap[heroKey] = pfp;
               // capture common avg price if present (use first non-null)
               if ((row.common_avg_price !== undefined && row.common_avg_price !== null) && !(heroKey in heroCommonAvgMap)) {
                   heroCommonAvgMap[heroKey] = Number(row.common_avg_price);
               }
               // Aggregate max stars
               if (row.current_hero_stars !== undefined && row.current_hero_stars !== null) {
                    if (!(heroKey in heroStarsMap) || Number(row.current_hero_stars) > heroStarsMap[heroKey]) {
                        heroStarsMap[heroKey] = Number(row.current_hero_stars);
                    }
                }
            });
            let heroes = [...heroSet].sort((a, b) => {
                   const pa = parseHeroKey(a);
                   const pb = parseHeroKey(b);
                   const n = pa.name.localeCompare(pb.name);
                   return n !== 0 ? n : pa.rarity.localeCompare(pb.rarity);
               });
           // Apply search / selection filter:
           // - selectedHeroKey (specific composite key) takes highest precedence
           // - selectedHeroBase matches hero name across all rarities
           // - otherwise use typed searchTerm fuzzy matching
           if (selectedHeroKey) {
               heroes = heroes.filter(h => h === selectedHeroKey);
           } else if (selectedHeroBase) {
               const baseLower = selectedHeroBase.toLowerCase();
               heroes = heroes.filter(h => parseHeroKey(h).name.toLowerCase() === baseLower);
           } else if (searchTerm && searchTerm.trim().length > 0) {
               const q = searchTerm.trim().toLowerCase();
               heroes = heroes.filter(h => {
                   const info = heroLookupLocal[h] || {};
                   return fuzzyMatch(q, (info.name || '').toLowerCase()) || fuzzyMatch(q, (info.handle || '').toLowerCase());
               });
           }
          // Apply rarity filter (same behavior as By-League view)
          let selectedRarities = [];
          if (document.getElementById('filterLegendary')?.checked) selectedRarities.push('legendary');
          if (document.getElementById('filterEpic')?.checked) selectedRarities.push('epic');
          if (document.getElementById('filterRare')?.checked) selectedRarities.push('rare');
          if (document.getElementById('filterCommon')?.checked) selectedRarities.push('common');
          if (selectedRarities.length > 0) {
              heroes = heroes.filter(h => selectedRarities.includes(parseHeroKey(h).rarity));
          }

            const tournamentNumbers = [...new Set(leagueData.map(row => row.tournament_number))].sort((a, b) => a - b);

            console.log('Heroes in this league:', heroes.length, heroes);
            console.log('Tournament numbers:', tournamentNumbers);

            // Create matrix data structure and store hero stars per tournament
            const matrix = {};               // will store raw total rewards per hero/tourn
            const starsMatrix = {};
            const scoreMatrix = {};
            const appearancesMatrix = {};    // will store summed appearances per hero/tourn
            heroes.forEach(hero => {
                matrix[hero] = {};
                starsMatrix[hero] = {};
                scoreMatrix[hero] = {};
                appearancesMatrix[hero] = {};
                
                tournamentNumbers.forEach(tournNum => {
                    // Use null to represent an actually absent / unknown value.
                    // This lets us distinguish "0" (a real value) from missing data.
                    matrix[hero][tournNum] = null;
                    starsMatrix[hero][tournNum] = 0;
                    scoreMatrix[hero][tournNum] = null;
                    appearancesMatrix[hero][tournNum] = null; // Initialize as null
                });
            });

            // Populate matrix with data and stars (use hero_name fallback)
            leagueData.forEach(row => {
                const heroKey = heroKeyFromRow(row);
                if (!heroKey) return;
                const tourn = row.tournament_number;
                if (matrix[heroKey] && matrix[heroKey].hasOwnProperty(tourn)) {
                    const rv = row.reward_value_added;
                    if (rv !== null && rv !== undefined) {
                        const num = Number(rv) || 0;
                        if (matrix[heroKey][tourn] === null) {
                            matrix[heroKey][tourn] = num;
                        } else {
                            matrix[heroKey][tourn] += num;
                        }
                    }
                    // Sum appearances (if provided) instead of overwriting
                    if (row.appearances !== null && row.appearances !== undefined) {
                        const app = Number(row.appearances) || 0;
                        if (appearancesMatrix[heroKey][tourn] === null) {
                            appearancesMatrix[heroKey][tourn] = app;
                        } else {
                            appearancesMatrix[heroKey][tourn] += app;
                        }
                    }
                    starsMatrix[heroKey][tourn] = (row.hero_stars !== undefined && row.hero_stars !== null)
                        ? Math.max(Number(row.hero_stars), starsMatrix[heroKey][tourn] || 0)
                        : starsMatrix[heroKey][tourn] || 0;

                    if (row.hero_score !== null && row.hero_score !== undefined) {
                        scoreMatrix[heroKey][tourn] = Math.round(Number(row.hero_score));
                    }
                }
                const pfp = row.hero_pfp_url || row.hero_pfp_Url || row.heroPfpUrl || '';
                if (pfp) heroPfpMap[heroKey] = heroPfpMap[heroKey] || pfp;
            });

            // Calculate totals and medians
            const heroTotals = heroes.map(hero => {
                // Per-tournament raw reward totals (missing => 0)
                const rawTotals = tournamentNumbers.map(t =>
                    (matrix[hero][t] === null || matrix[hero][t] === undefined) ? 0 : Number(matrix[hero][t])
                );
                // Per-tournament avg per appearance (missing => 0)
                const avgPerAppValues = tournamentNumbers.map(t => {
                    const tot = matrix[hero][t];
                    const apps = appearancesMatrix[hero][t];
                    if (tot === null || tot === undefined) return 0;
                    if (apps === null || apps === undefined || apps === 0) return 0;
                    return Number(tot) / Number(apps);
                });

                // Total = sum of raw reward_value_added across tournaments (per hero/rarity)
                const total = rawTotals.reduce((s, v) => s + v, 0);
                // Median = median of the raw per-tournament reward_value_added values
                const median = calculateMedian(rawTotals);

                const commonAvg = (heroCommonAvgMap && heroCommonAvgMap[hero] !== undefined)
                    ? Number(heroCommonAvgMap[hero])
                    : null;
                // Sum appearances from the appearancesMatrix (correctly keyed by composite hero key)
                const heroAppearances = tournamentNumbers.reduce((sum, t) => {
                    const v = appearancesMatrix[hero][t];
                    return sum + ((v === null || v === undefined) ? 0 : Number(v));
                }, 0);
                const avgRewards = heroAppearances > 0 ? total / heroAppearances : 0;
                const roi = (commonAvg && commonAvg > 0) ? (avgRewards / commonAvg) * 100 : 0;
                return { hero, total, median, values: avgPerAppValues, commonAvg, appearances: heroAppearances, avgRewards, roi };
            });

            // Calculate independent color scales
            const matrixValues = []; // will contain avg-per-app values (for tournament cell color)
            const totalValues = [];
            const medianValues = [];
            const avgRewardsValues = [];
            const roiValues = []; // Add ROI values array

            // Populate the arrays with values
            heroes.forEach(hero => {
                 tournamentNumbers.forEach(tournNum => {
                     const rawTot = matrix[hero][tournNum];
                     const apps = appearancesMatrix[hero][tournNum];
    if (rawTot !== null && rawTot !== undefined) {
        if (showAvgPerAppearance) {
            if (apps && apps > 0) {
                const avg = Number(rawTot) / Number(apps);
                matrixValues.push(avg);
            }
        } else {
            // use raw totals for matrix coloring when toggled to Total RVA
            matrixValues.push(Number(rawTot));
        }
    }
});
             });
 
            heroTotals.forEach(({ total, median, appearances, commonAvg }) => {
                totalValues.push(total);
                medianValues.push(median);
                // Add avg rewards calculation
                const avgRewards = appearances > 0 ? total / appearances : 0;
                avgRewardsValues.push(avgRewards);
                // Add ROI calculation
                const roi = (commonAvg && commonAvg > 0) ? (avgRewards / commonAvg) * 100 : 0;
                roiValues.push(roi);
            });

            // Ensure arrays are not empty before calculating min/max
            const safeMin = (arr) => arr.length > 0 ? Math.min(...arr) : 0;
            const safeMax = (arr) => arr.length > 0 ? Math.max(...arr) : 1;

            const colorScales = {
                matrix: {
                    min: safeMin(matrixValues),
                    max: safeMax(matrixValues)
                },
                total: {
                    min: safeMin(totalValues),
                    max: safeMax(totalValues)
                },
                median: {
                    min: safeMin(medianValues),
                    max: safeMax(medianValues)
                },
                avgRewards: {
                    min: safeMin(avgRewardsValues),
                    max: safeMax(avgRewardsValues)
                },
                roi: {  // Add ROI color scale
                    min: safeMin(roiValues),
                    max: safeMax(roiValues)
                }
            };

            console.log('Color scales:', colorScales);

            // Do not overwrite currentSort here — keep the user's selected sort.
            // Pass matrix/appearances and the display toggle so sorting respects Avg vs Total toggle.
            const sortedHeroTotals = sortHeroes(heroTotals, currentSort.column, currentSort.direction, tournamentNumbers, matrix, appearancesMatrix, showAvgPerAppearance);
 
              console.log('Hero totals calculated:', sortedHeroTotals.length);
 
              // Render table with independent color scales (pass heroPfpMap)
              renderTable(sortedHeroTotals, tournamentNumbers, matrix, starsMatrix, colorScales, heroPfpMap, heroStarsMap, scoreMatrix, appearancesMatrix, heroIdMap, heroRarityMap);
              
             document.getElementById('loading').style.display = 'none';
             // Hide loading when rendering is complete
             hideLoading();
            // Hide loading when rendering is complete
            hideLoading();
              document.getElementById('matrixTable').style.display = 'table';
              document.getElementById('noData').style.display = 'none';
          }
 
        // Fix the sortHeroes function - accept matrix/appearances and toggle so tournament-column sorting
        // uses avg-per-appearance or raw total depending on the UI toggle.
        function sortHeroes(heroTotals, column, direction, tournamentNumbers, matrix, appearancesMatrix, useAvgPerAppearance) {
             // Defensive: ensure tournamentNumbers is an array
             tournamentNumbers = Array.isArray(tournamentNumbers) ? tournamentNumbers : [];
  
              return [...heroTotals].sort((a, b) => {
                  let aVal, bVal;
                  
                 if (column === 'hero') {
                     const pa = parseHeroKey(a.hero || '');
                     const pb = parseHeroKey(b.hero || '');
                     const cmpName = pa.name.localeCompare(pb.name);
                     const cmp = cmpName !== 0 ? cmpName : pa.rarity.localeCompare(pb.rarity);
                      if (direction === 'asc') return cmp;
                      return -cmp;
                 } else if (column === 'total') {
                     aVal = Number(a.total) || 0;
                     bVal = Number(b.total) || 0;
                 } else if (column === 'median') {
                     aVal = Number(a.median) || 0;
                     bVal = Number(b.median) || 0;
                 } else if (column === 'avgRewards') {
                    aVal = Number(a.avgRewards) || 0;
                    bVal = Number(b.avgRewards) || 0;
                } else if (column === 'roi') {
                    aVal = Number(a.roi) || 0;
                    bVal = Number(b.roi) || 0;
                 } else if (column === 'common_avg_price') {
                    // Numeric sort for the common avg price (use hero.commonAvg).
                    // Treat null/undefined as missing so they sort to the bottom.
                    aVal = (a.commonAvg === null || a.commonAvg === undefined || isNaN(Number(a.commonAvg))) ? -Infinity : Number(a.commonAvg);
                    bVal = (b.commonAvg === null || b.commonAvg === undefined || isNaN(Number(b.commonAvg))) ? -Infinity : Number(b.commonAvg);
                } else if (column.startsWith('T')) {
                     // Tournament column sorting: use matrix + appearancesMatrix so we can respect
                     // Avg Per App vs Total RVA toggle.
                     const tournNum = parseInt(column.substring(1));
                     // derive values directly from the raw matrix for a and b
                     const aRaw = (matrix && matrix[a.hero] && matrix[a.hero][tournNum] !== null && matrix[a.hero][tournNum] !== undefined) ? Number(matrix[a.hero][tournNum]) : 0;
                     const bRaw = (matrix && matrix[b.hero] && matrix[b.hero][tournNum] !== null && matrix[b.hero][tournNum] !== undefined) ? Number(matrix[b.hero][tournNum]) : 0;
                     if (useAvgPerAppearance) {
                         const aApps = (appearancesMatrix && appearancesMatrix[a.hero] && appearancesMatrix[a.hero][tournNum]) ? Number(appearancesMatrix[a.hero][tournNum]) : 0;
                         const bApps = (appearancesMatrix && appearancesMatrix[b.hero] && appearancesMatrix[b.hero][tournNum]) ? Number(appearancesMatrix[b.hero][tournNum]) : 0;
                         aVal = (aApps > 0) ? (aRaw / aApps) : 0;
                         bVal = (bApps > 0) ? (bRaw / bApps) : 0;
                     } else {
                         aVal = aRaw;
                         bVal = bRaw;
                     }
                 } else {
                     // Unknown column -> keep original order
                     return 0;
                 }
                 
                 // Numeric comparison for non-hero columns (only reward_value_added)
                 if (direction === 'asc') {
                     return aVal - bVal;
                 } else {
                     return bVal - aVal;
                 }
             });
         }

        // Update color calculation function to accept scale type
        function getValueColor(value, colorScale, type) {
            if (colorScale.max === colorScale.min) {
                return { backgroundColor: '#2d2d2d', color: '#ffffff' };
            }
            if (value === null || value === undefined || isNaN(Number(value))) {
                return { backgroundColor: '#2d2d2d', color: '#888888' };
            }
            const v = Number(value);
            const clamped = Math.max(colorScale.min, Math.min(colorScale.max, v));
            const normalized = (clamped - colorScale.min) / (colorScale.max - colorScale.min);
            let backgroundColor;
            if (type === 'matrix') {
                backgroundColor = getMatrixBackgroundColor(normalized);
            } else if (type === 'total') {
                backgroundColor = getTotalBackgroundColor(normalized);
            } else if (type === 'median') {
                backgroundColor = getMedianBackgroundColor(normalized);
            } else if (type === 'avgRewards') {
                backgroundColor = getAvgRewardsBackgroundColor(normalized);
            } else if (type === 'roi') {
                // Reuse avg rewards palette (or create a dedicated ROI palette)
                backgroundColor = getAvgRewardsBackgroundColor(normalized);
            } else {
                backgroundColor = getMatrixBackgroundColor(normalized);
            }
            const rgb = hexToRgb(backgroundColor);
            const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            const textColor = brightness > 128 ? '#000000' : '#ffffff';
            return { backgroundColor, color: textColor };
        }

        // Matrix (tournament) color palette - Green to Red scale
        function getMatrixBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#006837';
            if (normalized >= 0.8) return '#18954e';
            if (normalized >= 0.7) return '#42ab5a';
            if (normalized >= 0.6) return '#70c164';
            if (normalized >= 0.5) return '#a2d769';
            if (normalized >= 0.4) return '#d1eb85';
            if (normalized >= 0.3) return '#edf7a7';
            if (normalized >= 0.2) return '#fef9b5';
            if (normalized >= 0.1) return '#fdd884';
            if (normalized >= 0.05) return '#f7864e';
            return '#a50026';
        }

        // Total color palette - Blue scale
        function getTotalBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#08306b';
            if (normalized >= 0.8) return '#08519c';
            if (normalized >= 0.7) return '#3182bd';
            if (normalized >= 0.6) return '#6baed6';
            if (normalized >= 0.5) return '#9ecae1';
            if (normalized >= 0.4) return '#c6dbef';
            if (normalized >= 0.3) return '#deebf7';
            if (normalized >= 0.2) return '#f7fbff';
            if (normalized >= 0.1) return '#fee8c8';
            if (normalized >= 0.05) return '#fd8d3c';
            return '#d94701';
        }

        // Median color palette - Purple scale
        function getMedianBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#3f007d';
            if (normalized >= 0.8) return '#54278f';
            if (normalized >= 0.7) return '#756bb1';
            if (normalized >= 0.6) return '#9e9ac8';
            if (normalized >= 0.5) return '#bcbddc';
            if (normalized >= 0.4) return '#dadaeb';
            if (normalized >= 0.3) return '#efedf5';
            if (normalized >= 0.2) return '#fcfbfd';
            if (normalized >= 0.1) return '#fee0d2';
            if (normalized >= 0.05) return '#fc9272';
            return '#de2d26';
        }

        // Avg Rewards color palette - Dark Green to Light Green scale
        function getAvgRewardsBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#00441b';
            if (normalized >= 0.8) return '#006d2c';
            if (normalized >= 0.7) return '#238b45';
            if (normalized >= 0.6) return '#41ae76';
            if (normalized >= 0.5) return '#66c2a4';
            if (normalized >= 0.4) return '#99d8c9';
            if (normalized >= 0.3) return '#ccece6';
            if (normalized >= 0.2) return '#edf8fb';
            if (normalized >= 0.1) return '#fee8c8';
            return '#fdd49e';
        }

        // Update the renderTable function - fix the last line:
        function renderTable(heroTotals, tournamentNumbers, matrix, starsMatrix, colorScales, heroPfpMap, heroStarsMap, scoreMatrix, appearancesMatrix, heroIdMap, heroRarityMap) {
            const tableHeader = document.getElementById('tableHeader');
            const tableBody = document.getElementById('tableBody');

            // Create header with sorting
            let headerHTML = '<tr>';
            headerHTML += `<th style="width:40px;">#</th>`; // Add rank column
            const heroSortClass = currentSort.column === 'hero' ? `sort-${currentSort.direction}` : '';
            headerHTML += `<th class="hero-col sortable ${heroSortClass}" onclick="handleSort('hero')">Hero</th>`;
            const commonSortClass = currentSort.column === 'common_avg_price' ? `sort-${currentSort.direction}` : '';
            headerHTML += `<th class="common-price-col sortable ${commonSortClass}" onclick="handleSort('common_avg_price')" style="text-align:right; width:110px;">Est Price</th>`;
            const heroStarsSortClass = currentSort.column === 'hero_stars' ? `sort-${currentSort.direction}` : '';
            headerHTML += `<th class="hero-stars-col" style="text-align:center; width:70px;">
<span title="Stars">Stars</span>
</th>`;
            tournamentNumbers.forEach(tournNum => {
                const colName = `T${tournNum}`;
                const sortClass = currentSort.column === colName ? `sort-${currentSort.direction}` : '';
                headerHTML += `<th class="value-cell sortable ${sortClass}" onclick="handleSort('${colName}')">${colName}</th>`;
            });
            // Summary columns: Avg Per App, Total, Median, ROI (ROI remains far right)
            const avgRewardsSortClass = currentSort.column === 'avgRewards' ? `sort-${currentSort.direction}` : '';
            const totalSortClass = currentSort.column === 'total' ? `sort-${currentSort.direction}` : '';
            const medianSortClass = currentSort.column === 'median' ? `sort-${currentSort.direction}` : '';
            const roiSortClass = currentSort.column === 'roi' ? `sort-${currentSort.direction}` : '';
            // New order: Avg Per App, ROI, Total, Median
            headerHTML += `<th class="total-col summary-col avg-per-app-col sortable ${avgRewardsSortClass}" onclick="handleSort('avgRewards')">Avg Per App</th>`;
            headerHTML += `<th class="total-col summary-col roi-col sortable ${roiSortClass}" onclick="handleSort('roi')">ROI</th>`;
            headerHTML += `<th class="total-col summary-col total-col sortable ${totalSortClass}" onclick="handleSort('total')">Total</th>`;
            headerHTML += `<th class="total-col summary-col median-col sortable ${medianSortClass}" onclick="handleSort('median')">Median</th>`;
            headerHTML += '</tr>';
            tableHeader.innerHTML = headerHTML;

            // Create body rows with type-specific color scaling
            let bodyHTML = '';
            heroTotals.forEach(({ hero, total, median, values, appearances }, idx) => {
                // Main data row
                bodyHTML += '<tr>';
                bodyHTML += `<td style="text-align:center;">${formatRank(idx + 1)}</td>`; // Row rank with trophy icons

                // Hero cell: generate card URL using hero_id, hero_rarity, and hero_stars
                const heroId = (heroIdMap && heroIdMap[hero]) ? heroIdMap[hero] : '';
                const heroRarity = (heroRarityMap && heroRarityMap[hero]) ? heroRarityMap[hero] : '';
                const heroStarsForCard = (heroStarsMap && heroStarsMap[hero]) ? heroStarsMap[hero] : 0;
                
                let imgHtml = '';
                if (heroId && heroRarity && heroStarsForCard) {
                    // Generate card URL: https://r2.fantasy.top/v3/{rarity}/{id}_{stars}.png
                    const cardUrl = `https://r2.fantasy.top/v3/${heroRarity}/${heroId}_${heroStarsForCard}.png`;
                    imgHtml = `<img class="hero-image" src="${escapeHtml(cardUrl)}" alt="${escapeHtml(hero)}" onerror="this.style.display='none'">`;
                } else {
                    const pfp = (heroPfpMap && heroPfpMap[hero]) ? heroPfpMap[hero] : '';
                    imgHtml = pfp ? `<img class="hero-image" src="${escapeHtml(pfp)}" alt="${escapeHtml(hero)}" onerror="this.style.display='none'">` : '';
                }

                // Truncate hero display name (use display label that includes rarity), keep full label in title
                const baseName = displayHeroBaseName(hero);
                const displayName = truncateHeroName(baseName);
                const badge = buildRarityBadge(hero);
                bodyHTML += `<td class="hero-col">
                    <div class="hero-column">
                        ${imgHtml}
                        <div class="hero-info">
                            <span class="hero-name-text" title="${escapeHtml(baseName)}">${displayName}</span>
                            ${badge}
                        </div>
                    </div>
                </td>`;

                // Common Avg Price cell (right-aligned, 3 decimals)
                const commonVal = (heroTotals && heroTotals[idx] && heroTotals[idx].commonAvg !== undefined) ? heroTotals[idx].commonAvg : null;
                const commonDisplay = formatThreeDecimals(commonVal);
                bodyHTML += `<td class="common-price-col" style="text-align:right;">${commonDisplay !== null ? commonDisplay : '-'}</td>`;

                // Hero Stars cell
                const heroStars = (heroStarsMap && heroStarsMap[hero] !== undefined) ? heroStarsMap[hero] : '';
                bodyHTML += `<td class="hero-stars-col" style="text-align:center;">${heroStars !== '' ? heroStars + ' <i class="fas fa-star" style="color:#ffd700"></i>' : '-'}</td>`;

                // Tournament columns (main data) - show avg per appearance (reward/appearances)
                // Add hover detection for expanding info rows
                tournamentNumbers.forEach(tournNum => {
                    const rawTotal = matrix[hero][tournNum];
                    const apps = appearancesMatrix[hero][tournNum];
// Determine presence depending on display mode
let hasValue = false;
let displayValue = null;
if (rawTotal !== null && rawTotal !== undefined) {
    if (showAvgPerAppearance) {
        if (apps && apps > 0) {
            hasValue = true;
            displayValue = Number(rawTotal) / Number(apps);
        }
    } else {
        // show raw total even if apps is zero/missing
        hasValue = true;
        displayValue = Number(rawTotal);
    }
}
if (!hasValue) {
    bodyHTML += `<td class="value-cell hover-expand" style="background-color: #2d2d2d; color: #888888;">-</td>`;

} else {
    const colors = getValueColor(displayValue, colorScales.matrix, 'matrix');
    const formattedValue = formatRva(displayValue);
    bodyHTML += `<td class="value-cell hover-expand" style="background-color: ${colors.backgroundColor}; color: ${colors.color};">${formattedValue}</td>`;
}
                });

                // Summary columns (main data) - ROI and Avg Per App only
                const avgRewardsPerAppearance = heroTotals[idx].avgRewards;
                const commonPrice = heroTotals[idx].commonAvg || null;
                const roi = heroTotals[idx].roi;

                // Avg Per App column (first of summary columns)
                const avgColors = getValueColor(avgRewardsPerAppearance, colorScales.avgRewards, 'avgRewards');
                const avgTooltip = `Total: ${formatCurrency(total)}, Appearances: ${appearances}`;
                bodyHTML += `<td class="total-col summary-col avg-per-app-col" style="background-color: ${avgColors.backgroundColor}; color: ${avgColors.color};" title="${avgTooltip}">${formatFourDecimals(avgRewardsPerAppearance)}</td>`;

                // ROI column (now directly after Avg Per App)
                const roiColors = getValueColor(roi, colorScales.roi, 'roi');
                const roiTooltip = `Avg Per App: ${formatFourDecimals(avgRewardsPerAppearance)}, Est Price: ${commonPrice ? formatThreeDecimals(commonPrice) : 'N/A'}`;
                bodyHTML += `<td class="total-col summary-col roi-col" style="background-color: ${roiColors.backgroundColor}; color: ${roiColors.color};" title="${roiTooltip}">${roi > 0 ? formatCurrency(roi) + '%' : '-'}</td>`;

                // Total column (blue palette)
                const totalColors = getValueColor(total, colorScales.total, 'total');
                bodyHTML += `<td class="total-col summary-col total-col" style="background-color: ${totalColors.backgroundColor}; color: ${totalColors.color};" title="Total RVA: ${formatCurrency(total)}">${formatCurrency(total)}</td>`;

                // Median column (purple palette) - median of raw per-tournament rewards
                const medianColors = getValueColor(median, colorScales.median, 'median');
                bodyHTML += `<td class="total-col summary-col median-col" style="background-color: ${medianColors.backgroundColor}; color: ${medianColors.color};" title="Median RVA: ${formatMedian(median)}">${formatMedian(median)}</td>`;
 
                 bodyHTML += '</tr>';
 
                 // Info row (stars and hero scores)
                 bodyHTML += '<tr class="info-row">';
                 bodyHTML += `<td></td>`; // Empty rank cell
                 bodyHTML += `<td>Stars & Scores</td>`; // Hero cell label
 
                 bodyHTML += `<td></td>`; // Empty est price cell
                 bodyHTML += `<td></td>`; // Empty hero stars cell
 
                 // Tournament info columns
                tournamentNumbers.forEach(tournNum => {
                    const stars = (starsMatrix[hero] && starsMatrix[hero][tournNum]) ? Number(starsMatrix[hero][tournNum]) : 0;
                    const heroScore = (scoreMatrix[hero] && scoreMatrix[hero][tournNum] !== null && scoreMatrix[hero][tournNum] !== undefined)
                        ? Number(scoreMatrix[hero][tournNum])
                        : null;
                    const tournamentAppearances = (appearancesMatrix[hero] && appearancesMatrix[hero][tournNum] !== null && appearancesMatrix[hero][tournNum] !== undefined)
                        ? Number(appearancesMatrix[hero][tournNum])
                        : null;

                    // Raw TRVA value for this hero/rarity/tournament (sum from query stored in matrix)
                    const rawRva = (matrix[hero] && matrix[hero][tournNum] !== null && matrix[hero][tournNum] !== undefined)
                        ? Number(matrix[hero][tournNum])
                        : null;

                    const lines = [];
                    // Neon-yellow star color (matches neon-green atom theme)
                    const starColor = 'rgb(255,223,0)'; // suggestion: neon-gold / star-like
                    if (stars > 0) {
                        const starSvg = `<svg width="10" height="10" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" style="vertical-align:middle;"><path d="M10 1C14.9706 1 19 5.02944 19 10C19 14.9706 14.9706 19 10 19C5.02944 19 1 14.9706 1 10C1 5.02944 5.02944 1 10 1ZM12.2139 5C11.5735 5 11.0832 5.24992 10.7441 5.75L10.2734 6.46582C10.1981 6.60544 10.0973 6.67578 9.97168 6.67578C9.87123 6.67575 9.78335 6.60541 9.70801 6.46582L9.2373 5.75C8.89822 5.24983 8.408 5 7.76758 5C7.31556 5.00002 6.93907 5.13981 6.6377 5.41895C6.33628 5.69818 6.18555 6.05886 6.18555 6.50098C6.18557 6.7452 6.25453 6.99512 6.39258 7.25098L6.84473 8.00195L6.91992 8.21094C6.91992 8.37382 6.79415 8.45508 6.54297 8.45508H5.6582C5.18097 8.45508 4.78467 8.60668 4.4707 8.90918C4.15681 9.21165 4.00002 9.57243 4 9.99121C4 10.4216 4.15684 10.7824 4.4707 11.0732C4.78467 11.3757 5.18097 11.5273 5.6582 11.5273H6.54297C6.79415 11.5273 6.91992 11.6145 6.91992 11.7891C6.91984 11.8006 6.91384 11.8127 6.90137 11.8242C6.90128 11.8474 6.89431 11.8765 6.88184 11.9111C6.86935 11.9458 6.85721 11.9749 6.84473 11.998L6.39258 12.749C6.25453 12.9584 6.18556 13.2083 6.18555 13.499C6.18555 13.9411 6.33628 14.3018 6.6377 14.5811C6.95164 14.8602 7.34105 15 7.80566 15C8.48357 14.9999 8.96104 14.7501 9.2373 14.25L9.70801 13.5342C9.78335 13.3946 9.87123 13.3242 9.97168 13.3242C10.0973 13.3242 10.1981 13.3946 10.2734 13.5342L10.7441 14.25C10.9828 14.75 11.4601 15 12.1758 15C12.6404 15 13.0168 14.8543 13.3057 14.5635C13.6071 14.2842 13.7578 13.9295 13.7578 13.499C13.7578 13.1502 13.7078 12.9003 13.6074 12.749L13.1367 11.998C13.0865 11.905 13.0615 11.8237 13.0615 11.7539C13.0615 11.6027 13.1743 11.5273 13.4004 11.5273H14.3418C14.8064 11.5273 15.1958 11.3756 15.5098 11.0732C15.8363 10.7824 16 10.4217 16 9.99121C16 9.57239 15.8363 9.21167 15.5098 8.90918C15.1833 8.60685 14.7938 8.45508 14.3418 8.45508H13.4004C13.1743 8.45508 13.0615 8.3857 13.0615 8.24609C13.0615 8.17631 13.0865 8.09499 13.1367 8.00195L13.6074 7.25098C13.7329 6.98348 13.7959 6.75641 13.7959 6.57031C13.7958 6.15172 13.6449 5.78567 13.3438 5.47168C13.0424 5.15763 12.6658 5.00008 12.2139 5Z" fill="${starColor}"></path></svg>`;
                        lines.push(`${starSvg} <span style="color: ${starColor}; font-weight:600; margin-left:4px; display:inline-block;">${stars}</span>`);
                     }
                     if (heroScore !== null) {
                         // Atom SVG provided by user with both paths filled in the requested neon color
                        const atomSvg = `<svg width="10" height="10.5" viewBox="0 0 20 21" fill="none" xmlns="http://www.w3.org/2000/svg" aria-label="Atom" role="img" style="vertical-align:middle;"><path d="M10.0684 8.49609C10.6166 8.4962 11.1426 8.71387 11.5303 9.10156C11.9181 9.48944 12.1357 10.0159 12.1357 10.5645C12.1357 11.1128 11.9179 11.6385 11.5303 12.0264C11.1426 12.4141 10.6167 12.6327 10.0684 12.6328C9.51989 12.6328 8.99328 12.4142 8.60547 12.0264C8.21788 11.6386 8.00003 11.1128 8 10.5645C8 10.0159 8.21766 9.48944 8.60547 9.10156C8.99328 8.71372 9.51992 8.49609 10.0684 8.49609Z" fill="rgb(187,255,0)"></path><path d="M14.6417 1.05889C15.9247 0.888547 17.2346 1.06482 18.213 1.89092L18.4181 2.07842L18.4191 2.07939L18.5489 2.21904C19.7639 3.58031 19.6744 5.59723 19.0597 7.46611L18.9259 7.8499C18.638 8.62639 18.2492 9.43317 17.7648 10.2483C18.2494 11.0638 18.6379 11.871 18.9259 12.6478L19.0597 13.0315C19.6957 14.965 19.7702 17.0578 18.4191 18.4183L18.4181 18.4192C17.3621 19.4658 15.87 19.6484 14.3937 19.3968C14.1719 19.4772 13.9358 19.5118 13.7003 19.4895C13.4387 19.4647 13.1869 19.375 12.9679 19.2298C12.7487 19.0843 12.5681 18.8862 12.4435 18.6546C12.3191 18.4231 12.2536 18.1645 12.253 17.9017V17.8978L12.2609 17.7591C12.2929 17.4381 12.4212 17.1329 12.631 16.8851C12.8711 16.6016 13.2038 16.4106 13.5695 16.345C13.9348 16.2797 14.3115 16.3435 14.6349 16.5257C14.9104 16.681 15.1314 16.9147 15.2736 17.1946C16.0544 17.2456 16.5326 17.047 16.7902 16.7894L16.8683 16.7015C17.2467 16.223 17.4109 15.1859 16.7687 13.4505V13.4495C16.6334 13.08 16.4787 12.7174 16.3068 12.3636C15.7488 13.0743 15.133 13.7723 14.4601 14.4534L14.4611 14.4544C12.5974 16.3896 10.3475 17.912 7.85852 18.9231L7.85168 18.9261C5.81663 19.6802 3.53295 19.8604 2.08215 18.4192L2.08117 18.4183C0.640139 16.9673 0.820325 14.6832 1.57434 12.6478L1.69348 12.3401C1.96607 11.6588 2.31361 10.9565 2.73449 10.2483C2.27794 9.48535 1.88891 8.68312 1.57531 7.85088L1.57434 7.8499C0.820338 5.81451 0.640159 3.53039 2.08117 2.07939L2.08215 2.07842L2.22082 1.94756C3.67596 0.649124 5.881 0.850461 7.8507 1.57158H7.85168L8.16027 1.69072C8.8408 1.96314 9.54178 2.31131 10.2491 2.73174C11.5125 1.95128 12.9034 1.39805 14.3595 1.10283L14.3673 1.10088L14.6417 1.05889ZM4.19348 12.3655C4.01321 12.738 3.86027 13.0999 3.73254 13.4495L3.73156 13.4505C3.04668 15.3012 3.27902 16.3577 3.71008 16.7894C4.14146 17.2207 5.19868 17.4543 7.04992 16.7688L7.0509 16.7679L7.39758 16.6351C7.6377 16.5376 7.88247 16.4272 8.13293 16.306C6.66483 15.1567 5.34247 13.8339 4.19348 12.3655ZM7.04992 3.72881C5.19873 3.04346 4.14139 3.27692 3.71008 3.7083C3.3059 4.11292 3.07612 5.06744 3.6134 6.71025L3.73156 7.04814L3.73254 7.04912L3.86535 7.3958C3.9635 7.63703 4.07496 7.88286 4.19934 8.13408C4.61485 7.60465 5.05294 7.09342 5.51379 6.60283C5.48182 6.32665 5.52178 6.04528 5.63195 5.78838C5.75957 5.49117 5.97458 5.23921 6.24816 5.0667C6.52189 4.89413 6.84185 4.80847 7.16516 4.82158C7.48831 4.83469 7.79993 4.94595 8.05871 5.13994C8.31747 5.33404 8.51123 5.60289 8.61438 5.90947C8.71735 6.21597 8.72565 6.54682 8.63684 6.85771C8.54787 7.16874 8.36592 7.44588 8.11633 7.65166C7.89196 7.8365 7.6214 7.95574 7.33508 7.99834C6.66188 8.70231 6.0408 9.45434 5.47668 10.2483C6.79018 12.095 8.40388 13.7079 10.2501 15.0218C12.0963 13.7082 13.7092 12.0949 15.0226 10.2483C14.4919 9.50198 13.8663 8.74311 13.1583 8.0042L12.8292 7.66924C10.8957 5.72646 8.80996 4.37101 7.0509 3.72881H7.04992ZM16.7902 3.7083C16.5019 3.42001 15.9356 3.20032 14.9581 3.33135L14.7579 3.3626C14.0601 3.48534 13.2439 3.75964 12.3654 4.18974C13.834 5.33909 15.1564 6.66249 16.3058 8.13115C16.4859 7.75885 16.641 7.39859 16.7687 7.04912V7.04814L16.8868 6.71025C17.3884 5.1766 17.2215 4.24269 16.8683 3.79619L16.7902 3.7083Z" fill="rgb(187,255,0)"></path></svg>`;
                        lines.push(`${atomSvg} <span style="color: rgb(187,255,0); font-weight:600; margin-left:4px; display:inline-block;">${heroScore}</span>`);
                     }
                     if (tournamentAppearances !== null) lines.push(`App: ${tournamentAppearances}`);
                     if (lines.length === 0) lines.push('-');
 
                     bodyHTML += `<td>${lines.join('<br>')}</td>`;
                 });
             });
             tableBody.innerHTML = bodyHTML;
             hideLoading();

            // Show/hide elements

            document.getElementById('matrixTable').style.display = 'table';
            document.getElementById('noData').style.display = heroTotals.length === 0 ? 'block' : 'none';
         }

       
        // Add loading state management
        function showLoading(message = 'Loading...') {
            // Only show the overlay on the first (initial) load.
            if (!initialLoad) return;
            const loading = document.getElementById('loading');
            if (!loading) return;
            loading.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${message}`;
            loading.style.display = 'flex';
        }
        
        function hideLoading() {
            const loading = document.getElementById('loading');
            if (loading) loading.style.display = 'none';
            // After the first hide, mark initial load complete so future showLoading() calls are ignored.
            if (initialLoad) initialLoad = false;
        }
        
        // Add debounced sorting to prevent rapid re-renders
        let sortTimeout;
        function handleSort(column) {
            if (sortTimeout) clearTimeout(sortTimeout);
            sortTimeout = setTimeout(() => {
                // Remove the showLoading('Sorting...') call
                // If clicking the same column, toggle direction
                if (currentSort.column === column) {
                    currentSort.direction = currentSort.direction === 'desc' ? 'asc' : 'desc';
                } else {
                    currentSort.column = column;
                    currentSort.direction = 'desc';
                }
                
                // Re-render immediately without delay for smoother UX
                if (currentLeague && currentLeague !== 'BY_LEAGUE') {
                    renderMatrix(currentLeague);
                } else if (currentLeague === 'BY_LEAGUE') {
                    renderByLeagueMatrix();
                }
            }, 50); // Reduced debounce time from 150ms to 50ms
        }

        // Add the missing calculateMedian function
        function calculateMedian(values) {
            if (values.length === 0) return 0;
            
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            
            if (sorted.length % 2 === 0) {
                return (sorted[mid - 1] + sorted[mid]) / 2;
            } else {
                return sorted[mid];
            }
        }

        // General formatting for 2 decimal places
        function formatCurrency(value) {
            return Number(value).toFixed(2);
        }

        // Generic 3-decimal formatter (used for Est Price)
        function formatThreeDecimals(value) {
            if (value === null || value === undefined || isNaN(Number(value))) return '-';
            const n = Number(value);
            // If Est Price > 1 show one decimal (e.g. 2.3), otherwise keep 3 decimals for precision < 1
            return n > 1 ? n.toFixed(1) : n.toFixed(3);
        }

        // Specific formatting for median values (3 decimal places)
        function formatMedian(value) {
            return Number(value).toFixed(3);
        }

        // Specific formatting for median values (3 decimal places)
        function formatFourDecimals(value) {
            return Number(value).toFixed(4);
        }

        // RVA formatting (4 decimals for per-tournament / TRVA previews)
        function formatRva(value) {
            if (value === null || value === undefined || isNaN(Number(value))) return '-';
            return Number(value).toFixed(4);
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
             // attach toggle handler early
             setupDisplayModeToggle();
             setupFilters();
             fetchRewardsData();
         });
 
        // Guide modal behavior
        (function setupGuideModal() {
            const guideBtn = document.getElementById('guideButton');
            const modal = document.getElementById('guideModal');
            const closeBtn = document.getElementById('guideCloseBtn');
            const closeBtn2 = document.getElementById('guideCloseBtn2');
 
            if (!guideBtn || !modal) return;
 
            function openModal() {
                modal.classList.add('open');
                modal.setAttribute('aria-hidden', 'false');
                // trap focus briefly on close
                (closeBtn || closeBtn2)?.focus();
            }
            function closeModal() {
                modal.classList.remove('open');
                modal.setAttribute('aria-hidden', 'true');
                guideBtn.focus();
            }
 
            guideBtn.addEventListener('click', (e) => {
                e.preventDefault();
                openModal();
            });
            if (closeBtn) closeBtn.addEventListener('click', closeModal);
            if (closeBtn2) closeBtn2.addEventListener('click', closeModal);
 
            // click outside modal content closes it
            modal.addEventListener('click', (ev) => {
                if (ev.target === modal) closeModal();
            });
            // allow Esc to close
            document.addEventListener('keydown', (ev) => {
                if (ev.key === 'Escape' && modal.classList.contains('open')) closeModal();
            });
        })();
 
    </script>
</body>
</html>