<!DOCTYPE html>
<html>
<head>
    <title>Hero Rewards Value Added</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LXJ5Q7LKKE"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LXJ5Q7LKKE');
    </script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../../styles.css?v=8e4c2f">
    <link rel="icon" type="image/png" href="../../icons/favicon.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        .league-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            border-bottom: 2px solid #555;
        }
        
        .league-tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            border-radius: 5px 5px 0 0;
            transition: all 0.18s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            background: transparent;              /* JS will set league color */
            color: #fff;                           /* default text color */
            border-bottom: 2px solid transparent;  /* JS will set border color */
        }
        
        .league-tab:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
        }

        .league-tab .league-icon {
            width: 20px;
            height: 20px;
            vertical-align: middle;
        }

        /* Visual emphasis for the active tab (JS will set exact background + text color) */
        .league-tab.active {
            box-shadow: 0 4px 10px rgba(0,0,0,0.35);
            transform: translateY(-2px);
        }

        /* Make body and html full height */
        html, body {
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent page-level scrolling */
        }

        /* Main container should be full height flex */
        body {
            display: flex;
            flex-direction: column;
        }

        /* Title container should not grow */
        .title-container {
            flex-shrink: 0;
        }

        /* League tabs should not grow */
        .league-tabs {
            flex-shrink: 0;
        }

        .matrix-container {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            min-height: 0; /* important for flex children with overflow */
            overflow: hidden; /* Prevent container overflow */
        }
        
        .matrix-scroll-wrapper {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            overflow-x: auto;
            border: 1px solid #444;
            border-radius: 6px;
            background: #222;
            /* Remove max-height to allow full expansion */
        }
        
        .matrix-scroll-wrapper {
            scrollbar-width: thin;
            scrollbar-color: #444 #222;
        }

        /* For Webkit browsers (Chrome, Edge, Safari) */
        .matrix-scroll-wrapper::-webkit-scrollbar {
            width: 8px;
            background: #222;
        }
        .matrix-scroll-wrapper::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 6px;
        }
        .matrix-scroll-wrapper::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        .matrix-scroll-wrapper::-webkit-scrollbar-corner {
            background: #222;
        }

        .matrix-table thead th {
            position: sticky;
            top: 0;
            background: #222;
            z-index: 2;
        }

        .summary-col {
            border-left: 2px solid #555; /* Subtle left border */
            background-color: rgba(255, 255, 255, 0.05); /* Slightly different background */
            padding: 0 12px; /* Add horizontal padding for spacing */
        }

        /* Hide star information by default */
        .star-info {
            display: none;
        }

        /* Show star information when hovering over the table row */
        .matrix-table tbody tr:hover .star-info {
            display: inline;
        }

        /* Optional: Add a subtle transition for smooth appearance */
        .star-info {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .matrix-table tbody tr:hover .star-info {
            display: inline;
            opacity: 1;
        }

        /* Style for the dynamic info row */
        .info-row {
            background-color: #333 !important;
            border-top: 1px solid #555;
            border-bottom: 1px solid #555;
            font-size: 0.9em;
            color: #ccc;
            height: 40px; /* Fixed height to prevent jumping */
        }

        .info-row td {
            padding: 4px 8px !important;
            background-color: #333 !important;
            border: none !important;
            text-align: center;
            font-style: italic;
            vertical-align: middle;
            width: inherit; /* Inherit width from parent column */
            min-width: inherit;
            max-width: inherit;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Hide info rows by default */
        .info-row {
            display: none;
        }

        /* Show info row when hovering over the previous row */
        .matrix-table tbody tr:hover + .info-row {
            display: table-row;
        }

        /* Keep info row visible when hovering over it */
        .info-row:hover {
            display: table-row;
        }

        /* Fixed table layout to prevent resizing */
        .matrix-table {
            table-layout: fixed;
            width: 100%;
        }

        /* Fixed width for tournament columns */
        .value-cell {
            width: 80px; /* Adjust this value as needed */
            min-width: 80px;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="title-container">
        <h1 class="title-header">
            <a href="../../index.html" class="home-link">
                <i class="fas fa-home"></i>
            </a>
            Hero Rewards Value Added Matrix
        </h1>
    </div>

    <div class="league-tabs" id="leagueTabs">
        <!-- Tabs will be populated dynamically -->
    </div>

    <!-- Wrap your table in a scrollable div -->
    <div class="matrix-container">
        <div id="loading" class="loading">
            <i class="fas fa-spinner fa-spin"></i> Loading tournament data...
        </div>
        <div class="matrix-scroll-wrapper">
            <table class="matrix-table" id="matrixTable">
                <thead id="tableHeader">
                </thead>
                <tbody id="tableBody">
                </tbody>
            </table>
        </div>
        <div id="noData" class="no-data" style="display: none;">
            No data available for the selected league.
        </div>
    </div>

    <script>
        // Initialize Supabase client
        const supabaseUrl = 'https://hhcuqhvmzwmehdsaamhn.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoY3VxaHZtendtZWhkc2FhbWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQ5NzIwMTIsImV4cCI6MjA1MDU0ODAxMn0.xJNGoFLnpnmQGLj8RY_4VLmefPmFzuOyiVHLvFtPkkE';
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);

        let allData = [];
        let currentLeague = null;
        let currentSort = { column: 'avgRewards', direction: 'desc' }; // Changed from 'median' to 'avgRewards'
        let colorScale = { min: 0, max: 1 }; // Add this missing variable

        // Fetch data from Supabase - ADD MORE DEBUGGING
        async function fetchRewardsData() {
            try {
                console.log('Starting to fetch rewards data...');
                
                const { data, error } = await supabaseClient
                    .from('rewardsvalueadded')
                    .select(`
                        league,
                        tournament_number,
                        hero_handle,
                        hero_name,
                        hero_pfp_url,
                        hero_stars,
                        hero_score,
                        common_avg_price,
                        reward_value_added,
                        appearances
                    `)

                if (error) {
                    console.error('Detailed error:', error);
                    
                    document.getElementById('loading').innerHTML = `
                        <div style="color: #f87171;">
                            <i class="fas fa-exclamation-triangle"></i> 
                            Error loading data: ${error.message}
                        </div>
                    `;
                    return;
                }

                console.log('Fetched data:', data.length, 'records');
                console.log('Sample records:', data.slice(0, 10));
                
                // Debug: Show unique leagues and heroes
                const uniqueLeagues = [...new Set(data.map(row => row.league))];
                const uniqueHeroes = [...new Set(data.map(row => row.hero_handle))];
                console.log('Unique leagues found:', uniqueLeagues);
                console.log('Total unique heroes:', uniqueHeroes.length);
                console.log('Heroes list:', uniqueHeroes.slice(0, 20)); // Show first 20
                
                allData = data;
                setupLeagueTabs();
                
            } catch (err) {
                console.error('Exception while fetching data:', err);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #f87171;">
                        <i class="fas fa-exclamation-triangle"></i> 
                        Network error: ${err.message}
                    </div>
                `;
            }
        }

        // Helper: convert hex -> {r,g,b} (already present lower in file, reused)
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // New helper: convert hex to rgba() string with alpha
        function hexToRgba(hex, alpha = 1) {
            const { r, g, b } = hexToRgb(hex);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Helper: convert any CSS color (hex, rgb, rgba, css-var) to {r,g,b}
        function parseColorToRgb(color) {
            // Create a temporary element to let the browser resolve any CSS color string
            const el = document.createElement('div');
            el.style.color = color;
            document.body.appendChild(el);
            const computed = getComputedStyle(el).color; // "rgb(r, g, b)" or "rgba(r, g, b, a)"
            document.body.removeChild(el);
            const m = computed.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
            return m ? { r: parseInt(m[1], 10), g: parseInt(m[2], 10), b: parseInt(m[3], 10) } : { r: 0, g: 0, b: 0 };
        }

        // Convert resolved color -> rgba(...) string with alpha
        function colorToRgba(color, alpha = 1) {
            const { r, g, b } = parseColorToRgb(color);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Choose readable text color (#000 or #fff) for a resolved color
        function readableTextColor(color) {
            const { r, g, b } = parseColorToRgb(color);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128 ? '#000000' : '#ffffff';
        }

        // Hero name truncation settings and helpers
        const HERO_TRUNCATE_THRESHOLD = 25; // if name length > threshold, truncate
        const HERO_TRUNCATE_SHOW = 25;      // show this many chars then '..'

        function truncateHeroName(name) {
            if (!name) return '';
            if (name.length > HERO_TRUNCATE_THRESHOLD) {
                return name.slice(0, HERO_TRUNCATE_SHOW) + '..';
            }
            return name;
        }

        function escapeHtml(str) {
            return String(str).replace(/[&<>"']/g, function (s) {
                return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]);
            });
        }

        // Default league colors fallback (used if CSS variable missing)
        const defaultLeagueColors = {
            elite: '#C78BFF',
            gold: '#FFCE52',
            silver: '#A7B8CF',
            bronze: '#FE8946',
            reverse: '#84D24C'
        };

        // Desired league order
        const leagueOrder = ['Bronze', 'Silver', 'Elite', 'Gold', 'Reverse'];

        // Setup league tabs
        function setupLeagueTabs() {
            // Use leagueOrder and filter to only those present in data
            const leaguesInData = [...new Set(allData.map(row => row.league))];
            const leagues = leagueOrder.filter(lg => leaguesInData.includes(lg));
            const tabsContainer = document.getElementById('leagueTabs');
            tabsContainer.innerHTML = '';

            leagues.forEach(league => {
                const tab = document.createElement('button');
                tab.className = `league-tab ${league.toLowerCase()}`;
                
                // Add league icon
                const icon = document.createElement('img');
                icon.src = `../../icons/${league.toLowerCase()}.webp`;
                icon.alt = `${league} League`;
                icon.className = 'league-icon';
                icon.onerror = function() {
                    this.style.display = 'none';
                };
                
                // Add league text
                const text = document.createElement('span');
                text.textContent = league;
                
                tab.appendChild(icon);
                tab.appendChild(text);

                // Try to read CSS variable first, otherwise fallback to default map
                const cssVarName = `--league-${league.toLowerCase()}`;
                let colorValue = getComputedStyle(document.documentElement).getPropertyValue(cssVarName).trim();
                if (!colorValue) {
                    colorValue = defaultLeagueColors[league.toLowerCase()] || '#666666';
                }

                // Store resolved color string on the tab
                tab.dataset.leagueColor = colorValue;

                // Apply inactive (50% opacity) background and solid border color
                tab.style.backgroundColor = colorToRgba(colorValue, 0.4);
                tab.style.borderBottomColor = colorToRgba(colorValue, 1);
                // Set appropriate text color for contrast (works for both active/inactive backgrounds)
                tab.style.color = readableTextColor(colorValue);

                tab.onclick = () => selectLeague(league);
                tabsContainer.appendChild(tab);
            });
            
            // Add "By League" tab
            const byLeagueTab = document.createElement('button');
            byLeagueTab.className = 'league-tab by-league';
            byLeagueTab.innerHTML = `<i class="fas fa-layer-group"></i> <span>By League</span>`;
            byLeagueTab.dataset.leagueColor = '#888888';
            byLeagueTab.onclick = () => selectLeague('BY_LEAGUE');
            tabsContainer.appendChild(byLeagueTab);

            // Select first league by default
            if (leagues.length > 0) {
                selectLeague(leagues[0]);
            }
        }

        // Update selectLeague to handle "BY_LEAGUE"
        function selectLeague(league) {
            currentLeague = league;

            document.querySelectorAll('.league-tab').forEach(tab => {
                const tabText = tab.querySelector('span') ? tab.querySelector('span').textContent : '';
                const isByLeague = league === 'BY_LEAGUE' && tab.classList.contains('by-league');
                const colorValue = tab.dataset.leagueColor || '#666666';

                if (tabText === league || isByLeague) {
                    tab.classList.add('active');
                    tab.style.backgroundColor = colorToRgba(colorValue, 1);
                    tab.style.color = readableTextColor(colorValue);
                    tab.style.borderBottomColor = colorToRgba(colorValue, 1);
                } else {
                    tab.classList.remove('active');
                    tab.style.backgroundColor = colorToRgba(colorValue, 0.4);
                    tab.style.color = readableTextColor(colorValue);
                    tab.style.borderBottomColor = colorToRgba(colorValue, 1);
                }
            });

            if (league === 'BY_LEAGUE') {
                renderByLeagueMatrix();
            } else {
                renderMatrix(league);
            }
        }

        // Render matrix for selected league
        function renderMatrix(league) {
            console.log('Rendering matrix for league:', league);
            const leagueData = allData.filter(row => row.league === league);
            console.log('Records for this league:', leagueData.length);
            
            if (leagueData.length === 0) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('matrixTable').style.display = 'none';
                document.getElementById('noData').style.display = 'block';
                return;
            }

            // Build hero -> pfp map and unique hero list using hero_name (fallback to hero_handle)
            const heroPfpMap = {};
            const heroCommonAvgMap = {};
            const heroStarsMap = {};
            const heroSet = new Set();
            leagueData.forEach(row => {
                const heroName = (row.hero_name || row.hero_handle || '').trim();
                if (!heroName) return;
                heroSet.add(heroName);
                // try multiple possible field names for the pfp
                const pfp = row.hero_pfp_url || row.hero_pfp_Url || row.heroPfpUrl || '';
                if (pfp) heroPfpMap[heroName] = pfp;
               // capture common avg price if present (use first non-null)
               if ((row.common_avg_price !== undefined && row.common_avg_price !== null) && !(heroName in heroCommonAvgMap)) {
                   heroCommonAvgMap[heroName] = Number(row.common_avg_price);
               }
               // Aggregate max stars
               if ((row.hero_stars !== undefined && row.hero_stars !== null)) {
                    if (!(heroName in heroStarsMap) || Number(row.hero_stars) > heroStarsMap[heroName]) {
                        heroStarsMap[heroName] = Number(row.hero_stars);
                    }
                }
            });
            const heroes = [...heroSet].sort();

            const tournamentNumbers = [...new Set(leagueData.map(row => row.tournament_number))].sort((a, b) => a - b);

            console.log('Heroes in this league:', heroes.length, heroes);
            console.log('Tournament numbers:', tournamentNumbers);

            // Create matrix data structure and store hero stars per tournament
            const matrix = {};
            const starsMatrix = {};
            const scoreMatrix = {};
            const appearancesMatrix = {}; // Add this new matrix
            heroes.forEach(hero => {
                matrix[hero] = {};
                starsMatrix[hero] = {};
                scoreMatrix[hero] = {};
                appearancesMatrix[hero] = {}; // Initialize appearances matrix
                
                tournamentNumbers.forEach(tournNum => {
                    // Use null to represent an actually absent / unknown value.
                    // This lets us distinguish "0" (a real value) from missing data.
                    matrix[hero][tournNum] = null;
                     starsMatrix[hero][tournNum] = 0;
                     scoreMatrix[hero][tournNum] = null;
                     appearancesMatrix[hero][tournNum] = null; // Initialize as null
                });
            });

            // Populate matrix with data and stars (use hero_name fallback)
            leagueData.forEach(row => {
                const heroName = (row.hero_name || row.hero_handle || '').trim();
                if (!heroName) return;
                const tourn = row.tournament_number;
                if (matrix[heroName] && matrix[heroName].hasOwnProperty(tourn)) {
                    // Only treat reward_value_added as numeric when it's not null/undefined
                    const rv = row.reward_value_added;
                    if (rv !== null && rv !== undefined) {
                        const num = Number(rv) || 0;
                        if (matrix[heroName][tourn] === null) {
                            matrix[heroName][tourn] = num;
                        } else {
                            matrix[heroName][tourn] += num;
                        }
                    }
                    // Preserve stars if present; don't override with falsy zero unless that's intended
                    starsMatrix[heroName][tourn] = (row.hero_stars !== undefined && row.hero_stars !== null)
                        ? Number(row.hero_stars)
                        : starsMatrix[heroName][tourn] || 0;

                    // Add hero_score storage
                    if (row.hero_score !== null && row.hero_score !== undefined) {
                        scoreMatrix[heroName][tourn] = Math.round(Number(row.hero_score));
                    }
                    
                    // Add appearances storage
                    if (row.appearances !== null && row.appearances !== undefined) {
                        appearancesMatrix[heroName][tourn] = Number(row.appearances);
                    }
                }
                // preserve pfp if present
                const pfp = row.hero_pfp_url || row.hero_pfp_Url || row.heroPfpUrl || '';
                if (pfp) heroPfpMap[heroName] = heroPfpMap[heroName] || pfp;
            });

            // Calculate totals and medians
            const heroTotals = heroes.map(hero => {
                // For totals/median treat missing (null) as 0 for aggregation/median calculation
                const values = tournamentNumbers.map(tournNum => (matrix[hero][tournNum] === null || matrix[hero][tournNum] === undefined) ? 0 : Number(matrix[hero][tournNum]));
                const total = values.reduce((sum, val) => sum + val, 0);
                const median = calculateMedian(values);
                const commonAvg = (heroCommonAvgMap && heroCommonAvgMap[hero] !== undefined) ? Number(heroCommonAvgMap[hero]) : null;
                
                // Get appearances from the data for this hero
                const heroAppearances = leagueData.filter(row => {
                    const heroName = (row.hero_name || row.hero_handle || '').trim();
                    return heroName === hero;
                }).reduce((sum, row) => sum + (row.appearances || 0), 0);
                
                return { hero, total, median, values, commonAvg, appearances: heroAppearances };
            });

            // Calculate independent color scales
            const matrixValues = [];
            const totalValues = [];
            const medianValues = [];
            const avgRewardsValues = [];
            const roiValues = []; // Add ROI values array

            // Populate the arrays with values
            heroes.forEach(hero => {
                tournamentNumbers.forEach(tournNum => {
                    const v = matrix[hero][tournNum];
                    if (v !== null && v !== undefined) matrixValues.push(Number(v));
                });
            });

            heroTotals.forEach(({ total, median, appearances, commonAvg }) => {
                totalValues.push(total);
                medianValues.push(median);
                // Add avg rewards calculation
                const avgRewards = appearances > 0 ? total / appearances : 0;
                avgRewardsValues.push(avgRewards);
                // Add ROI calculation
                const roi = (commonAvg && commonAvg > 0) ? (avgRewards / commonAvg) * 100 : 0;
                roiValues.push(roi);
            });

            // Ensure arrays are not empty before calculating min/max
            const safeMin = (arr) => arr.length > 0 ? Math.min(...arr) : 0;
            const safeMax = (arr) => arr.length > 0 ? Math.max(...arr) : 1;

            const colorScales = {
                matrix: {
                    min: safeMin(matrixValues),
                    max: safeMax(matrixValues)
                },
                total: {
                    min: safeMin(totalValues),
                    max: safeMax(totalValues)
                },
                median: {
                    min: safeMin(medianValues),
                    max: safeMax(medianValues)
                },
                avgRewards: {
                    min: safeMin(avgRewardsValues),
                    max: safeMax(avgRewardsValues)
                },
                roi: {  // Add ROI color scale
                    min: safeMin(roiValues),
                    max: safeMax(roiValues)
                }
            };

            console.log('Color scales:', colorScales);

            // Do not overwrite currentSort here â€” keep the user's selected sort.
            // If heroTotals is first render and currentSort not set, currentSort was initialized globally.
            const sortedHeroTotals = sortHeroes(heroTotals, currentSort.column, currentSort.direction, tournamentNumbers);

            console.log('Hero totals calculated:', sortedHeroTotals.length);

            // Render table with independent color scales (pass heroPfpMap)
            renderTable(sortedHeroTotals, tournamentNumbers, matrix, starsMatrix, colorScales, heroPfpMap, heroStarsMap, scoreMatrix, appearancesMatrix);
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('matrixTable').style.display = 'table';
            document.getElementById('noData').style.display = 'none';
        }

        // Fix the sortHeroes function - use heroTotals.values and tournamentNumbers
        function sortHeroes(heroTotals, column, direction, tournamentNumbers) {
            // Defensive: ensure tournamentNumbers is an array
            tournamentNumbers = Array.isArray(tournamentNumbers) ? tournamentNumbers : [];

            return [...heroTotals].sort((a, b) => {
                let aVal, bVal;
                
                if (column === 'hero') {
                    aVal = a.hero || '';
                    bVal = b.hero || '';
                    // String comparison
                    if (direction === 'asc') {
                        return aVal.localeCompare(bVal);
                    } else {
                        return bVal.localeCompare(aVal);
                    }
                } else if (column === 'total') {
                    aVal = Number(a.total) || 0;
                    bVal = Number(b.total) || 0;
                } else if (column === 'median') {
                    aVal = Number(a.median) || 0;
                    bVal = Number(b.median) || 0;
                } else if (column === 'avgRewards') { // Add this new case
                    aVal = a.appearances > 0 ? a.total / a.appearances : 0;
                    bVal = b.appearances > 0 ? b.total / b.appearances : 0;
                } else if (column === 'common_avg_price') {
                    // Numeric sort for the common avg price (use hero.commonAvg).
                    // Treat null/undefined as missing so they sort to the bottom.
                    aVal = (a.commonAvg === null || a.commonAvg === undefined || isNaN(Number(a.commonAvg))) ? -Infinity : Number(a.commonAvg);
                    bVal = (b.commonAvg === null || b.commonAvg === undefined || isNaN(Number(b.commonAvg))) ? -Infinity : Number(b.commonAvg);
                } else if (column.startsWith('T')) {
                    // Tournament column sorting: find index in tournamentNumbers and read values[]
                    const tournNum = parseInt(column.substring(1));
                    const tournIndex = tournamentNumbers.indexOf(tournNum);
                    aVal = tournIndex >= 0 ? Number(a.values[tournIndex] || 0) : 0;
                    bVal = tournIndex >= 0 ? Number(b.values[tournIndex] || 0) : 0;
                } else {
                    // Unknown column -> keep original order
                    return 0;
                }
                
                // Numeric comparison for non-hero columns (only reward_value_added)
                if (direction === 'asc') {
                    return aVal - bVal;
                } else {
                    return bVal - aVal;
                }
            });
        }

        // Update color calculation function to accept scale type
        function getValueColor(value, colorScale, type) {
            if (colorScale.max === colorScale.min) {
                return { backgroundColor: '#2d2d2d', color: '#ffffff' };
            }

            // Treat truly absent values (null/undefined/NaN) as neutral grey.
            if (value === null || value === undefined || isNaN(Number(value))) {
                return { backgroundColor: '#2d2d2d', color: '#888888' };
            }

            // Normalize value between 0 and 1 (clamp inside range)
            const v = Number(value);
            const clamped = Math.max(colorScale.min, Math.min(colorScale.max, v));
            const normalized = (clamped - colorScale.min) / (colorScale.max - colorScale.min);

            // Get background color based on type and normalized value
            let backgroundColor;
            if (type === 'matrix') {
                backgroundColor = getMatrixBackgroundColor(normalized);
            } else if (type === 'total') {
                backgroundColor = getTotalBackgroundColor(normalized);
            } else if (type === 'median') {
                backgroundColor = getMedianBackgroundColor(normalized);
            } else if (type === 'avgRewards') {
                backgroundColor = getAvgRewardsBackgroundColor(normalized);
            } else {
                backgroundColor = getMatrixBackgroundColor(normalized); // Default
            }

            // Determine text color based on background brightness
            const rgb = hexToRgb(backgroundColor);
            const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
            const textColor = brightness > 128 ? '#000000' : '#ffffff';

            return { backgroundColor, color: textColor };
        }

        // Matrix (tournament) color palette - Green to Red scale
        function getMatrixBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#006837';
            if (normalized >= 0.8) return '#18954e';
            if (normalized >= 0.7) return '#42ab5a';
            if (normalized >= 0.6) return '#70c164';
            if (normalized >= 0.5) return '#a2d769';
            if (normalized >= 0.4) return '#d1eb85';
            if (normalized >= 0.3) return '#edf7a7';
            if (normalized >= 0.2) return '#fef9b5';
            if (normalized >= 0.1) return '#fdd884';
            if (normalized >= 0.05) return '#f7864e';
            return '#a50026';
        }

        // Total color palette - Blue scale
        function getTotalBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#08306b';
            if (normalized >= 0.8) return '#08519c';
            if (normalized >= 0.7) return '#3182bd';
            if (normalized >= 0.6) return '#6baed6';
            if (normalized >= 0.5) return '#9ecae1';
            if (normalized >= 0.4) return '#c6dbef';
            if (normalized >= 0.3) return '#deebf7';
            if (normalized >= 0.2) return '#f7fbff';
            if (normalized >= 0.1) return '#fee8c8';
            if (normalized >= 0.05) return '#fd8d3c';
            return '#d94701';
        }

        // Median color palette - Purple scale
        function getMedianBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#3f007d';
            if (normalized >= 0.8) return '#54278f';
            if (normalized >= 0.7) return '#756bb1';
            if (normalized >= 0.6) return '#9e9ac8';
            if (normalized >= 0.5) return '#bcbddc';
            if (normalized >= 0.4) return '#dadaeb';
            if (normalized >= 0.3) return '#efedf5';
            if (normalized >= 0.2) return '#fcfbfd';
            if (normalized >= 0.1) return '#fee0d2';
            if (normalized >= 0.05) return '#fc9272';
            return '#de2d26';
        }

        // Avg Rewards color palette - Dark Green to Light Green scale
        function getAvgRewardsBackgroundColor(normalized) {
            if (normalized >= 0.9) return '#00441b';
            if (normalized >= 0.8) return '#006d2c';
            if (normalized >= 0.7) return '#238b45';
            if (normalized >= 0.6) return '#41ae76';
            if (normalized >= 0.5) return '#66c2a4';
            if (normalized >= 0.4) return '#99d8c9';
            if (normalized >= 0.3) return '#ccece6';
            if (normalized >= 0.2) return '#edf8fb';
            if (normalized >= 0.1) return '#fee8c8';
            return '#fdd49e';
        }

        // Update the renderTable function as follows:
        function renderTable(heroTotals, tournamentNumbers, matrix, starsMatrix, colorScales, heroPfpMap, heroStarsMap, scoreMatrix, appearancesMatrix) {
            const tableHeader = document.getElementById('tableHeader');
            const tableBody = document.getElementById('tableBody');

            // Create header with sorting
            let headerHTML = '<tr>';
            headerHTML += `<th style="width:40px;">#</th>`; // Add rank column
            const heroSortClass = currentSort.column === 'hero' ? `sort-${currentSort.direction}` : '';
            headerHTML += `<th class="hero-col sortable ${heroSortClass}" onclick="handleSort('hero')">Hero</th>`;
            const commonSortClass = currentSort.column === 'common_avg_price' ? `sort-${currentSort.direction}` : '';
            headerHTML += `<th class="common-price-col sortable ${commonSortClass}" onclick="handleSort('common_avg_price')" style="text-align:right; width:110px;">Common Price</th>`;
            const heroStarsSortClass = currentSort.column === 'hero_stars' ? `sort-${currentSort.direction}` : '';
            headerHTML += `<th class="hero-stars-col" style="text-align:center; width:70px;">
    <span title="Stars">Stars</span>
</th>`;
            tournamentNumbers.forEach(tournNum => {
                const colName = `T${tournNum}`;
                const sortClass = currentSort.column === colName ? `sort-${currentSort.direction}` : '';
                headerHTML += `<th class="value-cell sortable ${sortClass}" onclick="handleSort('${colName}')">${colName}</th>`;
            });
            // Rearranged summary columns: ROI, Avg Per App, Median, Total
            const roiSortClass = currentSort.column === 'roi' ? `sort-${currentSort.direction}` : '';
            const avgRewardsSortClass = currentSort.column === 'avgRewards' ? `sort-${currentSort.direction}` : '';
            const medianSortClass = currentSort.column === 'median' ? `sort-${currentSort.direction}` : '';
            const totalSortClass = currentSort.column === 'total' ? `sort-${currentSort.direction}` : '';
            headerHTML += `<th class="total-col summary-col sortable ${roiSortClass}" onclick="handleSort('roi')">ROI</th>`;
            headerHTML += `<th class="total-col summary-col sortable ${avgRewardsSortClass}" onclick="handleSort('avgRewards')">Avg Per App</th>`;
            headerHTML += `<th class="total-col summary-col sortable ${medianSortClass}" onclick="handleSort('median')">Median</th>`;
            headerHTML += `<th class="total-col summary-col sortable ${totalSortClass}" onclick="handleSort('total')">Total</th>`;
            headerHTML += '</tr>';
            tableHeader.innerHTML = headerHTML;

            // Create body rows with type-specific color scaling
            let bodyHTML = '';
            heroTotals.forEach(({ hero, total, median, values, appearances }, idx) => {
                // Main data row
                bodyHTML += '<tr>';
                bodyHTML += `<td style="text-align:center;">${idx + 1}</td>`; // Row rank

                // Hero cell: image (if available) then name using .hero-image style
                const pfp = (heroPfpMap && heroPfpMap[hero]) ? heroPfpMap[hero] : '';
                const imgHtml = pfp ? `<img class="hero-image" src="${escapeHtml(pfp)}" alt="${escapeHtml(hero)}" onerror="this.style.display='none'">` : '';

                // Truncate hero display name when long, keep full name in title
                const displayName = truncateHeroName(hero);
                bodyHTML += `<td class="hero-col"><div class="hero-column">${imgHtml}<span class="hero-name-text" title="${escapeHtml(hero)}">${displayName}</span></div></td>`;

                // Common Avg Price cell (right-aligned, 3 decimals)
                const commonVal = (heroTotals && heroTotals[idx] && heroTotals[idx].commonAvg !== undefined) ? heroTotals[idx].commonAvg : null;
                const commonDisplay = formatThreeDecimals(commonVal);
                bodyHTML += `<td class="common-price-col" style="text-align:right;">${commonDisplay !== null ? commonDisplay : '-'}</td>`;

                // Hero Stars cell
                const heroStars = (heroStarsMap && heroStarsMap[hero] !== undefined) ? heroStarsMap[hero] : '';
                bodyHTML += `<td class="hero-stars-col" style="text-align:center;">${heroStars !== '' ? heroStars + ' <i class="fas fa-star" style="color:#ffd700"></i>' : '-'}</td>`;

                // Tournament columns (main data)
                tournamentNumbers.forEach(tournNum => {
                    const rawValue = matrix[hero][tournNum];
                    const hasValue = rawValue !== null && rawValue !== undefined;
                    const value = hasValue ? Number(rawValue) : null;

                    if (!hasValue) {
                        bodyHTML += `<td class="value-cell" style="background-color: #2d2d2d; color: #888888;">-</td>`;
                    } else {
                        const colors = getValueColor(value, colorScales.matrix, 'matrix');
                        const formattedValue = formatCurrency(value);
                        bodyHTML += `<td class="value-cell" style="background-color: ${colors.backgroundColor}; color: ${colors.color};">${formattedValue}</td>`;
                    }
                });

                // Summary columns (main data)
                const avgRewardsPerAppearance = appearances > 0 ? total / appearances : 0;
                const commonPrice = heroTotals[idx].commonAvg || null;
                const roi = (commonPrice && commonPrice > 0) ? (avgRewardsPerAppearance / commonPrice) * 100 : 0;

                // ROI column
                const roiColors = getValueColor(roi, colorScales.roi, 'roi');
                const roiTooltip = `Avg Per App: ${formatFourDecimals(avgRewardsPerAppearance)}, Common Price: ${commonPrice ? formatThreeDecimals(commonPrice) : 'N/A'}`;
                bodyHTML += `<td class="total-col summary-col" style="background-color: ${roiColors.backgroundColor}; color: ${roiColors.color};" title="${roiTooltip}">${roi > 0 ? formatCurrency(roi) + '%' : '-'}</td>`;

                // Avg Per App column
                const avgColors = getValueColor(avgRewardsPerAppearance, colorScales.avgRewards, 'avgRewards');
                const avgTooltip = `Total: ${formatCurrency(total)}, Appearances: ${appearances}`;
                bodyHTML += `<td class="total-col summary-col" style="background-color: ${avgColors.backgroundColor}; color: ${avgColors.color};" title="${avgTooltip}">${formatFourDecimals(avgRewardsPerAppearance)}</td>`;

                // Median column
                const medianColors = getValueColor(median, colorScales.median, 'median');
                bodyHTML += `<td class="total-col summary-col" style="background-color: ${medianColors.backgroundColor}; color: ${medianColors.color};">${formatMedian(median)}</td>`;

                // Total column
                const totalColors = getValueColor(total, colorScales.total, 'total');
                bodyHTML += `<td class="total-col summary-col" style="background-color: ${totalColors.backgroundColor}; color: ${totalColors.color};">${formatCurrency(total)}</td>`;

                bodyHTML += '</tr>';

                // Info row (stars and hero scores)
                bodyHTML += '<tr class="info-row">';
                bodyHTML += `<td></td>`; // Empty rank cell
                bodyHTML += `<td>Stars & Scores</td>`; // Hero cell label

                bodyHTML += `<td></td>`; // Empty common price cell
                bodyHTML += `<td></td>`; // Empty hero stars cell

                // Tournament info columns
                tournamentNumbers.forEach(tournNum => {
                    const stars = (starsMatrix[hero] && starsMatrix[hero][tournNum]) ? Number(starsMatrix[hero][tournNum]) : 0;
                    const heroScore = (scoreMatrix[hero] && scoreMatrix[hero][tournNum] !== null && scoreMatrix[hero][tournNum] !== undefined) ? Number(scoreMatrix[hero][tournNum]) : null;
                    const tournamentAppearances = (appearancesMatrix[hero] && appearancesMatrix[hero][tournNum] !== null && appearancesMatrix[hero][tournNum] !== undefined) ? Number(appearancesMatrix[hero][tournNum]) : null;
                    
                    let infoContent = '';
                    if (heroScore !== null && stars > 0 && tournamentAppearances !== null) {
                        infoContent = `Score: ${heroScore}<br>Stars: ${stars}<br>App: ${tournamentAppearances}`;
                    } else if (heroScore !== null && tournamentAppearances !== null) {
                        infoContent = `Score: ${heroScore}<br>App: ${tournamentAppearances}`;
                    } else if (stars > 0 && tournamentAppearances !== null) {
                        infoContent = `Stars: ${stars}<br>App: ${tournamentAppearances}`;
                    } else if (heroScore !== null) {
                        infoContent = `Score: ${heroScore}`;
                    } else if (stars > 0) {
                        infoContent = `Stars: ${stars}`;
                    } else if (tournamentAppearances !== null) {
                        infoContent = `App: ${tournamentAppearances}`;
                    } else {
                        infoContent = '-';
                    }
                    
                    bodyHTML += `<td>${infoContent}</td>`;
                });

                // Empty summary columns for info row
                bodyHTML += `<td></td>`; // ROI
                bodyHTML += `<td></td>`; // Avg Per App
                bodyHTML += `<td></td>`; // Median
                bodyHTML += `<td></td>`; // Total

                bodyHTML += '</tr>';
            });
            tableBody.innerHTML = bodyHTML;
        }

        // Add sort handler
        function handleSort(column) {
            // If clicking the same column, toggle direction
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'desc' ? 'asc' : 'desc';
            } else {
                // New column, default to descending
                currentSort.column = column;
                currentSort.direction = 'desc';
            }
            
            // Re-render the current league with new sort
            if (currentLeague) {
                renderMatrix(currentLeague);
            }
        }

        // Add the missing calculateMedian function
        function calculateMedian(values) {
            if (values.length === 0) return 0;
            
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            
            if (sorted.length % 2 === 0) {
                return (sorted[mid - 1] + sorted[mid]) / 2;
            } else {
                return sorted[mid];
            }
        }

        // General formatting for 2 decimal places
        function formatCurrency(value) {
            return Number(value).toFixed(2);
        }

        // Specific formatting for median values (3 decimal places)
        function formatMedian(value) {
            return Number(value).toFixed(3);
        }

        // Specific formatting for median values (3 decimal places)
        function formatFourDecimals(value) {
            return Number(value).toFixed(4);
        }


        // New helper: format number to 3 decimal places, add commas
        function formatThreeDecimals(value) {
            if (value === null || value === undefined) return null;
            return Number(value).toLocaleString(undefined, { minimumFractionDigits: 3, maximumFractionDigits: 3 });
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            fetchRewardsData();
        });

        // Add sorting handler for By League tab
        function handleByLeagueSort(column) {
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'desc' ? 'asc' : 'desc';
            } else {
                currentSort.column = column;
                currentSort.direction = column === 'hero' ? 'asc' : 'desc';
            }
            renderByLeagueMatrix();
        }

        // Render the By League summary matrix
        function renderByLeagueMatrix() {
            // Use leagueOrder and filter to only those present in data
            const leaguesInData = [...new Set(allData.map(row => row.league))];
            const leagues = leagueOrder.filter(lg => leaguesInData.includes(lg));
            const heroSet = new Set();
            const heroPfpMap = {};
            const heroCommonAvgMap = {};
            const heroStarsMap = {};
            
            allData.forEach(row => {
                const heroName = (row.hero_name || row.hero_handle || '').trim();
                if (!heroName) return;
                if ((row.hero_stars !== undefined && row.hero_stars !== null)) {
                    if (!(heroName in heroStarsMap) || Number(row.hero_stars) > heroStarsMap[heroName]) {
                        heroStarsMap[heroName] = Number(row.hero_stars);
                    }
                }
            });

            allData.forEach(row => {
                const heroName = (row.hero_name || row.hero_handle || '').trim();
                if (!heroName) return;
                heroSet.add(heroName);
                const pfp = row.hero_pfp_url || row.hero_pfp_Url || row.heroPfpUrl || '';
                if (pfp) heroPfpMap[heroName] = pfp;
                if ((row.common_avg_price !== undefined && row.common_avg_price !== null) && !(heroName in heroCommonAvgMap)) {
                    heroCommonAvgMap[heroName] = Number(row.common_avg_price);
                }
            });
            const heroes = [...heroSet].sort();

            // 2. Aggregate reward_value_added by hero and league
            const heroLeagueTotals = {};
            heroes.forEach(hero => {
                heroLeagueTotals[hero] = {};
                leagues.forEach(league => {
                    heroLeagueTotals[hero][league] = 0;
                });
            });

            allData.forEach(row => {
                const heroName = (row.hero_name || row.hero_handle || '').trim();
                const league = row.league;
                let val = row.reward_value_added;
                if (val === null || val === undefined || isNaN(Number(val))) val = 0;
                else val = Number(val);
                if (heroLeagueTotals[heroName] && league in heroLeagueTotals[heroName]) {
                    heroLeagueTotals[heroName][league] += val;
                }
            });

            // 3. Prepare data for rendering
            const summaryRows = heroes.map(hero => {
                const leagueTotals = leagues.map(lg => heroLeagueTotals[hero][lg] || 0);
                const grandTotal = leagueTotals.reduce((a, b) => a + b, 0);
                const commonAvg = (heroCommonAvgMap && heroCommonAvgMap[hero] !== undefined) ? Number(heroCommonAvgMap[hero]) : null;
                return { hero, leagueTotals, grandTotal, commonAvg };
            });

            // 4. Sort by grandTotal descending by default, or by currentSort
            let sortCol = currentSort.column;
            let sortDir = currentSort.direction;
            if (sortCol !== 'grandTotal' && sortCol !== 'hero' && !leagues.includes(sortCol) && sortCol !== 'common_avg_price') {
                sortCol = 'grandTotal';
                sortDir = 'desc';
            }
            summaryRows.sort((a, b) => {
                if (sortCol === 'hero') {
                    return sortDir === 'asc' ? a.hero.localeCompare(b.hero) : b.hero.localeCompare(a.hero);
                } else if (leagues.includes(sortCol)) {
                    const idx = leagues.indexOf(sortCol);
                    return sortDir === 'asc'
                        ? a.leagueTotals[idx] - b.leagueTotals[idx]
                        : b.leagueTotals[idx] - a.leagueTotals[idx];
                } else if (sortCol === 'common_avg_price') {
                    return sortDir === 'asc'
                        ? (a.commonAvg ?? -Infinity) - (b.commonAvg ?? -Infinity)
                        : (b.commonAvg ?? -Infinity) - (a.commonAvg ?? -Infinity);
                } else {
                    return sortDir === 'asc'
                        ? a.grandTotal - b.grandTotal
                        : b.grandTotal - a.grandTotal;
                }
            });

            // 5. Calculate total color scale for the grand total column
            const totalVals = summaryRows.map(row => row.grandTotal);
            const minTotal = Math.min(...totalVals);
            const maxTotal = Math.max(...totalVals);

            // Helper for blue-to-orange/red palette (same as league tabs)
            function getTotalPaletteColor(normalized) {
                // Blue to orange/red
                if (normalized >= 0.9) return '#08306b';
                if (normalized >= 0.8) return '#08519c';
                if (normalized >= 0.7) return '#3182bd';
                if (normalized >= 0.6) return '#6baed6';
                if (normalized >= 0.5) return '#9ecae1';
                if (normalized >= 0.4) return '#c6dbef';
                if (normalized >= 0.3) return '#deebf7';
                if (normalized >= 0.2) return '#f7fbff';
                if (normalized >= 0.1) return '#fee8c8';
                if (normalized >= 0.05) return '#fd8d3c';
                return '#d94701';
            }

            // 6. Render table header
            const tableHeader = document.getElementById('tableHeader');
            let headerHTML = '<tr>';
            headerHTML += `<th style="width:40px;">#</th>`;
            const heroSortClass = sortCol === 'hero' ? `sort-${sortDir}` : '';
            headerHTML += `<th class="hero-col sortable ${heroSortClass}" onclick="handleByLeagueSort('hero')">Hero</th>`;
            const commonSortClass = sortCol === 'common_avg_price' ? `sort-${sortDir}` : '';
            // Wrap Common Price header text
            headerHTML += `<th class="common-price-col sortable ${commonSortClass}" onclick="handleByLeagueSort('common_avg_price')" style="text-align:right; width:110px; white-space:normal; line-height:1.1;"><span style="white-space:normal;">Common<br>Price</span></th>`;
            // New Hero Stars column
            const heroStarsSortClass = sortCol === 'hero_stars' ? `sort-${sortDir}` : '';
            headerHTML += `<th class="hero-stars-col" style="text-align:center; width:70px;">
                <span title="Stars">Stars</span>
            </th>`;
            leagues.forEach(lg => {
                const sortClass = sortCol === lg ? `sort-${sortDir}` : '';
                // League icon only, no background fill
                const iconHtml = `<img class="league-icon" src="../../icons/${lg.toLowerCase()}.webp" alt="${lg}" style="width:22px;height:22px;vertical-align:middle;">`;
                headerHTML += `<th class="value-cell sortable ${sortClass}" onclick="handleByLeagueSort('${lg}')">${iconHtml}</th>`;
            });
            const totalSortClass = sortCol === 'grandTotal' ? `sort-${sortDir}` : '';
            headerHTML += `<th class="total-col sortable ${totalSortClass}" onclick="handleByLeagueSort('grandTotal')">Total</th>`;
            headerHTML += '</tr>';
            tableHeader.innerHTML = headerHTML;

            // 7. Render table body
            const tableBody = document.getElementById('tableBody');
            let bodyHTML = '';
            summaryRows.forEach((row, idx) => {
                bodyHTML += '<tr>';
                bodyHTML += `<td style="text-align:center;">${idx + 1}</td>`;
                const pfp = (heroPfpMap && heroPfpMap[row.hero]) ? heroPfpMap[row.hero] : '';
                const imgHtml = pfp ? `<img class="hero-image" src="${escapeHtml(pfp)}" alt="${escapeHtml(row.hero)}" onerror="this.style.display='none'">` : '';
                const displayName = truncateHeroName(row.hero);
                bodyHTML += `<td class="hero-col"><div class="hero-column">${imgHtml}<span class="hero-name-text" title="${escapeHtml(row.hero)}">${displayName}</span></div></td>`;
                const commonDisplay = formatThreeDecimals(row.commonAvg);
                bodyHTML += `<td class="common-price-col" style="text-align:right;">${commonDisplay !== null ? commonDisplay : '-'}</td>`;
                // Hero Stars cell
                const starsVal = (heroStarsMap && heroStarsMap[row.hero] !== undefined) ? heroStarsMap[row.hero] : 0;
                bodyHTML += `<td class="hero-stars-col" style="text-align:center;">${starsVal > 0 ? starsVal + ' <i class="fas fa-star" style="color: #ffd700;"></i>' : '-'}</td>`;
                row.leagueTotals.forEach((val, i) => {
                    const league = leagues[i];
                    
                    // Get star count for this hero in this specific league
                    const heroLeagueStars = allData
                        .filter(dataRow => {
                            const heroName = (dataRow.hero_name || dataRow.hero_handle || '').trim();
                            return heroName === row.hero && dataRow.league === league;
                        })
                        .reduce((maxStars, dataRow) => {
                            const stars = dataRow.hero_stars || 0;
                            return Math.max(maxStars, stars);
                        }, 0);
                    
                    // League color with 20% opacity
                    let colorValue = getComputedStyle(document.documentElement).getPropertyValue(`--league-${league.toLowerCase()}`).trim();
                    if (!colorValue) colorValue = defaultLeagueColors[league.toLowerCase()] || '#666666';
                    const bg = colorToRgba(colorValue, 0.2);
                    
                    // Build cell content with value and hidden stars
                    let cellContent = `<div>${formatCurrency(val)}</div>`;
                    if (heroLeagueStars > 0) {
                        cellContent += `<div class="star-info" style="font-size: 0.9em; margin-top: 4px;">(${heroLeagueStars} <i class="fas fa-star" style="color: #ffd700;"></i>)</div>`;
                    }
                    
                    bodyHTML += `<td class="value-cell" style="background:${bg}; text-align:center; vertical-align:middle; line-height:1.2;">${cellContent}</td>`;
                });
                // Total column: blue-to-orange/red palette at 20% opacity
                let norm = (maxTotal === minTotal) ? 0 : (row.grandTotal - minTotal) / (maxTotal - minTotal);
                const totalBgSolid = getTotalPaletteColor(norm);
                const totalBg = colorToRgba(totalBgSolid, 0.2);
                const totalTextColor = readableTextColor(totalBgSolid);
                bodyHTML += `<td class="total-col" style="background:${totalBg};color:${totalTextColor};">${formatCurrency(row.grandTotal)}</td>`;
                bodyHTML += '</tr>';
            });
            tableBody.innerHTML = bodyHTML;

            // Show/hide elements
            document.getElementById('loading').style.display = 'none';
            document.getElementById('matrixTable').style.display = 'table';
            document.getElementById('noData').style.display = summaryRows.length === 0 ? 'block' : 'none';
        }
    </script>
</body>
</html>